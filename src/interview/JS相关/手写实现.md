## 手写一个 new

1. 新生成了一个对象
2. 链接到原型
3. 绑定 this
4. 返回新对象

```js
// 箭头函数
const _new = (fn, ...rest) => {
  const obj = Object.create(fn.prototype);
  const result = fn.apply(obj, rest);
  return result instanceof Object ? result : obj;
};

// arguments实现
const _new1 = function () {
  const obj = {};
  const constructor = Array.prototype.shift.call(arguments);
  obj.__proto__ = constructor.prototype;
  const result = constructor.apply(obj, [...arguments]);
  return result instanceof Object ? result : obj;
};

function a(name) {
  this.xx = name;
}

const xxx = _new(a, 23);
console.log('xxx: ', xxx);
```

## 手写一个节流

```js
const throttle = (fn, interval) => {
  let last = 0;
  return (...args) => {
    const now = +new Date();
    // 还没到时间
    if (now - last < interval) return;
    last = now;
    fn.apply(this, args);
  };
};
```

## 手写一个防抖

```js
const debounce = (fn, ms = 0) => {
  let timeoutId;
  return (...args) => {
    if (timeoutId) clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), ms);
  };
};
```

## 手写一个 Promise.all

```js
Promise._all = (list) => {
  return new Promise((resolve, reject) => {
    let resValues = [];
    let counts = 0;
    for (let [i, p] of list) {
      resolve(p).then(
        (res) => {
          counts++;
          resValues[i] = res;
          if (counts === list.length) {
            resolve(resValues);
          }
        },
        (err) => {
          reject(err);
        },
      );
    }
  });
};
```

## 手写一个 Promise.race

```js
Promise._race = (promises) =>
  new Promise((resolve, reject) => {
    promises.forEach((promise) => {
      promise.then(resolve, reject);
    });
  });
```

## 手写一个 Promise.finally

```js
Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    (value) => P.resolve(callback()).then(() => value),
    (reason) =>
      P.resolve(callback()).then(() => {
        throw reason;
      }),
  );
};
```

##
