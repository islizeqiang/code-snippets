## 手写一个 new

1. 新生成了一个对象
2. 链接到原型
3. 绑定 this
4. 返回新对象

```js
// 箭头函数
const _new = (fn, ...rest) => {
  const obj = Object.create(fn.prototype);
  const result = fn.apply(obj, rest);
  return result instanceof Object ? result : obj;
};

// arguments实现
const _new1 = function () {
  const obj = {};
  const constructor = Array.prototype.shift.call(arguments);
  obj.__proto__ = constructor.prototype;
  const result = constructor.apply(obj, [...arguments]);
  return result instanceof Object ? result : obj;
};

function a(name) {
  this.xx = name;
}

const xxx = _new(a, 23);
console.log('xxx: ', xxx);
```

## 手写一个节流

```js
const throttle = (fn, interval) => {
  let last = 0;
  return (...args) => {
    const now = +new Date();
    // 还没到时间
    if (now - last < interval) return;
    last = now;
    fn.apply(this, args);
  };
};
```

## 手写一个防抖

```js
const debounce = (fn, ms = 0) => {
  let timeoutId;
  return (...args) => {
    if (timeoutId) clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), ms);
  };
};
```

## 手写一个 Promise.all

```js
Promise._all = (list) => {
  return new Promise((resolve, reject) => {
    let resValues = [];
    let counts = 0;
    for (let [i, p] of list) {
      resolve(p).then(
        (res) => {
          counts++;
          resValues[i] = res;
          if (counts === list.length) {
            resolve(resValues);
          }
        },
        (err) => {
          reject(err);
        },
      );
    }
  });
};
```

## 手写一个 Promise.race

```js
Promise._race = (promises) =>
  new Promise((resolve, reject) => {
    promises.forEach((promise) => {
      promise.then(resolve, reject);
    });
  });
```

## 手写一个 Promise.finally

```js
Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    (value) => P.resolve(callback()).then(() => value),
    (reason) =>
      P.resolve(callback()).then(() => {
        throw reason;
      }),
  );
};
```

##手写一个 Promise

```js
const PENDING = 'pending';
const RESOLVED = 'resolved';
const REJECTED = 'rejected';

class MyPromise1 {
  constructor(fn) {
    this.state = PENDING;
    this.value = null;
    this.resolvedCallbacks = [];
    this.rejectedCallbacks = [];
    try {
      fn(this.resolve, this.reject);
    } catch (e) {
      this.reject(e);
    }
  }

  resolve = (value) => {
    if (this.state === PENDING) {
      this.state = RESOLVED;
      this.value = value;
      this.resolvedCallbacks.map((cb) => cb(this.value));
    }
  };

  reject = (value) => {
    if (this.state === PENDING) {
      this.state = REJECTED;
      this.value = value;
      this.rejectedCallbacks.map((cb) => cb(this.value));
    }
  };

  then = (onFulfilled, onRejected) => {
    const onFulfilledFunc = typeof onFulfilled === 'function' ? onFulfilled : (v) => v;
    const onRejectedFunc =
      typeof onRejected === 'function'
        ? onRejected
        : (r) => {
            throw r;
          };

    if (this.state === PENDING) {
      this.resolvedCallbacks.push(onFulfilledFunc);
      this.rejectedCallbacks.push(onRejectedFunc);
    }

    if (this.state === RESOLVED) {
      onFulfilled(this.value);
    }

    if (this.state === REJECTED) {
      onRejectedFunc(this.value);
    }
  };
}

new MyPromise1((resolve) => {
  resolve(1);
  // setTimeout(() => {
  //   resolve(1);
  // }, 1000);
}).then((value) => {
  console.log(value);
});
```

## 手写一个 async await

```js
const asyncToGen = (genFunction) => {
  return (...args) => {
    const gen = genFunction.apply(this, args);
    return new Promise((resolve, reject) => {
      const step = (key, arg) => {
        let genResult;
        try {
          genResult = gen[key](arg);
        } catch (err) {
          return reject(err);
        }

        const { value, done } = genResult;

        if (done) {
          return resolve(value);
        }

        return Promise.resolve(value).then(
          (val) => {
            step('next', val);
          },
          (err) => {
            step('throw', err);
          },
        );
      };

      step('next');
    });
  };
};

const getData = (n) => new Promise((resolve) => setTimeout(() => resolve(`data${n}`), 1000));

function* testG() {
  const data = yield getData(1);
  console.log('data1: ', data);
  const data2 = yield getData(2);
  console.log('data2: ', data2);
  return 'success';
}

async function test() {
  const data = await getData();
  console.log('data3: ', data);
  const data2 = await getData();
  console.log('data4: ', data2);
  return 'success';
}

asyncToGen(testG)().then(console.log);

test().then(console.log);

function* foo(x) {
  const y = 2 * (yield x + 1);
  const z = yield y / 3;
  return x + y + z;
}

asyncToGen(foo)(5).then(console.log);

const a = foo(5);

console.log('a.next(): ', a.next());
console.log('a.next(): ', a.next());
console.log('a.next(): ', a.next());
```
