## V8 如何执行一段 JS 代码

1. **预解析**：检查语法错误但不生成 AST

2. **生成 AST**：经过词法/语法分析，生成抽象语法树

3. **生成字节码**：基线编译器(Ignition)将 AST 转换成字节码

4. **生成机器码**：优化编译器(Turbofan)将字节码转换成优化过的机器码，此外在逐行执行字节码的过程中，如果一段代码经常被执行，那么 V8 会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码，优化了执行速度

## 介绍一下引用计数和标记清除

- **引用计数**：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为 0 的对象。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。
- **标记清除**：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。

## V8 如何进行垃圾回收

JS 引擎中对变量的存储主要有两种位置，栈内存和堆内存。

栈内存存储基本类型数据 以及 引用类型数据的内存地址。 堆内存储存引用类型的数据

![img](https://user-gold-cdn.xitu.io/2020/4/5/17149730709e41a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 栈内存的回收：栈内存调用栈上下文切换后就被回收，比较简单

- 堆内存的回收：V8 的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代内存存在时间长

![img](https://user-gold-cdn.xitu.io/2020/4/5/1714980cac75fc32?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 新生代内存回收机制：
  - 新生代内存容量小，64 位系统下仅有 32M。新生代内存分为**From、To**两部分，进行垃圾回收时，先扫描 From，将非存活对象回收，将存活对象顺序复制到 To 中，之后调换 From/To，等待下一次回收
- 老生代内存回收机制
  - **晋升**：如果新生代的变量经过多次回收依然存在，那么就会被放入老生代内存中
  - **标记清除**：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收被标记的对象
  - **整理内存碎片**：把对象挪到内存的一端

## JS 相较于 C++等语言为什么慢，V8 做了哪些优化

1. JS 的问题：
   - **动态类型**：导致每次存取属性/寻求方法时候，都需要先检查类型；此外动态类型也很难在编译阶段进行优化
   - **属性存取**：C++/Java 等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而 JS 存储在对象中，每次获取都要进行哈希查询
2. V8 的优化：
   - **优化 JIT(即时编译)**：相较于 C++/Java 这类编译型语言，JS 一边解释一边执行，效率低。V8 对这个过程进行了优化：如果一段代码被执行多次，那么 V8 会把这段代码转化为机器码缓存下来，下次运行时直接使用机器码。
   - **隐藏类**：对于 C++这类语言来说，仅需几个指令就能通过偏移量获取变量信息，而 JS 需要进行字符串匹配，效率低，V8 借用了类和偏移位置的思想，将对象划分成不同的组，即隐藏类
   - **内嵌缓存**：即缓存对象查询的结果。常规查询过程是：获取隐藏类地址 -> 根据属性名查找偏移值 -> 计算该属性地址，内嵌缓存就是对这一过程结果的缓存
   - **垃圾回收管理**：上文已介绍

![img](https://user-gold-cdn.xitu.io/2020/4/5/1714a1f7c054c657?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 定时器

setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。

## 为什么 JavaScript 是单线程

- 特点：同一个时间只能做一件事
- 为什么不是：与它的用途有关，作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

## 事件循环

- 什么是：JS 是单线程，在单线程中拥有唯一的事件循环。事件循环决定了 JS 代码的执行顺序。
- 和函数调用栈的不同：函数调用栈是决定函数的执行顺序，事件循环是依靠任务队列的方式，来决定整体代码的执行顺序的。
- 特点：
  - 事件循环是唯一的，但任务队列可以有多个
  - setTimeout/Promise 等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。（例：setTimeout 中的回调函数才是进入任务队列的任务，setTimeout 会立即执行）
  - 来自不同任务源的任务会进入到不同的任务队列。其中 setTimeout 与 setInterval 是同源的。
  - 事件循环的顺序，决定了 JavaScript 代码的执行顺序。它从 script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的 micro-task。当所有可执行的 micro-task 执行完毕之后。循环再次从 macro-task 开始，找到其中一个任务队列执行完毕，然后再执行所有的 micro-task，这样一直循环下去。
  - 其中每一个任务的执行，无论是 macro-task 还是 micro-task，都是借助函数调用栈来完成。

#### 执行上下文

- 什么是：执行上下文可以理解为函数执行的环境，每一个函数执行时，都会给对应的函数创建这样一个执行环境。

- 特点：

  1. 单线程
  2. v8 以栈的方式处理他们

  3. 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待

  4. 全局上下文只有唯一的一个，它在浏览器关闭时出栈

  5. 函数的执行上下文的个数没有限制

  6. 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。

#### 任务队列

- 什么是：具体执行任务组成的队列叫任务队列
- 分类
  - 宏任务(macro-task / task)：script(整体代码), setTimeout, setInterval, setImmediate, I/O 操作，UI 渲染等。
  - 微任务(micro-task / jobs)：promise.then、promise.nextTick(node)

![img](https://pic4.zhimg.com/80/v2-aac30c2c5277e89df6738fa961c9348f_720w.jpg)

## 浏览器和 Node 事件循环的区别

- 在 node10 之前：将同源宏任务队列执行完毕后再清空微任务队列(同源宏任务就是来自相同任务源，其中 setTimeout 和 setInterval 是同源的)
- 之后：和浏览器一样 每执行一个宏任务就执行完微任务队列。

```js
// 可做区别的代码参考
console.log(1);

setTimeout(() => {
  console.log(2);
  new Promise((resolve) => {
    console.log(6);
    resolve(7);
  }).then((num) => {
    console.log(num);
  });
});

setTimeout(() => {
  console.log(3);
  new Promise((resolve) => {
    console.log(9);
    resolve(10);
  }).then((num) => {
    console.log(num);
  });
  setTimeout(() => {
    console.log(8);
  });
});

new Promise((resolve) => {
  console.log(4);
  resolve(5);
}).then((num) => {
  console.log(num);
  new Promise((resolve) => {
    console.log(11);
    resolve(12);
  }).then((num) => {
    console.log(num);
  });
});
```

练习题：

```js
//请写出输出内容
console.log('golb1');

async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}

async function async2() {
  console.log('async2');
}

setTimeout(function () {
  console.log('timeout1');
  process.nextTick(function () {
    console.log('timeout1_nextTick');
  });
  new Promise(function (resolve) {
    console.log('timeout1_promise');
    resolve();
  }).then(function () {
    console.log('timeout1_then');
  });
});

setImmediate(function () {
  console.log('immediate1');
  process.nextTick(function () {
    console.log('immediate1_nextTick');
  });
  new Promise(function (resolve) {
    console.log('immediate1_promise');
    resolve();
  }).then(function () {
    console.log('immediate1_then');
  });
});

console.log('script start');

setTimeout(function () {
  console.log('setTimeout');
}, 0);

new Promise(function (resolve) {
  console.log('promise1');
  resolve();
}).then(function () {
  console.log('promise2');
});

process.nextTick(function () {
  console.log('glob1_nextTick');
});

new Promise(function (resolve) {
  console.log('glob1_promise');
  resolve();
}).then(function () {
  console.log('glob1_then');
});

setTimeout(function () {
  console.log('timeout2');
  process.nextTick(function () {
    console.log('timeout2_nextTick');
  });
  new Promise(function (resolve) {
    console.log('timeout2_promise');
    resolve();
  }).then(function () {
    console.log('timeout2_then');
  });
});

process.nextTick(function () {
  console.log('glob2_nextTick');
});

new Promise(function (resolve) {
  console.log('glob2_promise');
  resolve();
}).then(function () {
  console.log('glob2_then');
});

setImmediate(function () {
  console.log('immediate2');
  process.nextTick(function () {
    console.log('immediate2_nextTick');
  });
  new Promise(function (resolve) {
    console.log('immediate2_promise');
    resolve();
  }).then(function () {
    console.log('immediate2_then');
  });
});

console.log('script end');

async1();

/*
golb1
script start
promise1
glob1_promise
glob2_promise
script end
async1 start
async2
glob1_nextTick
glob2_nextTick
promise2
glob1_then
glob2_then
async1 end
timeout1
timeout1_promise
timeout1_nextTick
timeout1_then
setTimeout
timeout2
timeout2_promise
timeout2_nextTick
timeout2_then
immediate1
immediate1_promise
immediate1_nextTick
immediate1_then
immediate2
immediate2_promise
immediate2_nextTick
immediate2_then
*/
```

```js
// 练习题
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve();
  console.log(2);
});

promise.then(() => {
  console.log(3);
});

console.log(4);

// 1243

const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve(5);
  console.log(2);
}).then((val) => {
  console.log(val);
});

promise.then(() => {
  console.log(3);
});

console.log(4);

setTimeout(function () {
  console.log(6);
});

// 124536
```
