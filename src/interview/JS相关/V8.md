# 第 10 题：事件循环

```js
//请写出输出内容
// demo02
console.log('golb1');

async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}

async function async2() {
  console.log('async2');
}

setTimeout(function () {
  console.log('timeout1');
  process.nextTick(function () {
    console.log('timeout1_nextTick');
  });
  new Promise(function (resolve) {
    console.log('timeout1_promise');
    resolve();
  }).then(function () {
    console.log('timeout1_then');
  });
});

setImmediate(function () {
  console.log('immediate1');
  process.nextTick(function () {
    console.log('immediate1_nextTick');
  });
  new Promise(function (resolve) {
    console.log('immediate1_promise');
    resolve();
  }).then(function () {
    console.log('immediate1_then');
  });
});

console.log('script start');

setTimeout(function () {
  console.log('setTimeout');
}, 0);

new Promise(function (resolve) {
  console.log('promise1');
  resolve();
}).then(function () {
  console.log('promise2');
});

process.nextTick(function () {
  console.log('glob1_nextTick');
});

new Promise(function (resolve) {
  console.log('glob1_promise');
  resolve();
}).then(function () {
  console.log('glob1_then');
});

setTimeout(function () {
  console.log('timeout2');
  process.nextTick(function () {
    console.log('timeout2_nextTick');
  });
  new Promise(function (resolve) {
    console.log('timeout2_promise');
    resolve();
  }).then(function () {
    console.log('timeout2_then');
  });
});

process.nextTick(function () {
  console.log('glob2_nextTick');
});

new Promise(function (resolve) {
  console.log('glob2_promise');
  resolve();
}).then(function () {
  console.log('glob2_then');
});

setImmediate(function () {
  console.log('immediate2');
  process.nextTick(function () {
    console.log('immediate2_nextTick');
  });
  new Promise(function (resolve) {
    console.log('immediate2_promise');
    resolve();
  }).then(function () {
    console.log('immediate2_then');
  });
});

console.log('script end');

async1();

/*
golb1
script start
promise1
glob1_promise
glob2_promise
script end
async1 start
async2
glob1_nextTick
glob2_nextTick
promise2
glob1_then
glob2_then
async1 end
timeout1
timeout1_promise
timeout1_nextTick
timeout1_then
setTimeout
timeout2
timeout2_promise
timeout2_nextTick
timeout2_then
immediate1
immediate1_promise
immediate1_nextTick
immediate1_then
immediate2
immediate2_promise
immediate2_nextTick
immediate2_then
*/
```

```js
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve();
  console.log(2);
});

promise.then(() => {
  console.log(3);
});

console.log(4);

// 1243

const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve(5);
  console.log(2);
}).then((val) => {
  console.log(val);
});

promise.then(() => {
  console.log(3);
});

console.log(4);

setTimeout(function () {
  console.log(6);
});

// 124536
```

可参考https://www.jianshu.com/p/12b9f73c5a4f

一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。

任务队列又分为 macro-task（宏任务）与 micro-task（微任务），在最新标准中，它们被分别称为 task 与 jobs。

macro-task 大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。

micro-task 大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5 新特性)

## V8 如何执行一段 JS 代码

**预解析**：检查语法错误但不生成 AST

**生成 AST**：经过词法/语法分析，生成抽象语法树

**生成字节码**：基线编译器(Ignition)将 AST 转换成字节码

**生成机器码**：优化编译器(Turbofan)将字节码转换成优化过的机器码，此外在逐行执行字节码的过程中，如果一段代码经常被执行，那么 V8 会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码，优化了执行速度

## 介绍一下引用计数和标记清除

- **引用计数**：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为 0 的对象。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。
- **标记清除**：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。

## V8 如何进行垃圾回收

JS 引擎中对变量的存储主要有两种位置，栈内存和堆内存，栈内存存储基本类型数据以及引用类型数据的内存地址，堆内存储存引用类型的数据

![img](https://user-gold-cdn.xitu.io/2020/4/5/17149730709e41a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 栈内存的回收：栈内存调用栈上下文切换后就被回收，比较简单

- 堆内存的回收：V8 的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代内存存在时间长

![img](https://user-gold-cdn.xitu.io/2020/4/5/1714980cac75fc32?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 新生代内存回收机制：
  - 新生代内存容量小，64 位系统下仅有 32M。新生代内存分为**From、To**两部分，进行垃圾回收时，先扫描 From，将非存活对象回收，将存活对象顺序复制到 To 中，之后调换 From/To，等待下一次回收
- 老生代内存回收机制
  - **晋升**：如果新生代的变量经过多次回收依然存在，那么就会被放入老生代内存中
  - **标记清除**：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收被标记的对象
  - **整理内存碎片**：把对象挪到内存的一端

## JS 相较于 C++等语言为什么慢，V8 做了哪些优化

1. JS 的问题：
   - **动态类型**：导致每次存取属性/寻求方法时候，都需要先检查类型；此外动态类型也很难在编译阶段进行优化
   - **属性存取**：C++/Java 等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而 JS 存储在对象中，每次获取都要进行哈希查询
2. V8 的优化：
   - **优化 JIT(即时编译)**：相较于 C++/Java 这类编译型语言，JS 一边解释一边执行，效率低。V8 对这个过程进行了优化：如果一段代码被执行多次，那么 V8 会把这段代码转化为机器码缓存下来，下次运行时直接使用机器码。
   - **隐藏类**：对于 C++这类语言来说，仅需几个指令就能通过偏移量获取变量信息，而 JS 需要进行字符串匹配，效率低，V8 借用了类和偏移位置的思想，将对象划分成不同的组，即隐藏类
   - **内嵌缓存**：即缓存对象查询的结果。常规查询过程是：获取隐藏类地址 -> 根据属性名查找偏移值 -> 计算该属性地址，内嵌缓存就是对这一过程结果的缓存
   - **垃圾回收管理**：上文已介绍

![img](https://user-gold-cdn.xitu.io/2020/4/5/1714a1f7c054c657?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

# 说说浏览器和 Node 事件循环的区别

在 node10 之前：

将同源宏任务队列执行完毕后再清空微任务队列(同源宏任务就是来自相同任务源，其中 setTimeout 和 setInterval 是同源的)

之后：

和浏览器一样 每执行一个宏任务就执行完微任务队列。

常见的 task（宏任务） 比如:setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。

常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5 新特性) 等。

```js
console.log(1);

setTimeout(() => {
  console.log(2);
  new Promise((resolve) => {
    console.log(6);
    resolve(7);
  }).then((num) => {
    console.log(num);
  });
});

setTimeout(() => {
  console.log(3);
  new Promise((resolve) => {
    console.log(9);
    resolve(10);
  }).then((num) => {
    console.log(num);
  });
  setTimeout(() => {
    console.log(8);
  });
});

new Promise((resolve) => {
  console.log(4);
  resolve(5);
}).then((num) => {
  console.log(num);
  new Promise((resolve) => {
    console.log(11);
    resolve(12);
  }).then((num) => {
    console.log(num);
  });
});
```

### 描述一下 EventLoop 的执行过程

- 一开始整个脚本作为一个宏任务执行

- 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列

- 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完

- 执行浏览器 UI 线程的渲染工作

- 检查是否有`Web Worker`任务，有则执行

- 执行完本轮的宏任务，回到 2，依此循环，直到宏任务和微任务队列都为空

  详见: [jin.im/post/5e58c6…](https://juejin.im/post/5e58c618e51d4526ed66b5cf#heading-1）)

## 介绍一下引用计数和标记清除

- **引用计数**：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为 0 的对象。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。
- **标记清除**：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象

### 十一、JS 运行机制

掌握下面几个要点：

- 理解 JS 的单线程概念
- 理解任务队列
- 理解 EventLoop
- 理解哪些语句会放入异步任务队列
- 理解语句放入异步任务队列的时机

#### 11.1 为什么 JavaScript 是单线程

JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？这样能提高效率啊。 JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。

#### 11.2 任务队列

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。所有任务可以分成两种，一种是**同步任务**（synchronous），另一种是**异步任务**（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。具体来说，异步执行的运行机制如下:（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。 （3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 复制代码只要主线程空了，就会去读取"任务队列"，这就是 JavaScript 的运行机制。这个过程会不断重复。

#### 11.3 宏任务 & 微任务

这里需要注意的是 new Promise 是会进入到主线程中立刻执行，而 promise.then 则属于微任务

- 宏任务(macro-task)：整体代码 script、setTimeOut、setInterval
- 微任务(mincro-task)：promise.then、promise.nextTick(node)

#### 11.4 EventLoop 事件循环

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。

![img](https://pic4.zhimg.com/80/v2-aac30c2c5277e89df6738fa961c9348f_720w.jpg)

1. 整体的 script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”；
2. 同步任务会直接进入主线程依次执行；
3. 异步任务会再分为宏任务和微任务；
4. 宏任务进入到 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中；
5. 微任务也会进入到另一个 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中；
6. 当主线程内的任务执行完毕，主线程为空时，会检查微任务的 Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务；
7. 上述过程会不断重复，这就是 Event Loop 事件循环；

#### 11.5 定时器

除了放置异步任务的事件，"任务队列"还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做"定时器"（timer）功能，也就是定时执行的代码。定时器功能主要由 setTimeout()和 setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论 setTimeout()。 setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。 console.log(1); setTimeout(function(){console.log(2);},1000); console.log(3); 复制代码上面代码的执行结果是 1，3，2，因为 setTimeout()将第二行推迟到 1000 毫秒之后执行。如果将 setTimeout()的第二个参数设为 0，就表示当前代码执行完（执行栈清空）以后，立即执行（0 毫秒间隔）指定的回调函数。 setTimeout(function(){console.log(1);}, 0); console.log(2); 复制代码上面代码的执行结果总是 2，1，因为只有在执行完第二行以后，系统才会去执行"任务队列"中的回调函数。总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行。 HTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔），不得低于**4 毫秒**，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为 10 毫秒。另外，对于那些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是**每 16 毫秒执行一次**。这时使用 requestAnimationFrame()的效果要好于 setTimeout()。需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。

#### 11.6 哪些是异步任务

1. setTimeout 和 setInterval
2. DOM 事件
3. Promise
4. 网络请求
5. I/O
