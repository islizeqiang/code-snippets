[TOC]

## JS 异步编程方案

#### 回调函数

- 内部利用发布-订阅模式，一个 EventEmitter 需要实现`addListener`, `removeListener`, `once`, `removeAllListener`, `emit`

#### Promise

##### 1. 凭借什么消灭了回调地狱？

​ 什么是回调地狱？

- 多层嵌套问题
- 每种任务的处理结果存在两种可能性，成功或失败，那么需要在每种任务执行结束后分别处理这两种可能性

​ 怎么解决的？

- 实现链式调用，解决多层嵌套问题
- 实现错误冒泡后一站式处理，解决每次任务中判断错误、增加代码混乱度的问题

##### 2.为什么要引入微任务

    1. 采用异步回调代替同步回调解决了浪费CPU性能的问题。因为同步执行的话，会让整个脚本阻塞，当前任务等待，后面任务都无法执行，也导致CPU利用率低。

2. 放在当前宏任务最后执行，解决回调执行的实时性问题。因为在任务队列特别长的时候，回调迟迟得不到执行，会造成应用卡顿。

#### Generator

当一个生成器要调用另一个生成器

```js
function* gen1() {
  yield 1;
  yield 4;
}
function* gen2() {
  yield 2;
  yield 3;
}

function* gen12() {
  yield 1;
  yield* gen2();
  yield 4;
}
```

执行机制：协程

协程是一种比线程更加轻量级的存在，协程在线程的环境中，其不受操作系统管理，被具体应用程序代码控制。而 JS 是单线程，一个线程一次只能执行一个协程，所以 JS 是利用执行权转移来实现的。最大的特点就是可以交出函数的执行权，遇到 yield 就暂停，等到执行权返回，再从暂停的地方继续往后执行。

#### async await

## Promise.all(iterable)

Promise.all(iterable) 方法返回一个 [`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise) 实例，此实例在 `iterable` 参数内所有的 `promise` 都完成（resolved）或参数中不包含 `promise` 时回调完成如果参数中 `promise` 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 `promise` 的结果。

## Promise.race(iterable)

Promise.race(iterable)方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。

## JS 是单线程怎么理解？

Node 是单线程只代表 js 的执行是单线程的，事件循环是单线程的，即开发者编写的代码运行在单线程环境中，但 js 的宿主环境，不管是 Node 还是浏览器都是多线程的，因为它在其运行时中具有 libuv 线程池，该线程池提供多线程功能来执行长时间运行的进程。

## Nodejs 的非阻塞 I/O 是如何实现的？

1. `阻塞`和`非阻塞` I/O 其实是针对操作系统内核而言的。阻塞 I/O 的特点就是一定要**等到操作系统完成所有操作后才表示调用结束**，而非阻塞 I/O 是调用后立马返回，不用等操作系统内核完成操作。
2. nodejs 中的异步 I/O 采用多线程的方式，由 `EventLoop`、`I/O 观察者`，`请求对象`、`线程池`四大要素相互配合，共同实现。

## forEach 中用 await 会产生什么问题？怎么解决？

forEach 不能保证执行顺序，callback 会一起执行，不能保证异步执行顺序，但可以采用 for...of 解决，通过迭代器去遍历。
