#### 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣 Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()

#### toString.call 和 isArray 的性能一样差，instanceof 稍好，constructor 性能最好

#### 1. Object.prototype.toString.call()

每一个继承 Object 的对象都有 `toString` 方法，如果 `toString` 方法没有重写的话，会返回 `[Object type]`，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 `toString` 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文。

```js
const an = ['Hello', 'An'];
an.toString(); // "Hello,An"
Object.prototype.toString.call(an); // "[object Array]"
```

这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。

```js
Object.prototype.toString.call('An'); // "[object String]"
Object.prototype.toString.call(1); // "[object Number]"
Object.prototype.toString.call(Symbol(1)); // "[object Symbol]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(function () {}); // "[object Function]"
Object.prototype.toString.call({ name: 'An' }); // "[object Object]"
```

`Object.prototype.toString.call()` 常用于判断浏览器内置对象时。

更多实现可见 [谈谈 Object.prototype.toString](https://juejin.im/post/591647550ce4630069df1c4a)

#### 2. instanceof

`instanceof` 的内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

使用 `instanceof`判断一个对象是否为数组，`instanceof` 会判断这个对象的原型链上是否会找到对应的 `Array` 的原型，找到返回 `true`，否则返回 `false`。

```js
[] instanceof Array; // true
```

但 `instanceof` 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。

```javascript
[] instanceof Object; // true
```

#### 3. Array.isArray()

- 功能：用来判断对象是否为数组

- instanceof 与 isArray

  当检测 Array 实例时，`Array.isArray` 优于 `instanceof` ，因为 `Array.isArray` 可以检测出 `iframes`

  ```javascript
  var iframe = document.createElement('iframe');
  document.body.appendChild(iframe);
  xArray = window.frames[window.frames.length - 1].Array;
  var arr = new xArray(1, 2, 3); // [1,2,3]

  // Correctly checking for Array
  Array.isArray(arr); // true
  Object.prototype.toString.call(arr); // true
  // Considered harmful, because doesn't work though iframes
  arr instanceof Array; // false
  ```

- `Array.isArray()` 与 `Object.prototype.toString.call()`

  `Array.isArray()`是 ES5 新增的方法，当不存在 `Array.isArray()` ，可以用 `Object.prototype.toString.call()` 实现。

  ```javascript
  if (!Array.isArray) {
    Array.isArray = function (arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    };
  }
  ```

#### 4. arr.constructor === Array

```js
console.log({ a: 23 }.toString());
console.log([{ a: 23 }].toString());
console.log(Object.prototype.toString.call([{ a: 23 }]));
console.log([{ a: 23 }].constructor === Array);
console.log({ a: 23 }.constructor === Array);
```

# `a.b.c.d` 和 `a['b']['c']['d']` ，哪个性能更高？

应该是 `a.b.c.d` 比 `a['b']['c']['d']` 性能高点，后者还要考虑 `[ ]` 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。

# 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果

```js
[102, 15, 22, 29, 3, 8];
```

解析：

根据 MDN 上对`Array.sort()`的解释，默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的 UTF-16 编码顺序来进行排序。所以`'102'` 会排在 `'15'` 前面。

# 第 75 题：数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少

数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)

JavaScript 没有真正意义上的数组，所有的数组其实是对象，其“索引”看起来是数字，其实会被转换成字符串，作为属性名（对象的 key）来使用。所以无论是取第 1 个还是取第 10 万个元素，都是用 key 精确查找哈希表的过程，其消耗时间大致相同。

得出结论：**消耗时间几乎一致，差异可以忽略不计**。

# 变量提升相关

```js
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

```js
// Goodbye Jack
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    var name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

```js
// Hello Tom
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    let name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

# 第 27 题：关于 const 和 let 声明的变量不在 window 上

在 ES5 中，顶层对象的属性和全局变量是等价的，var 命令和 function 命令声明的全局变量，自然也是顶层对象。

但 ES6 规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。

在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中

在定义变量的块级作用域中就能获取

# 第 102 题：不用加减乘除运算符，求整数的 7 倍

```js
const ax = (multiple, num) => Array(multiple).fill(Array(num).fill(1)).flat().length;

console.log(ax(7, 2));

console.log(Array(7).fill(1));
console.log([...Array(7)]);
```

# 第 38 题：下面代码中 a 在什么情况下会打印 1？

> 题目如下

```js
var a = ?;
if (a == 1 && a == 2 && a == 3) {
 	console.log(1);
}
```

这个题目考察==的隐式转换吧

> 利用 toString

```js
let a = {
  i: 1,
  toString() {
    a.i += 1;
    return a.i - 1;
  },
};

if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

> 利用 valueOf

```js
let a = {
  i: 1,
  valueOf() {
    a.i += 1;
    return a.i - 1;
  },
};

if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

> 数组这个就有点妖了

```js
var a = [1, 2, 3];
a.join = a.shift;
if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

> ES6 的 symbol

```js
let a = { [Symbol.toPrimitive]: ((i) => () => ++i)(0) };
if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

[从 (a==1&&a==2&&a==3) 成立中看 javascript 的隐式类型转换](https://yq.aliyun.com/articles/399499)

# 第 55 题：某公司 1 到 12 月份的销售额存在一个对象里面

```js
const obj = { 1: 222, 2: 123, 5: 888 };
const result = Array.from({ length: 12 }).map((_, index) => obj[index + 1] || null);
const result1 = [...Array(12)].map((_, index) => obj[index + 1] || null);
```

> 生成指定长度数组的几种方法

```js
[...new Array(12)]

[...Array(12)]

Array.from({ length : 12 })
```

# 第 11 题：将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组

已知如下数组：

var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];

编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

```js
Array.from(new Set(arr.flat(Infinity))).sort((a, b) => a - b);
```

# 第 58 题：箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？

箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：

1、函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。

2、不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

3、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

4、不可以使用 new 命令，因为：

- 没有自己的 this，无法调用 call，apply。
- 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 **proto**

# 第 33 题：下面的代码打印什么内容，为什么？

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
// 打印 Function b
```

1. 函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。

2. 对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。

3. IIFE 中的函数是函数表达式，而不是函数声明。

   b 函数是一个相当于用 const 定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错"Uncaught TypeError: Assignment to constant variable."

如果用 ' use strict ' 的话 会导致报错

# 第 53 题：输出以下代码的执行结果并解释为什么

结果: undefined {n:2}

首先，a 和 b 同时引用了{n:2}对象，接着执行到 a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行 a.x，相当于为 a（或者 b）所指向的{n:1}对象新增了一个属性 x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行 a ={n:2}的时候，a 的引用改变，指向了新对象{n：2},而 b 依然指向的是旧对象。之后执行 a.x = {n：2}的时候，并不会重新解析一遍 a，而是沿用最初解析 a.x 时候的 a，也即旧对象，故此时旧对象的 x 的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被 b 引用着。后面输出 a.x 的时候，又要解析 a 了，此时的 a 是指向新对象的 a，而这个新对象是没有 x 属性的，故访问时输出 undefined；而访问 b.x 的时候，将输出旧对象的 x 的值，即{n:2}。

# 第 106 题：分别写出如下代码的返回值

```js
String('11') == new String('11');
String('11') === new String('11');
```

分析： new String() 返回的是对象

```
==` 的时候，实际运行的是
`String('11') == new String('11').toString();
```

`===` 不再赘述。

# 第 41 题：考察作用域的一道代码题

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  // var a = 20;
  console.log(a);
})();
// 10 5 5
```

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
// undefined 10 20
```

在立即执行函数中，`var a = 20;` 语句定义了一个局部变量 `a`，由于 js 的变量声明提升机制，局部变量`a`的声明会被提升至立即执行函数的函数体最上方，且由于这样的提升并不包括赋值，因此第一条打印语句会打印`undefined`，最后一条语句会打印`20`。

由于变量声明提升，`a = 5;` 这条语句执行时，局部的变量`a`已经声明，因此它产生的效果是对局部的变量`a`赋值，此时`window.a` 依旧是最开始赋值的`10`.

分别为 undefined 　 10 　 20，原因是作用域问题，在内部声名 var a = 20;相当于先声明 var a;然后再执行赋值操作，这是在ＩＩＦＥ内形成的独立作用域，如果把 var a=20 注释掉，那么 a 只有在外部有声明，显示的就是外部的Ａ变量的值了。结果Ａ会是 10 　 5 　 5

# 第 98 题：写出如下代码的打印结果

```js
function changeObjProperty(o) {
  o.siteUrl = 'http://www.baidu.com';
  o = new Object();
  o.siteUrl = 'http://www.google.com';
}
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl);
```

对象传值传的是引用，但是引用是 copy 给函数形参。

```js
// 这里把o改成a
// webSite引用地址的值copy给a了
function changeObjProperty(a) {
  // 改变对应地址内的对象属性值
  a.siteUrl = 'http://www.baidu.com';
  // 变量a指向新的地址 以后的变动和旧地址无关
  a = new Object();
  a.siteUrl = 'http://www.google.com';
  a.name = 456;
}
var webSite = new Object();
webSite.name = '123';
changeObjProperty(webSite);
console.log(webSite); // {name: 123, siteUrl: 'http://www.baidu.com'}
```

`parseInt()` 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。

# 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？

const 和 let 会生成块级作用域，可以理解为

```js
let a = 10;
const b = 20;
相当于：
(function(){
         var  a = 10;
         var b = 20;
})()
```

ES5 没有块级作用域的概念，只有函数作用域，可以近似理解成这样。 所以外层 window 必然无法访问。

# 下面的代码打印什么内容，为什么？

几个例子：

```js
var b = 10;
(function b() {
  // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值；
  // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。
  // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）
  b = 20;
  console.log(b); // [Function b]
  console.log(window.b); // 10，不是20
})();
```

所以严格模式下能看到错误：`Uncaught TypeError: Assignment to constant variable`

```js
var b = 10;
(function b() {
  'use strict';
  b = 20;
  console.log(b);
})(); // "Uncaught TypeError: Assignment to constant variable."
```

其他情况例子：

有`window`：

```js
var b = 10;
(function b() {
  window.b = 20;
  console.log(b); // [Function b]
  console.log(window.b); // 20是必然的
})();
```

有`var`:

```js
var b = 10;
(function b() {
  var b = 20; // IIFE内部变量
  console.log(b); // 20
  console.log(window.b); // 10
})();
```

# 下面代码输出什么

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
```

# 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果

`sort` 函数，可以接收一个函数，返回值是比较两个数的相对顺序的值

默认没有函数 是按照 `UTF-16` 排序的，对于字母数字 你可以利用 `ASCII` 进行记忆

### 说一下==数据类型转换吧

当使用`==`进行比较的时候，会有以下转换规则（判断规则）：

1. 两边类型如果相同，值相等则相等，如 `2 == 3`肯定是为`false`的了
2. 比较的双方都为基本数据类型：

- 若是一方为`null、undefined`，则另一方必须为`null或者undefined`才为`true`，也就是`null == undefined`为`true`或者`null == null`为`true`，因为`undefined`派生于`null`
- 其中一方为`String`，是的话则把`String`转为`Number`再来比较
- 其中一方为`Boolean`，是的话则将`Boolean`转为`Number`再来比较

1. 比较的一方有引用类型：

- 将引用类型遵循类似`ToNumber`的转换形式来进行比较(也就是`toPrimitive(obj, 'defalut')`
- 两方都为引用类型，则判断它们是不是指向同一个对象

### typeof 为什么对 null 错误的显示

这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。

### 一句话描述一下 this

是函数运行时内部自动生成的一个内部对象，只能在函数内部使用

### setTimeout 的执行原理(EventLoop)

(回答参考：[juejin.im/post/5e621f…](https://juejin.im/post/5e621f5fe51d452700567c32))

`setTimeout`的运行机制：执行该语句时，是立即把当前定时器代码推入事件队列，当定时器在事件列表中满足设置的时间值时将传入的函数加入任务队列，之后的执行就交给任务队列负责。但是如果此时任务队列不为空，则需等待，所以执行定时器内代码的时间可能会大于设置的时间

说了一下它属于异步任务，然后说了一下还有哪些宏任务以及微任务，最后说了一下`EventLoop`的执行过程。

- 一开始整个脚本作为一个宏任务执行
- 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
- 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完
- 执行浏览器 UI 线程的渲染工作
- 检查是否有`Web Worker`任务，有则执行
- 执行完本轮的宏任务，回到 2，依此循环，直到宏任务和微任务队列都为空

（具体可以看这里：[juejin.im/post/5e58c6…](https://juejin.im/post/5e58c618e51d4526ed66b5cf#heading-1）)

### 10. requestAnimationFrame 有了解过吗？

`requestAnimationFrame`是浏览器用于定时循环操作的一个接口，类似于`setTimeout`，主要用途是按帧对网页进行重绘。对于`JS`动画，用`requestAnimationFrame` 会比 `setInterval` 效果更好。

### 平常工作中 ES6+主要用到了哪些？

`ES6`：

1. `Class`
2. 模块`import`和`export`
3. 箭头函数
4. 函数默认参数
5. `...`扩展运输符允许展开数组
6. 解构
7. 字符串模版
8. Promise
9. `let const`
10. `Proxy、Map、Set`
11. 对象属性同名能简写

`ES7`：

1. `includes`
2. `**`求幂运算符

`ES8`：

1. `async/await`
2. `Object.values()和Object.entries()`
3. `padStart()和padEnd()`
4. `Object.getOwnPropertyDescriptors()`
5. 函数参数允许尾部`,`

`ES9`：

1. `for...await...of`
2. `...`展开符合允许展开对象收集剩余参数
3. `Promise.finally()`
4. 正则中的四个新功能

`ES10`：

1. `flat()`
2. `flatMap()`
3. `fromEntries()`
4. `trimStart`和`trimEnd`
5. `matchAll`
6. `BigInt`
7. `try/catch`中报错允许没有`err`异常参数
8. `Symbol.prototype.description`
9. `Function.toString()`调用时呈现原本源码的样子

### 不使用框架如何实现组件按需加载以及原理

当时答的是是用`import`来按需引入，以及提到了`Vue.use`。

但后来有去了解，`babel-plugin-import`就可以实现。

## 如何在 ES5 环境下实现 let

babel 在 let 定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数来模拟块级作用域

```js
(function () {
  for (var i = 0; i < 5; i++) {
    console.log(i); // 0 1 2 3 4
  }
})();

console.log(i); // Uncaught ReferenceError: i is not defined
```

不过这个问题并没有结束，我们回到`var`和`let/const`的区别上：

- `var`声明的变量会挂到 window 上，而`let`和`const`不会
- `var`声明的变量存在变量提升，而`let`和`const`不会
- `let`和`const`声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问
- 同一作用域下`let`和`const`不能声明同名变量，而`var`可以
- 暂时性死区，`let`和`const`声明的变量不能在声明前被使用

babel 的转化，其实只实现了第 2、3、5 点

## 如何在 ES5 环境下实现 const

对于 const 不可修改的特性，我们通过设置 writable 属性来实现

```js
function _const(key, value) {
  const desc = {
    value,
    writable: false,
  };
  Object.defineProperty(window, key, desc);
}

_const('obj', { a: 1 }); //定义obj
obj.b = 2; //可以正常给obj的属性赋值
obj = {}; //无法赋值新对象
```

## 数组扁平化

**1.ES6 的 flat()**

```js
const arr = [1, [1, 2], [1, 2, 3]];
arr.flat(Infinity); // [1, 1, 2, 1, 2, 3]
```

**2.序列化后正则**

```js
const arr = [1, [1, 2], [1, 2, 3]];
const str = `[${JSON.stringify(arr).replace(/(\[|\])/g, '')}]`;
JSON.parse(str); // [1, 1, 2, 1, 2, 3]
```

**3.递归** 对于树状结构的数据，最直接的处理方式就是递归

```js
const arr = [1, [1, 2], [1, 2, 3]];
function flat(arr) {
  let result = [];
  for (const item of arr) {
    item instanceof Array ? (result = result.concat(flat(item))) : result.push(item);
  }
  return result;
}

flat(arr); // [1, 1, 2, 1, 2, 3]
```

**4.reduce()递归**

```js
const arr = [1, [1, 2], [1, 2, 3]];
function flat(arr) {
  return arr.reduce((prev, cur) => {
    return prev.concat(cur instanceof Array ? flat(cur) : cur);
  }, []);
}

flat(arr); // [1, 1, 2, 1, 2, 3]
```

**5.迭代+展开运算符**

```js
// 每次while都会合并一层的元素，这里第一次合并结果为[1, 1, 2, 1, 2, 3, [4,4,4]]
// 然后arr.some判定数组中是否存在数组，因为存在[4,4,4]，继续进入第二次循环进行合并
let arr = [1, [1, 2], [1, 2, 3, [4, 4, 4]]];
while (arr.some(Array.isArray)) {
  arr = [].concat(...arr);
}

console.log(arr); // [1, 1, 2, 1, 2, 3, 4, 4, 4]
```

## 2. ES5 如何实现继承

说到继承，最容易想到的是 ES6 的`extends`，当然如果只回答这个肯定不合格，我们要从函数和原型链的角度上实现继承，下面我们一步步地、递进地实现一个合格的继承

### 一. 原型链继承

原型链继承的原理很简单，直接让子类的原型对象指向父类实例，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而实现对父类的属性和方法的继承

```js
// 父类
function Parent() {
  this.name = '写代码像蔡徐抻';
}
// 父类的原型方法
Parent.prototype.getName = function () {
  return this.name;
};
// 子类
function Child() {}

// 让子类的原型对象指向父类实例, 这样一来在Child实例中找不到的属性和方法就会到原型对象(父类实例)上寻找
Child.prototype = new Parent();
Child.prototype.constructor = Child; // 根据原型链的规则,顺便绑定一下constructor, 这一步不影响继承, 只是在用到constructor时会需要

// 然后Child实例就能访问到父类及其原型上的name属性和getName()方法
const child = new Child();
child.name; // '写代码像蔡徐抻'
child.getName(); // '写代码像蔡徐抻'
```

缺点:

1. 由于所有 Child 实例原型都指向同一个 Parent 实例, 因此对某个 Child 实例的父类引用类型变量修改会影响所有的 Child 实例
2. 在创建子类实例时无法向父类构造传参, 即没有实现`super()`的功能

```js
// 示例:
function Parent() {
  this.name = ['写代码像蔡徐抻'];
}
Parent.prototype.getName = function () {
  return this.name;
};
function Child() {}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

// 测试
const child1 = new Child();
const child2 = new Child();
child1.name[0] = 'foo';
console.log(child1.name); // ['foo']
console.log(child2.name); // ['foo'] (预期是['写代码像蔡徐抻'], 对child1.name的修改引起了所有child实例的变化)
```

### 二. 构造函数继承

构造函数继承，即在子类的构造函数中执行父类的构造函数，并为其绑定子类的`this`，让父类的构造函数把成员属性和方法都挂到`子类的this`上去，这样既能避免实例之间共享一个原型实例，又能向父类构造方法传参

```js
function Parent(name) {
  this.name = [name];
}
Parent.prototype.getName = function () {
  return this.name;
};
function Child() {
  Parent.call(this, 'zhangsan'); // 执行父类构造方法并绑定子类的this, 使得父类中的属性能够赋到子类的this上
}

//测试
const child1 = new Child();
const child2 = new Child();
child1.name[0] = 'foo';
console.log(child1.name); // ['foo']
console.log(child2.name); // ['zhangsan']
child2.getName(); // 报错,找不到getName(), 构造函数继承的方式继承不到父类原型上的属性和方法
```

缺点:

1. 继承不到父类原型上的属性和方法

### 三. 组合式继承

既然原型链继承和构造函数继承各有互补的优缺点, 那么我们为什么不组合起来使用呢, 所以就有了综合二者的组合式继承

```js
function Parent(name) {
  this.name = [name];
}
Parent.prototype.getName = function () {
  return this.name;
};
function Child() {
  // 构造函数继承
  Parent.call(this, 'zhangsan');
}
//原型链继承
Child.prototype = new Parent();
Child.prototype.constructor = Child;

//测试
const child1 = new Child();
const child2 = new Child();
child1.name[0] = 'foo';
console.log(child1.name); // ['foo']
console.log(child2.name); // ['zhangsan']
child2.getName(); // ['zhangsan']
```

缺点:

1. 每次创建子类实例都执行了两次构造函数(`Parent.call()`和`new Parent()`)，虽然这并不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅

### 四. 寄生式组合继承

为了解决构造函数被执行两次的问题, 我们将`指向父类实例`改为`指向父类原型`, 减去一次构造函数的执行

```js
function Parent(name) {
  this.name = [name];
}
Parent.prototype.getName = function () {
  return this.name;
};
function Child() {
  // 构造函数继承
  Parent.call(this, 'zhangsan');
}
//原型链继承
// Child.prototype = new Parent()
Child.prototype = Parent.prototype; //将`指向父类实例`改为`指向父类原型`
Child.prototype.constructor = Child;

//测试
const child1 = new Child();
const child2 = new Child();
child1.name[0] = 'foo';
console.log(child1.name); // ['foo']
console.log(child2.name); // ['zhangsan']
child2.getName(); // ['zhangsan']
```

但这种方式存在一个问题，由于子类原型和父类原型指向同一个对象，我们对子类原型的操作会影响到父类原型，例如给`Child.prototype`增加一个 getName()方法，那么会导致`Parent.prototype`也增加或被覆盖一个 getName()方法，为了解决这个问题，我们给`Parent.prototype`做一个浅拷贝

```js
function Parent(name) {
  this.name = [name];
}
Parent.prototype.getName = function () {
  return this.name;
};
function Child() {
  // 构造函数继承
  Parent.call(this, 'zhangsan');
}
//原型链继承
// Child.prototype = new Parent()
Child.prototype = Object.create(Parent.prototype); //将`指向父类实例`改为`指向父类原型`
Child.prototype.constructor = Child;

//测试
const child = new Child();
const parent = new Parent();
child.getName(); // ['zhangsan']
parent.getName(); // 报错, 找不到getName()
复制代码;
```

到这里我们就完成了 ES5 环境下的继承的实现，这种继承方式称为`寄生组合式继承`，是目前最成熟的继承方式，babel 对 ES6 继承的转化也是使用了寄生组合式继承

我们回顾一下实现过程： 一开始最容易想到的是`原型链继承`，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型链继承的缺陷在于`对子类实例继承的引用类型的修改会影响到所有的实例对象`以及`无法向父类的构造方法传参`。 因此我们引入了`构造函数继承`, 通过在子类构造函数中调用父类构造函数并传入子类 this 来获取父类的属性和方法，但构造函数继承也存在缺陷，构造函数继承`不能继承到父类原型链上的属性和方法`。 所以我们综合了两种继承的优点，提出了`组合式继承`，但组合式继承也引入了新的问题，它`每次创建子类实例都执行了两次父类构造方法`，我们通过将`子类原型指向父类实例`改为`子类原型指向父类原型的浅拷贝`来解决这一问题，也就是最终实现 —— `寄生组合式继承`

![img](https://user-gold-cdn.xitu.io/2020/4/6/1714fd86c8983189?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
