## 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣 Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()

结论：toString.call 和 isArray 的性能一样差，instanceof 稍好，constructor 性能最好

- Object.prototype.toString.call()

```js
Object.prototype.toString.call('An'); // "[object String]"
Object.prototype.toString.call(1); // "[object Number]"
Object.prototype.toString.call(Symbol(1)); // "[object Symbol]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(function () {}); // "[object Function]"
Object.prototype.toString.call({ name: 'An' }); // "[object Object]"
```

- instanceof

`instanceof` 的内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

使用 `instanceof`判断一个对象是否为数组，`instanceof` 会判断这个对象的原型链上是否会找到对应的 `Array` 的原型，找到返回 `true`，否则返回 `false`。

```js
[] instanceof Array; // true
```

但 `instanceof` 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。

```javascript
[] instanceof Object; // true
```

- Array.isArray()

- arr.constructor === Array

```js
console.log(Object.prototype.toString.call([{ a: 23 }]));
console.log([{ a: 23 }].constructor === Array);
console.log({ a: 23 }.constructor === Array);
```

## `a.b.c.d` 和 `a['b']['c']['d']` ，哪个性能更高？

应该是 `a.b.c.d` 比 `a['b']['c']['d']` 性能高点，后者还要考虑 `[ ]` 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。

## 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果

```js
[102, 15, 22, 29, 3, 8];
```

解析：默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的 UTF-16 编码顺序来进行排序。所以`'102'` 会排在 `'15'` 前面。

## 数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少

数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)

JavaScript 没有真正意义上的数组，所有的数组其实是对象，其“索引”看起来是数字，其实会被转换成字符串，作为属性名（对象的 key）来使用。所以无论是取第 1 个还是取第 10 万个元素，都是用 key 精确查找哈希表的过程，其消耗时间大致相同。

得出结论：**消耗时间几乎一致，差异可以忽略不计**。

## 变量提升相关

```js
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

```js
// Goodbye Jack
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    var name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

```js
// Hello Tom
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    let name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

## 下面代码中 a 在什么情况下会打印 1？

> 题目如下

```js
var a = ?;
if (a == 1 && a == 2 && a == 3) {
 	console.log(1);
}
```

这个题目考察==的隐式转换吧

> 利用 toString

```js
let a = {
  i: 1,
  toString() {
    a.i += 1;
    return a.i - 1;
  },
};

if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

> 利用 valueOf

```js
let a = {
  i: 1,
  valueOf() {
    a.i += 1;
    return a.i - 1;
  },
};

if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

> 数组这个就有点妖了

```js
var a = [1, 2, 3];
a.join = a.shift;
if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

> ES6 的 symbol

```js
let a = { [Symbol.toPrimitive]: ((i) => () => ++i)(0) };
if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

## 下面的代码打印什么内容，为什么？

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
// 打印 Function b
```

1. 函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。

2. 对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。

3. IIFE 中的函数是函数表达式，而不是函数声明。

   b 函数是一个相当于用 const 定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错"Uncaught TypeError: Assignment to constant variable."

如果用 ' use strict ' 的话 会导致报错

## 输出以下代码的执行结果并解释为什么

```js
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };

console.log(a.x);
console.log(b.x);
```

结果: undefined {n:2}

首先，a 和 b 同时引用了{n:2}对象，接着执行到 a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行 a.x，相当于为 a（或者 b）所指向的{n:1}对象新增了一个属性 x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行 a ={n:2}的时候，a 的引用改变，指向了新对象{n：2},而 b 依然指向的是旧对象。之后执行 a.x = {n：2}的时候，并不会重新解析一遍 a，而是沿用最初解析 a.x 时候的 a，也即旧对象，故此时旧对象的 x 的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被 b 引用着。后面输出 a.x 的时候，又要解析 a 了，此时的 a 是指向新对象的 a，而这个新对象是没有 x 属性的，故访问时输出 undefined；而访问 b.x 的时候，将输出旧对象的 x 的值，即{n:2}。

## 分别写出如下代码的返回值

```js
String('11') == new String('11');
String('11') === new String('11');
```

分析： new String() 返回的是对象

```js
// ==` 的时候，实际运行的是
String('11') == new String('11').toString();
```

## 考察作用域的一道代码题

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  // var a = 20;
  console.log(a);
})();
// 10 5 5
```

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
// undefined 10 20
```

在立即执行函数中，`var a = 20;` 语句定义了一个局部变量 `a`，由于 js 的变量声明提升机制，局部变量`a`的声明会被提升至立即执行函数的函数体最上方，且由于这样的提升并不包括赋值，因此第一条打印语句会打印`undefined`，最后一条语句会打印`20`。

由于变量声明提升，`a = 5;` 这条语句执行时，局部的变量`a`已经声明，因此它产生的效果是对局部的变量`a`赋值，此时`window.a` 依旧是最开始赋值的`10`.

分别为 undefined 　 10 　 20，原因是作用域问题，在内部声名 var a = 20;相当于先声明 var a;然后再执行赋值操作，这是在ＩＩＦＥ内形成的独立作用域，如果把 var a=20 注释掉，那么 a 只有在外部有声明，显示的就是外部的Ａ变量的值了。结果Ａ会是 10 　 5 　 5

## 写出如下代码的打印结果

```js
function changeObjProperty(o) {
  o.siteUrl = 'http://www.baidu.com';
  o = new Object();
  o.siteUrl = 'http://www.google.com';
}
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl);
```

对象传值传的是引用，但是引用是 copy 给函数形参。

```js
// 这里把o改成a
// webSite引用地址的值copy给a了
function changeObjProperty(a) {
  // 改变对应地址内的对象属性值
  a.siteUrl = 'http://www.baidu.com';
  // 变量a指向新的地址 以后的变动和旧地址无关
  a = new Object();
  a.siteUrl = 'http://www.google.com';
  a.name = 456;
}
var webSite = new Object();
webSite.name = '123';
changeObjProperty(webSite);
console.log(webSite); // {name: 123, siteUrl: 'http://www.baidu.com'}
```

`parseInt()` 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。

## 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？

在 ES5 中，顶层对象的属性和全局变量是等价的，var 命令和 function 命令声明的全局变量，自然也是顶层对象。

但 ES6 规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。

在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中

在定义变量的块级作用域中就能获取

const 和 let 会生成块级作用域，可以理解为

```js
let a = 10;
const b = 20;
相当于：
(function(){
    var  a = 10;
    var b = 20;
})()
```

ES5 没有块级作用域的概念，只有函数作用域，可以近似理解成这样。 所以外层 window 必然无法访问。

## 如何在 ES5 环境下实现 let

babel 在 let 定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数来模拟块级作用域

```js
(function () {
  for (var i = 0; i < 5; i++) {
    console.log(i); // 0 1 2 3 4
  }
})();

console.log(i); // Uncaught ReferenceError: i is not defined
```

不过这个问题并没有结束，我们回到`var`和`let/const`的区别上：

- `var`声明的变量会挂到 window 上，而`let`和`const`不会
- `var`声明的变量存在变量提升，而`let`和`const`不会
- `let`和`const`声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问
- 同一作用域下`let`和`const`不能声明同名变量，而`var`可以
- 暂时性死区，`let`和`const`声明的变量不能在声明前被使用

babel 的转化，其实只实现了第 2、3、5 点

## 如何在 ES5 环境下实现 const

对于 const 不可修改的特性，我们通过设置 writable 属性来实现

```js
function _const(key, value) {
  const desc = {
    value,
    writable: false,
  };
  Object.defineProperty(window, key, desc);
}

_const('obj', { a: 1 }); //定义obj
obj.b = 2; //可以正常给obj的属性赋值
obj = {}; //无法赋值新对象
```

## 下面的代码打印什么内容，为什么？

几个例子：

```js
var b = 10;
(function b() {
  // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值；
  // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。
  // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）
  b = 20;
  console.log(b); // [Function b]
  console.log(window.b); // 10，不是20
})();
```

所以严格模式下能看到错误：`Uncaught TypeError: Assignment to constant variable`

```js
var b = 10;
(function b() {
  'use strict';
  b = 20;
  console.log(b);
})(); // "Uncaught TypeError: Assignment to constant variable."
```

其他情况例子：

有`window`：

```js
var b = 10;
(function b() {
  window.b = 20;
  console.log(b); // [Function b]
  console.log(window.b); // 20是必然的
})();
```

有`var`:

```js
var b = 10;
(function b() {
  var b = 20; // IIFE内部变量
  console.log(b); // 20
  console.log(window.b); // 10
})();
```

## 下面代码输出什么

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
```

## 说一下==数据类型转换吧

当使用`==`进行比较的时候，会有以下转换规则（判断规则）：

1. 两边类型如果相同，值相等则相等，如 `2 == 3`肯定是为`false`的了
2. 比较的双方都为基本数据类型：

- 若是一方为`null、undefined`，则另一方必须为`null或者undefined`才为`true`，也就是`null == undefined`为`true`或者`null == null`为`true`，因为`undefined`派生于`null`
- 其中一方为`String`，是的话则把`String`转为`Number`再来比较
- 其中一方为`Boolean`，是的话则将`Boolean`转为`Number`再来比较

1. 比较的一方有引用类型：

- 将引用类型遵循类似`ToNumber`的转换形式来进行比较(也就是`toPrimitive(obj, 'defalut')`
- 两方都为引用类型，则判断它们是不是指向同一个对象

## typeof 为什么对 null 错误的显示

这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。

## setTimeout 的执行原理(EventLoop)

`setTimeout`的运行机制：执行该语句时，是立即把当前定时器代码推入事件队列，当定时器在事件列表中满足设置的时间值时将传入的函数加入任务队列，之后的执行就交给任务队列负责。但是如果此时任务队列不为空，则需等待，所以执行定时器内代码的时间可能会大于设置的时间

## requestAnimationFrame 有了解过吗？

`requestAnimationFrame`是浏览器用于定时循环操作的一个接口，类似于`setTimeout`，主要用途是按帧对网页进行重绘。对于`JS`动画，用`requestAnimationFrame` 会比 `setInterval` 效果更好。

## 平常工作中 ES6+主要用到了哪些？

`ES6`：

1. `Class`
2. 模块`import`和`export`
3. 箭头函数
4. 函数默认参数
5. `...`扩展运输符允许展开数组
6. 解构
7. 字符串模版
8. Promise
9. `let const`
10. `Proxy、Map、Set`
11. 对象属性同名能简写

`ES7`：

1. `includes`
2. `**`求幂运算符

`ES8`：

1. `async/await`
2. `Object.values()和Object.entries()`
3. `padStart()和padEnd()`
4. `Object.getOwnPropertyDescriptors()`
5. 函数参数允许尾部`,`

`ES9`：

1. `for...await...of`
2. `...`展开符合允许展开对象收集剩余参数
3. `Promise.finally()`
4. 正则中的四个新功能

`ES10`：

1. `flat()`
2. `flatMap()`
3. `fromEntries()`
4. `trimStart`和`trimEnd`
5. `matchAll`
6. `BigInt`
7. `try/catch`中报错允许没有`err`异常参数
8. `Symbol.prototype.description`
9. `Function.toString()`调用时呈现原本源码的样子

## 不使用框架如何实现组件按需加载以及原理

当时答的是是用`import`来按需引入，以及提到了`Vue.use`。

但后来有去了解，`babel-plugin-import`就可以实现。

## ES5 如何实现继承

说到继承，最容易想到的是 ES6 的`extends`，当然如果只回答这个肯定不合格，我们要从函数和原型链的角度上实现继承，下面我们一步步地、递进地实现一个合格的继承

- 原型链继承

原型链继承的原理很简单，直接让子类的原型对象指向父类实例，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而实现对父类的属性和方法的继承

```js
// 父类
function Parent() {
  this.name = '写代码像蔡徐抻';
}
// 父类的原型方法
Parent.prototype.getName = function () {
  return this.name;
};
// 子类
function Child() {}

// 让子类的原型对象指向父类实例, 这样一来在Child实例中找不到的属性和方法就会到原型对象(父类实例)上寻找
Child.prototype = new Parent();
Child.prototype.constructor = Child; // 根据原型链的规则,顺便绑定一下constructor, 这一步不影响继承, 只是在用到constructor时会需要

// 然后Child实例就能访问到父类及其原型上的name属性和getName()方法
const child = new Child();
child.name; // '写代码像蔡徐抻'
child.getName(); // '写代码像蔡徐抻'
```

缺点:

1. 由于所有 Child 实例原型都指向同一个 Parent 实例, 因此对某个 Child 实例的父类引用类型变量修改会影响所有的 Child 实例
2. 在创建子类实例时无法向父类构造传参, 即没有实现`super()`的功能

```js
// 示例:
function Parent() {
  this.name = ['写代码像蔡徐抻'];
}
Parent.prototype.getName = function () {
  return this.name;
};
function Child() {}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

// 测试
const child1 = new Child();
const child2 = new Child();
child1.name[0] = 'foo';
console.log(child1.name); // ['foo']
console.log(child2.name); // ['foo'] (预期是['写代码像蔡徐抻'], 对child1.name的修改引起了所有child实例的变化)
```

- 构造函数继承

构造函数继承，即在子类的构造函数中执行父类的构造函数，并为其绑定子类的`this`，让父类的构造函数把成员属性和方法都挂到`子类的this`上去，这样既能避免实例之间共享一个原型实例，又能向父类构造方法传参

```js
function Parent(name) {
  this.name = [name];
}
Parent.prototype.getName = function () {
  return this.name;
};
function Child() {
  Parent.call(this, 'zhangsan'); // 执行父类构造方法并绑定子类的this, 使得父类中的属性能够赋到子类的this上
}

//测试
const child1 = new Child();
const child2 = new Child();
child1.name[0] = 'foo';
console.log(child1.name); // ['foo']
console.log(child2.name); // ['zhangsan']
child2.getName(); // 报错,找不到getName(), 构造函数继承的方式继承不到父类原型上的属性和方法
```

缺点: 继承不到父类原型上的属性和方法

- 组合式继承

既然原型链继承和构造函数继承各有互补的优缺点, 那么我们为什么不组合起来使用呢, 所以就有了综合二者的组合式继承

```js
function Parent(name) {
  this.name = [name];
}
Parent.prototype.getName = function () {
  return this.name;
};
function Child() {
  // 构造函数继承
  Parent.call(this, 'zhangsan');
}
//原型链继承
Child.prototype = new Parent();
Child.prototype.constructor = Child;

//测试
const child1 = new Child();
const child2 = new Child();
child1.name[0] = 'foo';
console.log(child1.name); // ['foo']
console.log(child2.name); // ['zhangsan']
child2.getName(); // ['zhangsan']
```

缺点:

1. 每次创建子类实例都执行了两次构造函数(`Parent.call()`和`new Parent()`)，虽然这并不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅

- 寄生式组合继承

为了解决构造函数被执行两次的问题, 我们将`指向父类实例`改为`指向父类原型`, 减去一次构造函数的执行

```js
function Parent(name) {
  this.name = [name];
}
Parent.prototype.getName = function () {
  return this.name;
};
function Child() {
  // 构造函数继承
  Parent.call(this, 'zhangsan');
}
//原型链继承
// Child.prototype = new Parent()
Child.prototype = Parent.prototype; //将`指向父类实例`改为`指向父类原型`
Child.prototype.constructor = Child;

//测试
const child1 = new Child();
const child2 = new Child();
child1.name[0] = 'foo';
console.log(child1.name); // ['foo']
console.log(child2.name); // ['zhangsan']
child2.getName(); // ['zhangsan']
```

但这种方式存在一个问题，由于子类原型和父类原型指向同一个对象，我们对子类原型的操作会影响到父类原型，例如给`Child.prototype`增加一个 getName()方法，那么会导致`Parent.prototype`也增加或被覆盖一个 getName()方法，为了解决这个问题，我们给`Parent.prototype`做一个浅拷贝

```js
function Parent(name) {
  this.name = [name];
}
Parent.prototype.getName = function () {
  return this.name;
};
function Child() {
  // 构造函数继承
  Parent.call(this, 'zhangsan');
}
//原型链继承
// Child.prototype = new Parent()
Child.prototype = Object.create(Parent.prototype); //将`指向父类实例`改为`指向父类原型`
Child.prototype.constructor = Child;

//测试
const child = new Child();
const parent = new Parent();
child.getName(); // ['zhangsan']
parent.getName(); // 报错, 找不到getName()
复制代码;
```

到这里我们就完成了 ES5 环境下的继承的实现，这种继承方式称为`寄生组合式继承`，是目前最成熟的继承方式，babel 对 ES6 继承的转化也是使用了寄生组合式继承

我们回顾一下实现过程： 一开始最容易想到的是`原型链继承`，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型链继承的缺陷在于`对子类实例继承的引用类型的修改会影响到所有的实例对象`以及`无法向父类的构造方法传参`。 因此我们引入了`构造函数继承`, 通过在子类构造函数中调用父类构造函数并传入子类 this 来获取父类的属性和方法，但构造函数继承也存在缺陷，构造函数继承`不能继承到父类原型链上的属性和方法`。 所以我们综合了两种继承的优点，提出了`组合式继承`，但组合式继承也引入了新的问题，它`每次创建子类实例都执行了两次父类构造方法`，我们通过将`子类原型指向父类实例`改为`子类原型指向父类原型的浅拷贝`来解决这一问题，也就是最终实现 —— `寄生组合式继承`

![img](https://user-gold-cdn.xitu.io/2020/4/6/1714fd86c8983189?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 创建对象的几种方法

```js
//创建对象的几种方式
//1.字面量
var obj1 = { name: 'solo obj1' };
//2.new Object
var obj2 = new Object({ name: 'solo obj2' });
//3.构造函数创建
var M = function (name) {
  this.name = name;
};
var obj3 = new M('solo obj3');
//4.Object.create
var p = { name: 'p' };
var obj4 = Object.create(p);
```

## 原型、构造函数、实例、原型链

![img](https://pic3.zhimg.com/80/v2-a6b2ab6b93f5b72cee707e2d3ea327e2_720w.jpg)

- 构造函数.prototype.constructor === 构造函数

M.prototype.constructor === M 的结果为 true

- 构造函数.prototype === 实例对象.**proto**

M.prototype === obj3._ *proto*_ 的结果为 true

## instanceof 的原理

instanceof 用于判断一个引用类型是否属于某构造函数；还可以在继承关系中用来判断一个实例是否属于它的父类型。 instanceof 的原理是判断实例对象的 `__proto__` 是否与构造函数的 `prototype` 指向同一个引用（即同一个原型）

![img](https://pic1.zhimg.com/80/v2-330ec703451af6c71b641b8ba16741c8_720w.jpg)

只要在实例对象的原型链上的构造函数，instaceof 都会返回 true。看下图： obj3 是 M 的实例，所以 `obj3 instanceof M = true` ; 同时 `obj3 instanceof Object` 的结果也是 true

## instanceof 和 typeof 的区别

typeof 对于基本数据类型（null, undefined, string, number, boolean, symbol），除了 null 都会返回正确的类型。null 会返回 object。 typeof 对于对象类型，除了函数会返回 function，其他的都返回 object。如果我们想获得一个变量的正确类型，可以通过 `Object.prototype.toString.call(xx)`。这样我们就可以获得类似 `[object Type]` 的字符串。

判断是否等于 undefined 的方法：

```js
let a;
// 我们也可以这样判断 undefined
a === undefined;
// 但是 undefined 不是保留字，能够在低版本浏览器被赋值
let undefined = 1;
// 这样判断就会出错
// 所以可以用下面的方式来判断，并且代码量更少
// 因为 void 后面随便跟上一个组成表达式
// 返回就是 undefined  或者void(0)
a === void 0;
```

## 类的声明和实例化

声明类有两种方法：

```js
function Animal(name) {
  this.name = name;
}

class Animal2 {
  constructor(name) {
    this.name = name;
  }
}
```

类的实例化只有一种方式

```js
var a1 = new Animal('shape');
var a2 = new Animal2('cat');
```

## call 和 apply 共同点

- 都能够改变函数执行时的上下文，将一个对象的方法交给另一个对象来执行，并且是立即执行的。
- 调用 call 和 apply 的对象，必须是一个函数 Function

## call 和 apply 的区别

区别主要体现在参数上。 call 的写法： Function.call(obj,[param1[,param2[,…[,paramN]]]])

调用 call 的对象，必须是个函数 Function。 call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。

```js
function func(a, b, c) {}
func.call(obj, 1, 2, 3);
// func 接收到的参数实际上是 1,2,3
func.call(obj, [1, 2, 3]);
// func 接收到的参数实际上是 [1,2,3],undefined,undefined
```

apply 的写法 Function.apply(obj[,argArray]) 复制代码

- 它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。
- 第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。

```js
func.apply(obj, [1, 2, 3]);
// func 接收到的参数实际上是 1,2,3
func.apply(obj, {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
});
// func 接收到的参数实际上是 1,2,3
```

## call 和 apply 的用途

下面会分别列举 call 和 apply 的一些使用场景。声明：例子中没有哪个场景是必须用 call 或者必须用 apply 的，只是个人习惯这么用而已。

- call 的使用场景

**1、对象的继承**。如下面这个例子：

```text
function superClass () {
    this.a = 1;
    this.print = function () {
        console.log(this.a);
    }
}
function subClass () {
    superClass.call(this);
    this.print();
}
subClass();
// 1
```

subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。此外，subClass 还可以扩展自己的其他方法。 **2、借用方法**。还记得刚才的类数组么？如果它想使用 Array 原型链上的方法，可以这样： let domNodes = Array.prototype.slice.call(document.getElementsByTagName("\*"));

这样，domNodes 就可以应用 Array 下的所有方法了。

- apply 的使用场景

**1、Math.max**。用它来获取数组中最大的一项。

```text
let max = Math.max.apply(null, array);
```

同理，要获取数组中最小的一项，可以这样：

```text
let min = Math.min.apply(null, array);
```

**2、实现两个数组合并**。在 ES6 的扩展运算符出现之前，我们可以用 Array.prototype.push 来实现。

```text
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
Array.prototype.push.apply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5, 6]
```

## bind 的使用

最后来说说 bind。在 MDN 上的解释是：bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。它的语法如下：

```text
Function.bind(thisArg[, arg1[, arg2[, ...]]])
```

bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，**bind 方法的返回值是函数，并且需要稍后调用，才会执行**。而 apply 和 call 则是立即调用。

来看下面这个例子：

```text
function add (a, b) {
    return a + b;
}
function sub (a, b) {
    return a - b;
}
add.bind(sub, 5, 3); // 这时，并不会返回 8
add.bind(sub, 5, 3)(); // 调用后，返回 8
```

如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。总结 call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。 bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。

## 闭包

闭包是指有权访问另一个函数作用域中的变量的函数。

```js
function sayHi(name) {
  return () => {
    console.log(`Hi! ${name}`);
  };
}
const test = sayHi('xiaoming');
test(); // Hi! xiaoming
```

虽然 sayHi 函数已经执行完毕，但是其活动对象也不会被销毁，因为 test 函数仍然引用着 sayHi 函数中的变量 name，这就是闭包。但也因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用。

## 使用 let、var 和 const 创建变量有什么区别

用 var 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。let 和 const 是块级作用域，意味着它们只能在最近的一组花括号（function、if-else 代码块或 for 循环中）中访问。

```js
function foo() {
  // 所有变量在函数中都可访问
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';

  console.log(bar); // bar
  console.log(baz); // baz
  console.log(qux); // qux
}

console.log(bar); // ReferenceError: bar is not defined
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
if (true) {
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';
}

// 用 var 声明的变量在函数作用域上都可访问
console.log(bar); // bar
// let 和 const 定义的变量在它们被定义的语句块之外不可访问
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
```

var 会使变量提升，这意味着变量可以在声明之前使用。let 和 const 不会使变量提升，提前使用会报错。

```js
console.log(foo); // undefined

var foo = 'foo';

console.log(baz); // ReferenceError: can't access lexical declaration 'baz' before initialization

let baz = 'baz';

console.log(bar); // ReferenceError: can't access lexical declaration 'bar' before initialization

const bar = 'bar';
```

用 var 重复声明不会报错，但 let 和 const 会。

```js
var foo = 'foo';
var foo = 'bar';
console.log(foo); // "bar"

let baz = 'baz';
let baz = 'qux'; // Uncaught SyntaxError: Identifier 'baz' has already been declared
```

let 和 const 的区别在于：let 允许多次赋值，而 const 只允许一次。

```js
// 这样不会报错。
let foo = 'foo';
foo = 'bar';

// 这样会报错。
const baz = 'baz';
baz = 'qux';
```

[https://github.com/yangshun/fro](https://link.zhihu.com/?target=https%3A//github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Chinese/questions/javascript-questions.md%23%E4%BD%BF%E7%94%A8letvar%E5%92%8Cconst%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)

## 对象浅拷贝和深拷贝有什么区别

在 `JS` 中，除了基本数据类型，还存在对象、数组这种引用类型。 基本数据类型，拷贝是直接拷贝变量的值，而引用类型拷贝的其实是变量的地址。

```text
let o1 = {a: 1}
let o2 = o1
```

在这种情况下，如果改变 `o1` 或 `o2` 其中一个值的话，另一个也会变，因为它们都指向同一个地址。

```text
o2.a = 3
console.log(o1.a) // 3
```

而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有重新创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。

## 怎么实现对象深拷贝

```js
let o1 = {
  a: {
    b: 1,
  },
};
let o2 = JSON.parse(JSON.stringify(o1));
```

另一种方法

```js
function deepCopy(s) {
  const d = {};
  for (let k in s) {
    if (typeof s[k] == 'object') {
      d[k] = deepCopy(s[k]);
    } else {
      d[k] = s[k];
    }
  }

  return d;
}
```

## 数组去重

ES5

```js
function unique(arry) {
  const temp = [];
  arry.forEach(function (item) {
    if (temp.indexOf(item) == -1) {
      temp.push(item);
    }
  });

  return temp;
}
```

ES6

```js
function unique(arry) {
  return Array.from(new Set(arry));
}
```

## 数据类型

1. Undefined
2. Null
3. Boolean
4. Number
5. String
6. Object
7. symbol(ES6 新增)

## 内置函数(原生函数)

- String
- Number
- Boolean
- Object
- Function
- Array
- Date
- RegExp
- Error
- Symbol

原始值 "I am a string" 并不是一个对象，它只是一个字面量，并且是一个不可变的值。 如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那需要将其 转换为 String 对象。 幸好，在必要时语言会自动把字符串字面量转换成一个 String 对象，也就是说你并不需要 显式创建一个对象。

## 如何判断数组与对象

```js
Array.isArray([]); // true
Array.isArray({}); // false

typeof []; // "object"
typeof {}; // "object"

Object.prototype == [].__proto__; // false
Object.prototype == {}.__proto__; // true
Array.prototype == [].__proto__; // true
Array.prototype == {}.__proto__; // false
```

## 自执行函数?用于什么场景？好处?

自执行函数:1、声明一个匿名函数 2、马上调用这个匿名函数。作用：创建一个独立的作用域。

好处：防止变量弥散到全局，以免各种 js 库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理

场景：一般用于框架、插件等场景

## 请简述`JavaScript`中的`this`。

是什么：是函数运行时内部自动生成的一个内部对象，只能在函数内部使用

JS 中的`this`是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了`this`的值。我阅读了网上很多关于`this`的文章，[Arnav Aggrawal](https://link.zhihu.com/?target=https%3A//medium.com/%40arnav_aggarwal) 写的比较清楚。`this`取值符合以下规则：

1. 在调用函数时使用`new`关键字，函数内的`this`是一个全新的对象。
2. 如果`apply`、`call`或`bind`方法用于调用、创建一个函数，函数内的 this 就是作为参数传入这些方法的对象。
3. 当函数作为对象里的方法被调用时，函数内的`this`是调用该函数的对象。比如当`obj.method()`被调用时，函数内的 this 将绑定到`obj`对象。
4. 如果调用函数不符合上述规则，那么`this`的值指向全局对象（global object）。浏览器环境下`this`的值指向`window`对象，但是在严格模式下(`'use strict'`)，`this`的值为`undefined`。
5. 如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定`this`的值。
6. 如果该函数是 ES2015 中的箭头函数，将忽略上面的所有规则，`this`被设置为它被创建时的上下文。

如何确定：如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。 1. 由 new 调用？绑定到新创建的对象。 2. 由 call 或者 apply （或者 bind ）调用？绑定到指定的对象。 3. 由上下文对象调用？绑定到那个上下文对象。 4. 默认：在严格模式下绑定到 undefined ，否则绑定到全局对象。

一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null) ，以保护全局对象。 ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this ，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这其实和 ES6 之前代码中的 self = this 机制一样

## 箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？

箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：

1、函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象，用 call，apply，bind 也不能改变`this`指向

2、不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

3、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

4、不可以使用 new 命令，因为：

- 没有自己的 this，无法调用 call，apply。
- 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 **proto**

## == 和 ===的区别是什么

`==`是抽象相等运算符，而`===`是严格相等运算符。`==`运算符是在进行必要的类型转换后，再比较。`===`运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回`false`。使用`==`时，可能发生一些特别的事情，例如：

```js
1 == '1'; // true
1 == [1]; // true
1 == true; // true
0 == ''; // true
0 == '0'; // true
0 == false; // true
```

如果你对`==`和`===`的概念不是特别了解，建议大多数情况下使用`===`
