#### 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣 Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()

#### toString.call 和 isArray 的性能一样差，instanceof 稍好，constructor 性能最好

#### 1. Object.prototype.toString.call()

每一个继承 Object 的对象都有 `toString` 方法，如果 `toString` 方法没有重写的话，会返回 `[Object type]`，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 `toString` 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文。

```js
const an = ['Hello', 'An'];
an.toString(); // "Hello,An"
Object.prototype.toString.call(an); // "[object Array]"
```

这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。

```js
Object.prototype.toString.call('An'); // "[object String]"
Object.prototype.toString.call(1); // "[object Number]"
Object.prototype.toString.call(Symbol(1)); // "[object Symbol]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(function () {}); // "[object Function]"
Object.prototype.toString.call({ name: 'An' }); // "[object Object]"
```

`Object.prototype.toString.call()` 常用于判断浏览器内置对象时。

更多实现可见 [谈谈 Object.prototype.toString](https://juejin.im/post/591647550ce4630069df1c4a)

#### 2. instanceof

`instanceof` 的内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

使用 `instanceof`判断一个对象是否为数组，`instanceof` 会判断这个对象的原型链上是否会找到对应的 `Array` 的原型，找到返回 `true`，否则返回 `false`。

```js
[] instanceof Array; // true
```

但 `instanceof` 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。

```javascript
[] instanceof Object; // true
```

#### 3. Array.isArray()

- 功能：用来判断对象是否为数组

- instanceof 与 isArray

  当检测 Array 实例时，`Array.isArray` 优于 `instanceof` ，因为 `Array.isArray` 可以检测出 `iframes`

  ```javascript
  var iframe = document.createElement('iframe');
  document.body.appendChild(iframe);
  xArray = window.frames[window.frames.length - 1].Array;
  var arr = new xArray(1, 2, 3); // [1,2,3]

  // Correctly checking for Array
  Array.isArray(arr); // true
  Object.prototype.toString.call(arr); // true
  // Considered harmful, because doesn't work though iframes
  arr instanceof Array; // false
  ```

- `Array.isArray()` 与 `Object.prototype.toString.call()`

  `Array.isArray()`是 ES5 新增的方法，当不存在 `Array.isArray()` ，可以用 `Object.prototype.toString.call()` 实现。

  ```javascript
  if (!Array.isArray) {
    Array.isArray = function (arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    };
  }
  ```

#### 4. arr.constructor === Array

```js
console.log({ a: 23 }.toString());
console.log([{ a: 23 }].toString());
console.log(Object.prototype.toString.call([{ a: 23 }]));
console.log([{ a: 23 }].constructor === Array);
console.log({ a: 23 }.constructor === Array);
```

# `a.b.c.d` 和 `a['b']['c']['d']` ，哪个性能更高？

应该是 `a.b.c.d` 比 `a['b']['c']['d']` 性能高点，后者还要考虑 `[ ]` 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。

# 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果

```js
[102, 15, 22, 29, 3, 8];
```

解析：

根据 MDN 上对`Array.sort()`的解释，默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的 UTF-16 编码顺序来进行排序。所以`'102'` 会排在 `'15'` 前面。

# 第 75 题：数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少

数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)

JavaScript 没有真正意义上的数组，所有的数组其实是对象，其“索引”看起来是数字，其实会被转换成字符串，作为属性名（对象的 key）来使用。所以无论是取第 1 个还是取第 10 万个元素，都是用 key 精确查找哈希表的过程，其消耗时间大致相同。

得出结论：**消耗时间几乎一致，差异可以忽略不计**。

# 变量提升相关

```js
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

```js
// Goodbye Jack
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    var name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

```js
// Hello Tom
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    let name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

# 第 27 题：关于 const 和 let 声明的变量不在 window 上

在 ES5 中，顶层对象的属性和全局变量是等价的，var 命令和 function 命令声明的全局变量，自然也是顶层对象。

但 ES6 规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。

在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中

在定义变量的块级作用域中就能获取

# 第 102 题：不用加减乘除运算符，求整数的 7 倍

```js
const ax = (multiple, num) => Array(multiple).fill(Array(num).fill(1)).flat().length;

console.log(ax(7, 2));

console.log(Array(7).fill(1));
console.log([...Array(7)]);
```

# 第 38 题：下面代码中 a 在什么情况下会打印 1？

> 题目如下

```js
var a = ?;
if (a == 1 && a == 2 && a == 3) {
 	console.log(1);
}
```

这个题目考察==的隐式转换吧

> 利用 toString

```js
let a = {
  i: 1,
  toString() {
    a.i += 1;
    return a.i - 1;
  },
};

if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

> 利用 valueOf

```js
let a = {
  i: 1,
  valueOf() {
    a.i += 1;
    return a.i - 1;
  },
};

if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

> 数组这个就有点妖了

```js
var a = [1, 2, 3];
a.join = a.shift;
if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

> ES6 的 symbol

```js
let a = { [Symbol.toPrimitive]: ((i) => () => ++i)(0) };
if (a == 1 && a == 2 && a == 3) {
  console.log('1');
}
```

[从 (a==1&&a==2&&a==3) 成立中看 javascript 的隐式类型转换](https://yq.aliyun.com/articles/399499)

# 第 55 题：某公司 1 到 12 月份的销售额存在一个对象里面

```js
const obj = { 1: 222, 2: 123, 5: 888 };
const result = Array.from({ length: 12 }).map((_, index) => obj[index + 1] || null);
const result1 = [...Array(12)].map((_, index) => obj[index + 1] || null);
```

> 生成指定长度数组的几种方法

```js
[...new Array(12)]

[...Array(12)]

Array.from({ length : 12 })
```

# 第 11 题：将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组

已知如下数组：

var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];

编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

```js
Array.from(new Set(arr.flat(Infinity))).sort((a, b) => a - b);
```

# 第 58 题：箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？

箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：

1、函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。

2、不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

3、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

4、不可以使用 new 命令，因为：

- 没有自己的 this，无法调用 call，apply。
- 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 **proto**

# 第 33 题：下面的代码打印什么内容，为什么？

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
// 打印 Function b
```

1. 函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。

2. 对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。

3. IIFE 中的函数是函数表达式，而不是函数声明。

   b 函数是一个相当于用 const 定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错"Uncaught TypeError: Assignment to constant variable."

如果用 ' use strict ' 的话 会导致报错

# 第 53 题：输出以下代码的执行结果并解释为什么

结果: undefined {n:2}

首先，a 和 b 同时引用了{n:2}对象，接着执行到 a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行 a.x，相当于为 a（或者 b）所指向的{n:1}对象新增了一个属性 x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行 a ={n:2}的时候，a 的引用改变，指向了新对象{n：2},而 b 依然指向的是旧对象。之后执行 a.x = {n：2}的时候，并不会重新解析一遍 a，而是沿用最初解析 a.x 时候的 a，也即旧对象，故此时旧对象的 x 的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被 b 引用着。后面输出 a.x 的时候，又要解析 a 了，此时的 a 是指向新对象的 a，而这个新对象是没有 x 属性的，故访问时输出 undefined；而访问 b.x 的时候，将输出旧对象的 x 的值，即{n:2}。

# 第 106 题：分别写出如下代码的返回值

```js
String('11') == new String('11');
String('11') === new String('11');
```

分析： new String() 返回的是对象

```
==` 的时候，实际运行的是
`String('11') == new String('11').toString();
```

`===` 不再赘述。

# 第 41 题：考察作用域的一道代码题

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  // var a = 20;
  console.log(a);
})();
// 10 5 5
```

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
// undefined 10 20
```

在立即执行函数中，`var a = 20;` 语句定义了一个局部变量 `a`，由于 js 的变量声明提升机制，局部变量`a`的声明会被提升至立即执行函数的函数体最上方，且由于这样的提升并不包括赋值，因此第一条打印语句会打印`undefined`，最后一条语句会打印`20`。

由于变量声明提升，`a = 5;` 这条语句执行时，局部的变量`a`已经声明，因此它产生的效果是对局部的变量`a`赋值，此时`window.a` 依旧是最开始赋值的`10`.

分别为 undefined 　 10 　 20，原因是作用域问题，在内部声名 var a = 20;相当于先声明 var a;然后再执行赋值操作，这是在ＩＩＦＥ内形成的独立作用域，如果把 var a=20 注释掉，那么 a 只有在外部有声明，显示的就是外部的Ａ变量的值了。结果Ａ会是 10 　 5 　 5

# 第 98 题：写出如下代码的打印结果

```js
function changeObjProperty(o) {
  o.siteUrl = 'http://www.baidu.com';
  o = new Object();
  o.siteUrl = 'http://www.google.com';
}
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl);
```

对象传值传的是引用，但是引用是 copy 给函数形参。

```js
// 这里把o改成a
// webSite引用地址的值copy给a了
function changeObjProperty(a) {
  // 改变对应地址内的对象属性值
  a.siteUrl = 'http://www.baidu.com';
  // 变量a指向新的地址 以后的变动和旧地址无关
  a = new Object();
  a.siteUrl = 'http://www.google.com';
  a.name = 456;
}
var webSite = new Object();
webSite.name = '123';
changeObjProperty(webSite);
console.log(webSite); // {name: 123, siteUrl: 'http://www.baidu.com'}
```

`parseInt()` 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。

# 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？

const 和 let 会生成块级作用域，可以理解为

```js
let a = 10;
const b = 20;
相当于：
(function(){
         var  a = 10;
         var b = 20;
})()
```

ES5 没有块级作用域的概念，只有函数作用域，可以近似理解成这样。 所以外层 window 必然无法访问。

# 下面的代码打印什么内容，为什么？

几个例子：

```js
var b = 10;
(function b() {
  // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值；
  // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。
  // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）
  b = 20;
  console.log(b); // [Function b]
  console.log(window.b); // 10，不是20
})();
```

所以严格模式下能看到错误：`Uncaught TypeError: Assignment to constant variable`

```js
var b = 10;
(function b() {
  'use strict';
  b = 20;
  console.log(b);
})(); // "Uncaught TypeError: Assignment to constant variable."
```

其他情况例子：

有`window`：

```js
var b = 10;
(function b() {
  window.b = 20;
  console.log(b); // [Function b]
  console.log(window.b); // 20是必然的
})();
```

有`var`:

```js
var b = 10;
(function b() {
  var b = 20; // IIFE内部变量
  console.log(b); // 20
  console.log(window.b); // 10
})();
```

# 下面代码输出什么

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
```

# 使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果

`sort` 函数，可以接收一个函数，返回值是比较两个数的相对顺序的值

默认没有函数 是按照 `UTF-16` 排序的，对于字母数字 你可以利用 `ASCII` 进行记忆
