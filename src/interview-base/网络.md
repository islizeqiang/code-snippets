[TOC]

## 在项目中如何把 http 的请求换成 https

由于我在项目中是会对`axios`做一层封装，所以每次请求的域名也是写在配置文件中，有一个`baseURL`字段专门用于存储它，所以只要改这个字段就可以达到替换所有请求`http`为`https`了。

也可以利用`meta`标签把`http`请求换为`https`:

```html
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" />
```

## 浏览器简单请求和非简单请求

- 简单请求
  - 请求方法为 GET、POST 或者 HEAD
  - 请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`)
- 除了上述情况就非简单请求

## 你们的 token 一般是存放在哪里的

`Token`其实就是**访问资源的凭证**。

一般是用户通过用户名和密码登录成功之后，服务器将登陆凭证做数字签名，加密之后得到的字符串作为`token`。

它在用户登录成功之后会返回给客户端，客户端主要有这么几种存储方式

2. 存储在`cookie`中，让它自动发送
3. 拿到之后存储在`localStorage`中，每次调用接口的时候放在`HTTP`请求头里的 Authorization

## 介绍下如何实现 token 加密

1. 需要一个 secret（随机数）
2. 后端利用 secret（随机数） 和加密算法(如：HMAC-SHA256)对 payload(如账号密码)生成一个字符串(token)，返回前端
3. 前端每次 request 在 header 中带上 token
4. 后端用同样的算法解密

## 常见 HTTP 状态码有哪些

HTTP 状态码的英文为 HTTP Status Code。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。

**1xx 表示是临时响应，代表着请求已经被接受，但需要继续处理。**

100 Continue 这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。

101 Switching Protocols。该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。

**2xx 表示请求已被成功接收、理解、接受。**

200 OK 是见得最多的成功状态码。通常在响应体中放有数据。

204 No Content 含义与 200 相同，但响应头后没有 body 数据。

206 Partial Content 表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段`Content-Range`。

**3xx 重定向状态，资源位置发生变动，需要重新请求。**

301 Moved Permanently 即永久重定向，比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回`301`，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。不会让网站的排名因为网址变更而收到丝毫影响。

302 Found 即临时重定向，不会做缓存优化，会降低网站的排名。

304 Not Modified: 当协商缓存命中时会返回这个状态码。

307 Temporary Redirect：临时重定向响应状态码，在 GET 请求下和 302 无差别，但 307 可以确保请求方法和消息主体不会发生变化，而 302 不能确保。

**4xx 客户端错误--请求有语法错误或请求无法实现。**

400 Bad Request: 服务器不理解请求的语法，常见于客户端传参错误

401 Unauthorized：请求未经授权，常见于客户端未登录

403 Forbidden: 服务器禁止访问，比如法律禁止、信息敏感，常见于客户端权限不足

404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。

405 Method Not Allowed: 请求方法不被服务器端允许。

416 Range Not Satisfiable: 意味着服务器无法处理所请求的数据区间，请求的数据区间不在文件范围之内。

499 Client Closed Request：不是标准状态码，nginx 在处理请求时客户端关闭连接。

**5xx 服务器端错误--服务器未能实现合法的请求。**

500 Internal Server Error: 仅仅告诉你服务器出错了，所请求的服务器遇到意外的情况并阻止其执行请求。

501 Not Implemented: 表示客户端请求的功能还不支持。

502 Bad Gateway: 作为网关或者代理服务器尝试执行请求时，从上游服务器接收到无效的响应。

503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务，通常是暂时状态。

504 Gateway Timeout 表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应。

## 讲讲网络 OSI 七层模型，TCP/IP 和 HTTP 分别位于哪一层

![alt](https://user-gold-cdn.xitu.io/2020/1/28/16fec363208256b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

| 模型       | 概述                                                   | 单位   |
| ---------- | ------------------------------------------------------ | ------ |
| 物理层     | 网络连接介质，如网线、光缆，数据在其中以比特为单位传输 | bit    |
| 数据链路层 | 数据链路层将比特封装成数据帧并传递                     | 帧     |
| 网络层     | 定义 IP 地址，定义路由功能，建立主机到主机的通信       | 数据包 |
| 传输层     | 负责将数据进行可靠或者不可靠传递，建立端口到端口的通信 | 数据段 |
| 会话层     | 控制应用程序之间会话能力，区分不同的进程               |        |
| 表示层     | 数据格式标识，基本压缩加密功能                         |        |
| 应用层     | 各种应用软件                                           |        |

## 接口如何防刷

防刷一般分两种：

- 总调用次数受限制。这个一般是在后端做限制，单位时间内最多可调用次数。
- 同一客户端次数限制。这个前端的一般使用是给接口调用加锁，在返回结果或者一定时间之后解锁。也可使用人机验证，验证码，短信码。滑动图片等形式

## TCP 和 UDP 的区别？

TCP：是面向连接的，可靠的，基于字节流的传输层协议。

- 面向连接： 通信之前 需要三次握手
- 可靠性
  1.  有状态：准确记录哪些发送成功，哪些失败了。通过滑动窗口解决数据丢包，顺序不对等问题。
  2.  可控制：当丢包或者当前网络环境不佳，会调整自己的行为，控制发送速度。通过拥塞窗口实现对流量的控制。
- 面向字节流：将一个个 IP 包（基于数据包）变成了字节流

## http1.0、1.1、2.0、3.0 协议的区别？

- http/1 :

  1. 默认不支持长连接，需要设置 keep-alive 参数指定
  2. 强缓存 expired、协商缓存 last-modified \ if-modified-since 有一定的缺陷

- http 1.1 :

  1. 默认长连接(keep-alive)，http 请求可以复用 TCP 连接，但是同一时间只能对应一个 http 请求(http 请求在一个 TCP 中是串行的)
  2. 增加了强缓存 cache-control、协商缓存 etag \ if-none-match 是对 http/1 缓存的优化

- http/2 : 默认使用 TLS1.2+

  1. 多路复用，一个 TCP 中多个 http 请求是并行的
  2. 二进制格式编码传输，头信息和数据体都是二进制
  3. header 压缩
  4. 服务端主动推送

- http/3：

  虽然 HTTP2 的多路复用解决了队头阻塞问题，但共用一个 TCP 连接会导致在丢包的情况下，整个 TCP 都要等待重传，也就导致后面所有的数据都阻塞了。

  基于 UDP 协议之上开发了一个叫 QUIC 协议，实现了多路复用，0-RTT（类似 TCP 快速打开，缓存当前会话上下文），流量控制，丢包重传等功能

## 对于定长和不定长的数据，HTTP 是怎么传输的？

定长包体采用 Content-Length 头标识指明包体长度。如果设置不当可能导致传输失败。

不定长包体 采用 Transfer-Encoding: chunked 头标识表示分块传输数据，会使忽略 Content-Length 字段，基于长连接持续推送内容。

## HTTP 如何处理大文件的传输？

首先服务端响应头 Accept-Ranges: bytes 来告知客户端 支持范围请求。

客户端通过请求头 Range 字段指定请求哪一部分。但如果超过范围，则返回 416，如果在范围内，返回 206。

1. 单段数据 （Range: bytes=0-9; ）

   ```http
   HTTP/1.1 206 Partial Content
   Content-Length: 10
   Accept-Ranges: bytes
   Content-Range: bytes 0-9/100
   ```

2. 多段数据 （Range: (bytes = 0 - 9), 30 - 39;）

   ```http
   HTTP/1.1 206 Partial Content
   // 响应体中的分隔符是00000010101
   Content-Type: multipart/byteranges; boundary=00000010101
   Content-Length: 189
   Connection: keep-alive
   Accept-Ranges: bytes
   ```

--00000010101 Content-Type: text/plain Content-Range: bytes 0-9/96

i am xxxxx --00000010101 Content-Type: text/plain Content-Range: bytes 20-29/96

eex jspy e --00000010101--

## HTTP 中如何处理表单数据的提交？

- application/x-www-form-urlencoded

- 其中的数据会被编码成以`&`分隔的键值对

- 字符以**URL 编码方式**编码。

```js
// 转换过程: {a: 1, b: 2} -> a=1&b=2 -> 如下(最终形式)
'a%3D1%26b%3D2';
```

- multipart/form-data

- 请求头中 Content-Type 字段包含 boundary，且其值有浏览器默认指定。

```http
// 请求体中的分隔符是WebkitFormBoundaryRRJKeWfHPGrS4LKe
Content-Type: multipart/form-data;boundary=WebkitFormBoundaryRRJKeWfHPGrS4LKe
```

- 数据会分为多个部分

在实际的场景中，对于图片等文件的上传，基本采用`multipart/form-data`而不用`application/x-www-form-urlencoded`，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间

## Http 与 Https 的区别

- HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头
- HTTP 是不安全的，而 HTTPS 是安全的
- HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443
- 在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 的安全传输机制工作在传输层
- HTTP 无法加密，而 HTTPS 对传输的数据进行加密
- HTTP 无需证书，而 HTTPS 需要 CA 机构颁发的 SSL 证书

https 为什么是安全的？

1. 所有信息加密传输，第三方无法窃听
2. 具有校验机制，一旦被篡改，通信双方会发现
3. 具备身份证书，防止身份被冒充

## 介绍 HTTPS 握手过程

https 是使用 SSL/TLS 的 HTTP 通信。 TLS1.0 = SSL 3.1

TLS1.3 在 TLS1.2 的基础上废除了大量的算法，提升了安全性

- 对称加密是指加密和解密用的是同样的密钥。
- 非对称加密，A 加密后的只能 B 解密，B 加密后的只能 A 来解密。

所以采用对称加密和非对称加密结合的方式。

1. 客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello 请求。给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
2. 服务器收到客户端请求后，向客户端发出回应，这叫做 SeverHello。确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
3. 客户端收到服务器回应以后，确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器。
4. 服务器使用自己的私钥，解密出客户端发来的随机数（即 Premaster secret）。
5. 客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。

[![img](http://47.98.159.95/my_blog/http/010.jpg)](http://47.98.159.95/my_blog/http/010.jpg)

## HTTPS 握手过程中，客户端如何验证证书的合法性

1. 浏览器校验证书的有效期和是否被吊销，还有证书的网站域名和证书的颁发域名是否是一致的。

2. 浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者做比对，校验是否为合法机构颁发。

3. 如果是合法机构颁发， 那么浏览器就会从操作系统中取出本地的这个机构的公钥，用这个公钥解密出服务器发来证书的签名。 接下来用相同的算法， 生成一个自己的证书签名，和解密出的签名做对比。

## 介绍下 HTTPS 中间人攻击

1. 服务器向客户端发送公钥。
2. 攻击者截获公钥，保留在自己手上。
3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
4. 客户端收到伪造的公钥后，生成加密 hash 值发给服务器。
5. 攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。
6. 同时生成假的加密 hash 值，发给服务器。
7. 服务器用私钥解密获得假秘钥。服务器用假秘钥加密传输信息

## RESTful 是什么

我理解是表现层状态转化，指得是一组架构约束条件和原则。

- 表现层：资源具体呈现的形式
- 状态转化：客户端想要操作服务器，必须通过某种手段，使服务器端发生状态转化。
- 一个 URI 代表一种资源。
- 客户端通过四个 HTTP 动词，对服务器端资源进行操作，实现"表现层状态转化"。

## 如何理解 HTTP 的请求方法？

- GET: 通常用来获取资源
- POST: 提交数据，即上传数据
- PUT: 修改数据
- DELETE: 删除资源
- OPTIONS: 列出可对资源实行的请求方法，用来跨域请求

GET 和 POST 有什么区别？

1. 参数：GET 放在 URL 中，长度一般有限制，POST 可以放在请求体，适合传输敏感信息。
2. 幂等：GET 是幂等的，POST 不是。幂等是对同一个资源进行多次请求都有相同的副作用，比如搜索，但删除，新增就不是。
3. 缓存：GET 会被缓存留下历史记录，POST 默认不会
4. 编码：GET 只能进行 URL 编码（ASCII 字符）
5. TCP：GET 一次性发出去，POST 会分两个数据包，首先发 header，如果响应 100，则发 body。

## 对 Content 系列字段了解多少？

1. 数据格式

Content-type Accept

- text/html text/plain text/css 等
- image/gif image/jpeg image/png 等
- audio/mpeg video/mp4 等
- application/json application/javascript application/pdf application/octet-stream

2. 压缩方式

Content-Encoding Accept-Encoding

- gzip 当前最流行的压缩方式
- deflate 另外一种著名的压缩格式
- br 一种专门为 HTTP 发明的压缩算法

3. 支持语言

Content-Language Accept-Language 可取值 zh-CN, zh, en

4. 字符集

发送端 Content-Type: text/html; charset=utf-8

接受端 Accept-Charset: charset=utf-8

## 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？

特点：

1. 灵活可扩展：传输形式的多样性，可以传输文本，图片，视频等。
2. 可靠传输：基于 TCP/IP
3. 请求应答：一发一收，有来有回，更好追溯问题。
4. 无状态：每次 http 请求都是独立的 无关的

缺点：

1. 无状态：导致客户端每次都要证实自己的身份
2. 明文传输：更容易被攻击
3. 队头阻塞问题：当共有一个 TCP 时，同一时刻只能处理一个请求，当前请求耗时较长，则会导致后面的只能阻塞。

## 如何解决 HTTP 的队头阻塞问题？

- 对于一个域名来说，可以分配多个 TCP 长连接，在 Chrome 中是 6 个。
- 多分几个域名，使得 TCP 长连接更多。
- 采用 HTTP2 的多路复用

## 简单讲解一下 http2 的多路复用

HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免队头阻塞问题。

由于是不按顺序发送的，同一个 TCP 连接里的数据包可能属于不同的回应，所以引入了数据流的概念，每个数据流都有独一无二的 ID，并且客户端发出的 ID 为奇数，服务端发出的为偶数。这里需要注意的一点是当 ID 到达上限会重开一个 TCP 连接。 每个数据流是由多个数据帧组成的。可以指定其所属数据流的优先级，让服务器优先响应。

## 为什么 HTTP1.1 不能实现多路复用

HTTP/1.1 不是二进制传输，而是通过文本进行传输。并且没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。

## 对 Cookie 了解多少？

作用是为了状态保留，服务器可用 Set-Cookie 字段写入客户端

1. Expires 过期时间
2. Max-Age 一段时间间隔过期
3. Domain 域名匹配，必须同一域名，不能设置跨域的
4. Path 路径匹配，例如 /path 会给/path12 绑定
5. Secure 属性，通过 HTTPS 协议
6. HttpOnly 只能通过 HTTP 传输，JS 无法获取，预防 XSS 攻击
7. SameSite Strict 只有当前网页的 URL 与请求目标一致，预防 CSRF 攻击
8. SameSite Lax a 链接，预加载请求，GET 表单，预防 CSRF 攻击
9. SameSite None 请求会自动携带上 Cookie 必须设置 Secure

80 版本 chrome 将 Cookie 默认设置成 Lax，使得必须显式设置为 none 才能携带，但显式设置必须在 HTTPS 协议下。

缺点

1. 容量缺陷，只有 4KB
2. 性能 不管域名下的某一地址是否需要，默认都会携带。但可设置作用域匹配和路径匹配
3. 安全 纯文本形式会导致暴露，但可设置 HttpOnly 为 true 保证 JS 获取不到。

## HTTP 代理主要作用

1. 负载均衡 使各台源服务器负载尽量平均
2. 保障安全 心跳机制监控后台服务器，保证集群里都是正常运行的机器
3. 缓存代理 缓存设置在代理服务上 不用到源服务器获取

![img](https://pic4.zhimg.com/80/v2-25f787baf5cbdb3bfa91fc41c5618e97_720w.jpg)

- proxy-revalidate `must-revalidate`的意思是**客户端**缓存过期就去源服务器获取，而`proxy-revalidate`则表示**代理服务器**的缓存过期后到源服务器获取。
- max-stale: 5 表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在**5 秒之内**，还是可以从代理中获取的。
- min-fresh: 5 表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在**到期前 5 秒**之前的时间拿，否则拿不到。
- only-if-cached 这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回 504

## 域名收敛和域名发散

域名收敛：就是将静态资源放在一个域名下。减少 DNS 解析的开销

域名发散：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速

## A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态

b 和 a 沟通过程双方有一份数据， b 重启之后这份数据没有了，就会发送 rst 重置。

![](https://user-images.githubusercontent.com/12479470/53468583-c28bf100-3a95-11e9-806b-62a0481ab714.png)

rst 是 TCP 首部中的 6 个标志比特之一,表示**重置**连接、复位连接

## TCP 三次握手

因为只有三次握手才能确定双方各自的发送能力和接收的能力。

第一次握手 客户端发送代表客户端具有发送能力

第二次握手 服务器接收客户端的并发送出去，代表服务端具有发送和接收的能力

第三次握手 说明客户端具有接收的能力，在第三次握手的时候可以携带数据

## 为什么要四次挥手？

TCP 是基于全双工的可信传输协议。何为全双工就是客户端与服务端建立两条通道。

通道 1: 客户端的输出连接服务端的输入

通道 2:客户端的输入连接服务端的输出。

两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。

客户端：我要关闭输入通道了。 服务端：好的，你关闭吧，我这边也关闭这个通道。

服务端：我也要关闭输入通道了。 客户端：好的你关闭吧，我也把这个通道关闭。

## 半连接队列和 SYN Flood 攻击的关系

半连接队列：当客户端发送第一次握手，服务端收到回复后，这个连接就进入半连接队列。

全连接队列：三次握手完成后，这个连接等待具体应用取走，在之前，会被放入全连接队列。

SYN Flood 攻击：伪造大量不存在的 IP 给服务器发请求，让服务器半连接队列充满，而且也让服务器不断给不存在的 IP 发消息，直到耗尽服务器的资源。

如何预防：

1. 增大半连接对列的容量
2. 设置半连接队列的重试次数，避免大量的重发。

## TCP 快速打开的原理(TFO)

采用 SYN Cookie 技术。

首轮三次正常握手，但客户端会留下第二次握手服务端发过来的一个 SYN Cookie，等再次进行三次握手的时候会利用这个 Cookie，加上 http 请求，如果验证通过，则直接获取数据。

## TCP 报文中时间戳的作用？

主要解决两大问题:

- 计算往返时延 RTT(Round-Trip Time)

- 防止序列号的回绕问题

## TCP 的流量控制？

对于发送端和接收端而言，TCP 需要把发送的数据放到**发送缓存区**, 将接收的数据放到**接收缓存区**。

而流量控制所要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。

## Nagle 算法和延迟确认？

Nagle 算法作用：避免小包的频繁发送

延迟确认作用：这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？ 选择第二种，稍稍延迟，合并后回复

## 如何理解 TCP 的 keep-alive？

轮询检测，主要是为了检测长时间的死连接。但默认设置是

1.两个小时检测一次，时间太长。时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接

## 能不能说说 TCP 的拥塞控制？

TCP 拥塞控制的经典算法: 慢启动、拥塞避免、快速重传和快速恢复。

## 如何理解 URI？

全称统一资源标识符。作用区分互联网上不同的资源。URI 有两种，分别是常见的 URL 和不常见的 URN，它通过特定命名空间中的唯一名称来标识资源。例如 urn:isbn:9780141036144

结构一般是 协议 主机 端口 路径 查询 锚点

URI 编码：只能使用 ASCII 将所有非 ASCII 码字符和界定符转成十六进制字节值，然后前面加个%，例如空格被转义成%20
