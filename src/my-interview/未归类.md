[TOC]

## requestAnimationFrame 有了解过吗？

`requestAnimationFrame`是浏览器用于定时循环操作的一个接口，类似于`setTimeout`，主要用途是按帧对网页进行重绘。对于`JS`动画，用`requestAnimationFrame` 会比 `setInterval` 效果更好。

## 平常工作中 ES6+主要用到了哪些？

`ES6`：

1. `Class`
2. 模块`import`和`export`
3. 箭头函数
4. 函数默认参数
5. `...`扩展运输符允许展开数组
6. 解构
7. 字符串模版
8. Promise
9. `let const`
10. `Proxy、Map、Set`
11. 对象属性同名能简写

`ES7`：

1. `includes`
2. 求幂运算符

`ES8`：

1. `async/await`
2. Object.values()和 Object.entries()

ES9：

1. `for...await...of`
2. `...`展开符合允许展开对象收集剩余参数
3. `Promise.finally()`
4. 正则中的四个新功能

`ES10`：

1. `flat()`

## BigInt 使用

BigInt 是一种新的数据类型，用于当整数值大于 Number 数据类型支持的范围时。这种数据类型允许我们安全地对`大整数`执行算术操作，表示高分辨率的时间戳，使用大整数 id，等等，而不需要使用库。

- 为什么需要 BigInt?

  在 JS 中，所有的数字都以双精度 64 位浮点格式表示，那这会带来什么问题呢？

  这导致 JS 中的 Number 无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS 中的 Number 类型只能安全地表示-9007199254740991(-(2^53-1))和 9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。

## 字符串 replace 方法和实现 replaceAll

如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。

```js
const str = 'dogdogdog';
const str2 = str.replace(new RegExp('dog'), 'cat');
const str3 = str.replace(new RegExp('dog', 'gm'), 'cat');
console.log(str2);

console.log(new RegExp('dog', 'g'));
```

## Math 对象方法和生成随机数的方式

| 方法 | 描述 |
| :-- | :-- |
| [ceil(x)](https://www.runoob.com/jsref/jsref-ceil.html) | 对数进行上舍入，即向上取整。 |
| [floor(x)](https://www.runoob.com/jsref/jsref-floor.html) | 对 x 进行下舍入，即向下取整。 |
| [round(x)](https://www.runoob.com/jsref/jsref-round.html) | 四舍五入。 |
| [random()](https://www.runoob.com/jsref/jsref-random.html) | 返回 0 ~ 1 之间的随机数，包含 0 不包含 1。 |

```js
Math.ceil(Math.random() * 10); // 获取从 1 到 10 的随机整数，取 0 的概率极小。

Math.round(Math.random()); // 可均衡获取 0 到 1 的随机整数。

Math.floor(Math.random() * 10); // 可均衡获取 0 到 9 的随机整数。

Math.round(Math.random() * 10); // 基本均衡获取 0 到 10 的随机整数，其中获取最小值 0 和最大值 10 的几率少一半。
```

## cookie 和 session 的区别

## 虚拟滚动

## worker 有哪几种

## 客户端渲染和服务端渲染

## animation 实现原理

## webpack 的配置过哪些

## Redux 相关整体流程以及 Provider 底层是如何实现的？

## Promise.all 中如何失败也执行.then 方法

核心内容是 map 方法，map 的每一项都是 promise，catch 方法返回值会被 promise.reslove()包裹，这样传进 promise.all 的数据都是 resolved 状态的。

```js
Promise.all(
  [
    Promise.reject({ code: 500, msg: '服务异常' }),
    Promise.resolve({ code: 200, list: [] }),
    Promise.resolve({ code: 200, list: [] }),
  ].map((p) => p.catch((e) => e)),
)
  .then((res) => {
    console.log('res=>', res);
  })
  .catch((error) => {
    console.log('error=>', error);
  });
// [ { code: 500, msg: '服务异常' },{ code: 200, list: [] },{ code: 200, list: [] } ]
```

## 数组实例操作的几种方式

不修改原数组的

| 类别 | concat | every | filter | find / findIndex | flat | forEach | includes | indexof | join |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 返回值 | 合并两个或多个数组 | 布尔值，全部通过 | 过滤 | 查找项 / 索引 | 指定深度递归展平 | 遍历 | 包含 | 元素 index | 所有元素拼接成字符串按照- |  |

修改原数组的 | 类别 | push | pop | unshift | shift | | ------ | -------------- | ------------------ | ---------------------- | ------------------ | | 返回值 | 新数组的新长度 | 末尾弹出，弹出的项 | 前面加一项，新数组长度 | 头部弹出，弹出的项 |

## webpack 如何自适应手机端

使用 postcss-px2rem

## redux 触发 action 如何指定 reducers

## 你的优点

## 你觉得你最擅长什么？

## 你的缺点，后续如何改进，以及一些成效

## JS 浮点数的问题，你是如何避免的

可能会通过一些库来去实现

## 性能 3D 词云

## Three.js 的坐标系和 canvas 的坐标系的区别

three 采用右手坐标系，场景，相机，渲染器

材质，纹理贴图，加载外部 3D 模型，如 obj，json，gltf 等格式文件。

canvas 通过 js 调用上下文对象进行绘制，通过 getContext 方式，可指定参数为 2d 或 webgl

## 技术深度以及之前是否有对源码有一些研究

## svg 和 canvas 的区别？以及你用过哪些？

Canvas 是 HTML5 的画布元素，在使用 Canvas 时，需要用到 Canvas 的上下文，可以用 2D 上下文绘制二维的图像，也可以使用 3D 上下文绘制三维的图像，其中 3D 上下文就是指 WebGL。

## 使用 defineproperty 实现一个双向绑定

是利用了 Object.defineProperty()这个方法重新定义了对象获取属性值 get 和设置属性值 set 的操作来实现的。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <span id="box">
      <h1 id="text"></h1>
      <input type="text" id="input" oninput="inputChange(event)" />
      <button id="button" onclick="clickChange()">Click me</button>
    </span>
    <script>
      const input = document.getElementById('input');
      const text = document.getElementById('text');
      const button = document.getElementById('button');
      const data = {
        value: '',
      };

      function defineProperty(obj, attr) {
        let val;

        Object.defineProperty(obj, attr, {
          set(newValue) {
            console.log('set');
            if (val === newValue) {
              return;
            }
            val = newValue;
            input.value = newValue;
            text.innerHTML = newValue;
          },

          get() {
            console.log('get');
            return val;
          },
        });
      }

      defineProperty(data, 'value');

      function inputChange(event) {
        data.value = event.target.value;
      }

      function clickChange() {
        data.value = 'hello';
      }
    </script>
  </body>
</html>
```

## 使用 Proxy 实现一个双向绑定

## 实现双向绑定 Proxy 比 defineproperty 优劣如何？

1. Object.definedProperty 的作用是劫持一个对象的属性，劫持属性的 getter 和 setter 方法，在对象的属性发生变化时进行特定的操作。而 Proxy 劫持的是整个对象。
2. Proxy 会返回一个代理对象，我们只需要操作新对象即可，而 `Object.defineProperty` 只能遍历对象属性直接修改。
3. Object.definedProperty 不支持数组，更准确的说是不支持数组的各种 API，因为如果仅仅考虑 arry[i] = value 这种情况，是可以劫持的，但是这种劫持意义不大。而 Proxy 可以支持数组的各种 API。
4. 尽管 Object.defineProperty 有诸多缺陷，但是其兼容性要好于 Proxy.

## 实现一个 EventEmitter 类

```js
class EventEmitter {
  constructor() {
    this.handler = {};
  }

  on(eventName, callback) {
    if (!this.handles) {
      this.handles = {};
    }
    if (!this.handles[eventName]) {
      this.handles[eventName] = [];
    }
    this.handles[eventName].push(callback);
  }

  emit(eventName, ...arg) {
    if (this.handles[eventName]) {
      for (var i = 0; i < this.handles[eventName].length; i++) {
        this.handles[eventName][i](...arg);
      }
    }
  }
}
```

## cookie 的一些使用

## flex 整体说一下

有主轴和交叉轴

在容器上常用的有

1. flex-direction 决定主轴的方向。

2. justify-content 属性定义了项目在主轴上的对齐方式。

3. align-items 属性定义项目在交叉轴上如何对齐。

在项目上常用的有

1. order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。
2. flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。
3. flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。
4. flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。
5. flex 属性是 flex-grow，flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。

## websocket 连接

与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

客户端发送 GET 请求，并携带 Upgrade: websocket 和 Connection: Upgrade 代表发起的是 WS 协议，并携带一个 Sec-WebSocket-Key 是由浏览器随机生成的，提供基本的防护，防止恶意或无意的连接。

服务端给客户端 101 表示已经理解了客户端的请求，并通过 Upgrade: websocket 通知客户端采用不同的协议完成这个请求。

Sec-WebSocket-Accept 是经过服务器确认，并且加密后的 Sec-WebSocket-Key，这个换算只能带来基本的保障。

## 虚拟滚动

## worker 有哪几种？ server worker web worker

## 客户端渲染和服务端渲染

客户端渲染：html 仅作为静态文件，解析完 js 之后进行 dom 修改

history 模式下 try_files $uri $uri/ index.html;

服务端渲染：在特定区域已经用数据填充，客户端只进行解析 html，有利于 SEO，因为不仅仅对于其中的 head 头还有其中的内容。

同构：是客户端渲染和服务端渲染的整合，代码总共执行两次，在客户端可进行交互

## Echarts 你是怎么封装的，有性能卡顿问题吗？echarts 卸载时需要注意的点

按需加载，使用 import 方法的形式。

采用 immutable 持久化数据结构，深层次赋值，返回一个新的 options。

## animation 实现原理

## React 中 key 的作用

key 帮助 React 识别哪些元素改变了

如果没有设置数组里的 key，在一个个手动创建时会提升创建速度，会就地复用。

但常用会是通过 map 方法，如果没添加 key 的话，会默认使用数组的 index 作为 key，这样如果 unshift 一项，则会导致后面两项重新创建并渲染，不然的话是可以复用的。

## React Fiber

与 Generator 中的协程概念类似，Generator 是交出函数的执行权，而 fiber 是交出浏览器的控制权，比如当前有一个 react 渲染任务，同时有一个事件响应任务，或手势操作任务，这个任务比 react 的渲染任务优先级更高，则 react 就会交出浏览器控制权，等到浏览器空闲后再继续。

没有使用 Generator 语法层次的让出机制，而是通过 Fiber 这个执行单位实现了自己的调度让出机制。

## 代码分割是怎么个加载形式

三方库按需加载可以用 Babel 的插件 babel-plugin-import

## Map Set weakMap weakSet 的区别

Set 是 ES6 新增的一种新的数据结构，类似数组，其成员是唯一且无序的，没有重复的值。

```js
new Set([iterable]);
// add delete has clear 清空
```

WeakSet 允许你将弱引用对象储存在一个集合中，只能储存对象引用，不能存放值，而 Set 对象都可以

WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素。

Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键

```js
// 任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数
const set = new Set([
  ['foo', 1],
  ['bar', 2],
]);
const m1 = new Map(set);
m1.get('foo'); // 1

const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz'); // 3
```

WeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。

注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。

## ===和 Object.is 的区别

| 数据  | Object.is | ===  | Set  | Map  |
| :---- | --------- | ---- | ---- | ---- |
| NaN   | 相等      | 不等 | 相等 | 相等 |
| +0 -0 | 不等      | 相等 | 相等 | 相等 |

## WebP 图片优势

更优的图像压缩算法提供高质量的图片，更小的图片体积。

问题有 平台兼容性问题以及其解码时间要更长，但体积缩小了，利大于弊。

## scrollTop 和 offsetTop 的位置

![img](https://user-gold-cdn.xitu.io/2019/4/2/169dd79558ce2af9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

![img](https://img-blog.csdn.net/20180104085724397)

## 重绘和重排具体，触发回流的方式？触发回流的次数

## 前端微服务如何兼容老系统中的新系统开发

| 方案 | 描述 | 优点 | 缺点 |
| --- | --- | --- | --- |
| Nginx 路由转发 | 通过 Nginx 配置反向代理来实现不同路径映射到不同应用，例如 www.abc.com/app1 对应 app1，www.abc.com/app2 对应 app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置。 | 简单，快速，易配置 | 在切换应用时会触发浏览器刷新，影响体验 |
| iframe 嵌套 | 父应用单独是一个页面，每个子应用嵌套一个 iframe，父子通信可采用 postMessage 或者 contentWindow 方式 | 实现简单，子应用之间自带沙箱，天然隔离，互不影响 | iframe 的样式显示、兼容性等都具有局限性；太过简单而显得 low |
| Web Components | 每个子应用需要采用纯 Web Components 技术编写组件，是一套全新的开发模式 | 每个子应用拥有独立的 script 和 css，也可单独部署 | 对于历史系统改造成本高，子应用通信较为复杂易踩坑 |
| 组合式应用路由分发 | 每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载，启动，卸载，以及通信机制 | 纯前端改造，体验良好，可无感知切换，子应用相互隔离 | 需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点 |

## 你觉得项目有哪些不足

## 数据 mock 方案

## 性能优化详细

## 前端组件库建设

## window 的 onload 事件和 domcontentloaded 谁先谁后？

## 知道什么是事件委托吗

## 请描述一下 DNS 解析的具体过程

## websocket 断线问题

## react 内部的 diff 算法是怎么样的？带来了什么？为什么要使用？

## toB 和 toC 的区别

## 页面无限滚动加载优化

## webp 具体兼容方式以及判断

1. 可以采用 picture 标签的方式加载，可包含多个 source 和一个 img 为不同的设备场景提供图像版本，可在 source 上设置 media 或 type。

## 遍历一个 DOM 树

```js
// 借用一下前面的
function traversal(node) {
  const stack = [];
  stack.push(node);
  while (stack.length > 0) {
    const elem = stack.pop();
    if (elem && elem.nodeType === 1) {
      console.log('tagName: ', elem.tagName);
      const children = elem.children;
      for (let i = 0, len = children.length; i < len; i++) {
        stack.push(children[i]);
      }
    }
  }
}

traversal(document.body);
```

## 在 web 安全方面，有什么实际的经验？

1. 跨域
2. 缓存
3. cookie
4. http 协议
5. 正则
6. JS 的一些特性
7. DOM
8. 事件
9. ajax
10. 优化
11. 安全
12. 项目经验

- 有没有做过性能优化
- 如何定位性能问题
- 如何解决的
- loader
- plugin
- Tree Shaking
- 代码分割
- 打包优化技巧
- TCP, UDP 的区别， 最佳场景
- 为什么说 HTTPS 是安全的
- Tree,
- BFS
- DFS
- 递归
- 动态规划
- React diff
- 虚拟 dom
- react 受控 非受控组件
- 错误监控， 收集，分析
- redux - 是怎么实现的， 实现过程
- 为什么生成了 CSSOM 树这样的结构
