[TOC]

## 在项目中如何把 http 的请求换成 https

由于我在项目中是会对`axios`做一层封装，所以每次请求的域名也是写在配置文件中，有一个`baseURL`字段专门用于存储它，所以只要改这个字段就可以达到替换所有请求`http`为`https`了。

也可以利用`meta`标签把`http`请求换为`https`:

```html
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" />
```

## 浏览器简单请求和非简单请求

- 简单请求
  - 请求方法为 GET、POST 或者 HEAD
  - 请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`)
- 除了上述情况就非简单请求

## 你们的 token 一般是存放在哪里的

`Token`其实就是**访问资源的凭证**。

一般是用户通过用户名和密码登录成功之后，服务器将登陆凭证做数字签名，加密之后得到的字符串作为`token`。

它在用户登录成功之后会返回给客户端，客户端主要有这么几种存储方式

2. 存储在`cookie`中，让它自动发送
3. 拿到之后存储在`localStorage`中，每次调用接口的时候放在`HTTP`请求头里的 Authorization

## 介绍下如何实现 token 加密

1. 需要一个 secret（随机数）
2. 后端利用 secret（随机数） 和加密算法(如：HMAC-SHA256)对 payload(如账号密码)生成一个字符串(token)，返回前端
3. 前端每次 request 在 header 中带上 token
4. 后端用同样的算法解密

## 常见 HTTP 状态码有哪些

HTTP 状态码的英文为 HTTP Status Code。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。

**1xx 表示是临时响应，代表着请求已经被接受，但需要继续处理。**

100 Continue 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。

101 Switching Protocols。服务器将遵从客户的请求转换到另外一种协议， 在`HTTP`升级为`WebSocket`的时会发送

**2xx 表示请求已被成功接收、理解、接受。**

200 OK 是见得最多的成功状态码。通常在响应体中放有数据。

204 No Content 含义与 200 相同，但响应头后没有 body 数据。

206 Partial Content 表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段`Content-Range`。

**3xx 重定向状态，资源位置发生变动，需要重新请求。**

301 Moved Permanently 即永久重定向，比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回`301`，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。不会让网站的排名因为网址变更而收到丝毫影响。

302 Found 即临时重定向，不会做缓存优化，会降低网站的排名。

304 Not Modified: 当协商缓存命中时会返回这个状态码。

**4xx 客户端错误--请求有语法错误或请求无法实现。**

400 Bad Request: 服务器不理解请求的语法，常见于客户端传参错误

401 Unauthorized：请求未经授权，常见于客户端未登录

403 Forbidden: 服务器禁止访问，比如法律禁止、信息敏感，常见于客户端权限不足

404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。

405 Method Not Allowed: 请求方法不被服务器端允许。

406 Not Acceptable: 资源无法满足客户端的条件。

408 Request Timeout: 服务器等待了太长时间。

409 Conflict: 多个请求发生了冲突。

413 Request Entity Too Large: 请求体的数据过大。

414 Request-URI Too Long: 请求行里的 URI 太大。

429 Too Many Request: 客户端发送的请求过多。

431 Request Header Fields Too Large 请求头的字段内容太大。

**5xx 服务器端错误--服务器未能实现合法的请求。**

500 Internal Server Error: 仅仅告诉你服务器出错了，所请求的服务器遇到意外的情况并阻止其执行请求。

501 Not Implemented: 表示客户端请求的功能还不支持。

502 Bad Gateway: 作为网关或者代理服务器尝试执行请求时，从上游服务器接收到无效的响应。

503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务，通常是暂时状态。

504 Gateway Timeout 表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应。

## http 请求报文

一个 HTTP 请求报文由请求行（request line）、请求头（header）、空行和请求数据 4 个部分组成，下图给出了请求报文的一般格式。

- **请求行**：GET /index.html HTTP/1.1。
- **请求头**: 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：
- User-Agent：产生请求的浏览器类型。
- Accept：客户端可识别的内容类型列表。
- Host：请求的主机名，允许多个域名同处一个 IP 地址，即虚拟主机。
- Content-Type：请求体的 MIME 类型 （用于 POST 和 PUT 请求中）。如：Content-Type: application/x-www-form-urlencoded
- **空行**

最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。

- **请求数据**

请求数据不在 GET 方法中使用，而是在 POST 方法中使用。POST 方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length。

## 讲讲网络 OSI 七层模型，TCP/IP 和 HTTP 分别位于哪一层

![alt](https://user-gold-cdn.xitu.io/2020/1/28/16fec363208256b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

| 模型       | 概述                                                   | 单位   |
| ---------- | ------------------------------------------------------ | ------ |
| 物理层     | 网络连接介质，如网线、光缆，数据在其中以比特为单位传输 | bit    |
| 数据链路层 | 数据链路层将比特封装成数据帧并传递                     | 帧     |
| 网络层     | 定义 IP 地址，定义路由功能，建立主机到主机的通信       | 数据包 |
| 传输层     | 负责将数据进行可靠或者不可靠传递，建立端口到端口的通信 | 数据段 |
| 会话层     | 控制应用程序之间会话能力，区分不同的进程               |        |
| 表示层     | 数据格式标识，基本压缩加密功能                         |        |
| 应用层     | 各种应用软件                                           |        |

## 接口如何防刷

防刷一般分两种：

- 总调用次数受限制。这个一般是在后端做限制，单位时间内最多可调用次数。
- 同一客户端次数限制。这个前端的一般使用是给接口调用加锁，在返回结果或者一定时间之后解锁。也可使用人机验证，验证码，短信码。滑动图片等形式

## http1.0、1.1、2.0、3.0 协议的区别？

- http/1 :

  1. 默认不支持长连接，需要设置 keep-alive 参数指定
  2. 强缓存 expired、协商缓存 last-modified \ if-modified-since 有一定的缺陷

- http 1.1 :

  1. 默认长连接(keep-alive)，http 请求可以复用 TCP 连接，但是同一时间只能对应一个 http 请求(http 请求在一个 TCP 中是串行的)
  2. 增加了强缓存 cache-control、协商缓存 etag \ if-none-match 是对 http/1 缓存的优化

- http/2 :

  1. 多路复用，一个 TCP 中多个 http 请求是并行的
  2. 二进制格式编码传输，头信息和数据体都是二进制
  3. header 压缩
  4. 服务端主动推送

![img](http://47.98.159.95/my_blog/http/008.png)

- http/3：

  尽管 HTTP/2 解决了很多 1.1 的问题，但 HTTP/2 仍然存在一些缺陷，这些缺陷并不是来自于 HTTP/2 协议本身，而是来源于底层的 TCP 协议，我们知道 TCP 链接是可靠的连接，如果出现了丢包，那么整个连接都要等待重传，HTTP/1.1 可以同时使用 6 个 TCP 连接，一个阻塞另外五个还能工作，但 HTTP/2 只有一个 TCP 连接，阻塞的问题便被放大了。

  由于 TCP 协议已经被广泛使用，我们很难直接修改 TCP 协议，基于此，HTTP/3 选择了一个折衷的方法——UDP 协议，一个基于 UDP 协议的 QUIC 协议上实现

  1. 多路复用
  2. 0-RTT 类似 TCP 快速打开的技术，缓存当前会话的上下文
  3. 流量控制、丢包重传

## 简单讲解一下 http2 的多路复用

HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免队头阻塞问题。

由于是不按顺序发送的，同一个 TCP 连接里的数据包可能属于不同的回应，所以引入了数据流的概念，每个数据流都有独一无二的 ID，并且客户端发出的 ID 为奇数，服务端发出的为偶数。这里需要注意的一点是当 ID 到达上限会重开一个 TCP 连接。 每个数据流是由多个数据帧组成的。可以指定其所属数据流的优先级，让服务器优先响应。

## 为什么 HTTP1.1 不能实现多路复用

HTTP/1.1 不是二进制传输，而是通过文本进行传输。并且没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。

## 对于定长和不定长的数据，HTTP 是怎么传输的？

- **定长包体**

  对于定长包体而言，发送端在传输的时候一般会带上 `Content-Length`, 来指明包体的长度。当取值小时会截取，当取值大时会失败。对于 http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败。

- **不定长包体**

  采用

  ```text
  Transfer-Encoding: chunked
  ```

  表示分块传输数据，设置这个字段后会自动产生两个效果:

  - Content-Length 字段会被忽略
  - 基于长连接持续推送动态内容

## Http 与 Https 的区别

- HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头
- HTTP 是不安全的，而 HTTPS 是安全的
- HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443
- 在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 的安全传输机制工作在传输层
- HTTP 无法加密，而 HTTPS 对传输的数据进行加密
- HTTP 无需证书，而 HTTPS 需要 CA 机构颁发的 SSL 证书

## 介绍 HTTPS 握手过程

https 是使用 SSL/TLS 的 HTTP 通信。

**TLS1.0 = SSL3.1** 其安全传输机制工作在传输层 （TLS1.3 在 TLS1.2 的基础上废除了大量的算法，提升了安全性）

`对称加密`是最简单的方式，指的是`加密`和`解密`用的是**同样的密钥**。

而对于`非对称加密`，如果有 A、 B 两把密钥，如果用 A 加密过的数据包只能用 B 解密，反之，如果用 B 加密过的数据包只能用 A 解密。

采用对称加密和非对称加密结合的方式，本质上是**防止了私钥加密的数据外传**。单独使用**非对称加密**，最大的漏洞在于服务器传数据给浏览器只能用`私钥`加密，这是危险产生的根源。

1. 客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello 请求。给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
2. 服务器收到客户端请求后，向客户端发出回应，这叫做 SeverHello。确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
3. 客户端收到服务器回应以后，确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器。
4. 服务器使用自己的私钥，解密出客户端发来的随机数（即 Premaster secret）。
5. 客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。

[![img](http://47.98.159.95/my_blog/http/010.jpg)](http://47.98.159.95/my_blog/http/010.jpg)

## HTTPS 握手过程中，客户端如何验证证书的合法性

（1）首先第一步是浏览器校验证书的有效期，以及是否被吊销(**_证书撤销名单_**, **_在线证书状态协议_**)，还有证书的网站域名和证书的颁发域名是否是一致的。

（2）第二步浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者做比对，校验是否为合法机构颁发。

（3）如果是合法机构颁发， 那么浏览器就会从操作系统中取出本地的这个机构的公钥，用这个公钥解密出服务器发来证书的签名。 接下来用相同的算法， 生成一个自己的证书签名，和解密出的签名做对比。

## 介绍下 HTTPS 中间人攻击

1. 服务器向客户端发送公钥。
2. 攻击者截获公钥，保留在自己手上。
3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
4. 客户端收到伪造的公钥后，生成加密 hash 值发给服务器。
5. 攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。
6. 同时生成假的加密 hash 值，发给服务器。
7. 服务器用私钥解密获得假秘钥。服务器用假秘钥加密传输信息

## RESTful 是什么

REST 指的是一组架构约束条件和原则。我理解是表现层状态转化。

我们把"资源"具体呈现出来的形式，叫做它的"表现层"，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转化"（State Transfer）。而这种转化是建立在表现层之上的，所以就是"表现层状态转化"。

1. 每一个 URI 代表一种资源；
2. 客户端和服务器之间，传递这种资源的某种表现层；
3. 客户端通过四个 HTTP 动词，对服务器端资源进行操作，实现"表现层状态转化"。（GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源。)

## 如何理解 HTTP 的请求方法？

**有哪些请求方法？**

`http/1.1`规定了以下请求方法(注意，都是大写):

- GET: 通常用来获取资源
- POST: 提交数据，即上传数据
- PUT: 修改数据
- DELETE: 删除资源
- OPTIONS: 列出可对资源实行的请求方法，用来跨域请求

**GET 和 POST 有什么区别？**

首先最直观的是语义上的区别。

而后又有这样一些具体的差别:

- 从**缓存**的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。

- 从**编码**的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。

- 从**参数**的角度，GET 一般放在 URL 中，其长度一般有限制，是各家浏览器设置的限制。且有历史记录，POST 放在请求体中，其参数长度可以非常大，更适合传输敏感信息。

- 从**幂等性**的角度，`GET`是**幂等**的，而`POST`不是。

  > 幂等性，指的是对某一资源进行一次或多次请求都具有相同的副作用。例如搜索就是一个幂等的操作，而删除、新增则不是一个幂等操作。

- 从**TCP**的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(**火狐**浏览器除外，它的 POST 请求只发一个 TCP 包)

## 对 Content 系列字段了解多少？

对于`Content`系列字段的介绍分为四个部分: **数据格式**、**压缩方式**、**支持语言**和**字符集**。

- 数据格式

  发送端 Content-type 和接受端 Accept 字段

  具体而言，这两个字段的取值可以分为下面几类:

  - text： text/html, text/plain, text/css 等

- image: image/gif, image/jpeg, image/png 等

  - audio/video: audio/mpeg, video/mp4 等

- application: application/json, application/javascript, application/pdf, application/octet-stream

* 压缩方式

  发送端 Content-Encoding 和接收端 Accept-Encoding

  - gzip: 当今最流行的压缩格式

  - deflate: 另外一种著名的压缩格式

  - br: 一种专门为 HTTP 发明的压缩算法

    ```
    // 发送端
    Content-Encoding: gzip
    // 接收端
    Accept-Encoding: gizp
    ```

- 支持语言

  发送端 Content-Language 接受端 Accept-Language

  ```
  // 发送端
  Content-Language: zh-CN, zh, en
  // 接收端
  Accept-Language: zh-CN, zh, en
  ```

* 字符集

  发送端放置在 Content-Type 中 以 charset 属性指定 接受端是 Accept-Charset

  ```
  // 发送端
  Content-Type: text/html; charset=utf-8
  // 接收端
  Accept-Charset: charset=utf-8
  ```

[![img](http://47.98.159.95/my_blog/http/005.png)](http://47.98.159.95/my_blog/http/005.png)

## 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？

**HTTP 特点**

HTTP 的特点概括如下:

1. 灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。
2. 可靠传输。HTTP 基于 TCP/IP，是可靠传输。
3. 请求-应答。也就是`一发一收`、`有来有回`， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演**请求方**的角色。
4. 无状态。这里的状态是指**通信过程的上下文信息**，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。

**HTTP 缺点**

- **无状态**

可以说是优点也可以说是缺点。当一些应用仅仅获取一些资源，无状态可以减少网络开销。但是对于长连接的场景来说，意味着每次传输都要携带可能重复的数据证明客户端的身份。Cookie 就是最开始为了解决这个问题而生。

- **明文传输**

即协议里的报文不使用二进制数据，而是文本形式。

这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。`WIFI陷阱`就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。

- **队头阻塞问题**

当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的**队头阻塞**问题。

## 如何解决 HTTP 的队头阻塞问题？

**什么是 HTTP 队头阻塞？**

从前面的小节可以知道，HTTP 传输是基于`请求-应答`的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的`HTTP队头阻塞`问题。

**并发连接**

对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在 RFC2616 规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。

但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。

**域名分片**

一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。

比如 content1.sanyuan.com 、content2.sanyuan.com。

这样一个`sanyuan.com`域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

## HTTP 如何处理大文件的传输？

对于几百 M 甚至上 G 的大文件来说，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，HTTP 针对这一场景，采取了`范围请求`的解决方案，允许客户端仅仅请求一个资源的一部分。

**如何支持**

当然，前提是服务器要支持**范围请求**，要支持这个功能，就必须加上这样一个响应头:

```text
Accept-Ranges: none
```

用来告知客户端这边是支持范围请求的。

**Range 字段拆解**

而对于客户端而言，它需要指定请求哪一部分，通过`Range`这个请求头字段确定，格式为`bytes=x-y`。接下来就来讨论一下这个 Range 的书写格式:

- **0-499**表示从开始到第 499 个字节。
- **500**- 表示从第 500 字节到文件终点。
- **-100**表示文件的最后 100 个字节。

服务器收到请求之后，首先验证范围**是否合法**，如果越界了那么返回`416`错误码，否则读取相应片段，返回`206`状态码。

同时，服务器需要添加`Content-Range`字段，这个字段的格式根据请求头中`Range`字段的不同而有所差异。

具体来说，请求`单段数据`和请求`多段数据`，响应头是不一样的。

举个例子:

```js
// 单段数据
Range: bytes = 0 - 9;
// 多段数据
Range: (bytes = 0 - 9), 30 - 39;
```

接下来我们就分别来讨论着两种情况。

**单段数据**

对于`单段数据`的请求，返回的响应如下:

```text
HTTP/1.1 206 Partial Content
Content-Length: 10
Accept-Ranges: bytes
Content-Range: bytes 0-9/100

i am xxxxx
```

值得注意的是`Content-Range`字段，`0-9`表示请求的返回，`100`表示资源的总大小，很好理解。

**多段数据**

接下来我们看看多段请求的情况。得到的响应会是下面这个形式:

```text
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000010101
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes


--00000010101
Content-Type: text/plain
Content-Range: bytes 0-9/96

i am xxxxx
--00000010101
Content-Type: text/plain
Content-Range: bytes 20-29/96

eex jspy e
--00000010101--
```

这个时候出现了一个非常关键的字段`Content-Type: multipart/byteranges;boundary=00000010101`，它代表了信息量是这样的:

- 请求一定是多段数据请求
- 响应体中的分隔符是 00000010101

因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上`--`表示结束。

## 对 Cookie 了解多少？

- 作用： 为了状态信息保留，由客户端发起请求时携带，服务端可用 Set-Cookie 字段写入客户端

- 属性

  1. 生命周期: Cookie 的有效期可以通过**Expires**和**Max-Age**两个属性来设置。

     - **Expires**即`过期时间`
     - **Max-Age**用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。

     若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。

  2. 作用域：关于作用域也有两个属性: **Domain**和**path**, 给 **Cookie** 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说，`/`表示域名下的任意路径都允许使用 Cookie。

  3. 安全相关：如果 cookie 字段带上`HttpOnly`，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。

     相应的，对于 CSRF 攻击的预防，也有`SameSite`属性。

     `SameSite`可以设置为三个值，`Strict`、`Lax`和`None`。

     **a.** 在`Strict`模式下，浏览器完全禁止第三方请求携带 Cookie。比如请求`sanyuan.com`网站只能在`sanyuan.com`域名当中请求才能携带 Cookie，在其他网站请求都不能。

     **b.** 在`Lax`模式，就宽松一点了，但是只能在 `get 方法提交表单`况或者`a 标签发送 get 请求`的情况下可以携带 Cookie，其他情况均不能。

     **c.** 在`None`模式下，也就是默认模式，请求会自动携带上 Cookie。

- 缺点：

  1. 容量缺陷。Cookie 的体积上限只有`4KB`，只能用来存储少量的信息。
  2. 性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过`Domain`和`Path`指定**作用域**来解决。
  3. 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在`HttpOnly`为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

## HTTP 代理主要作用

**功能**

1. **负载均衡**。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括**随机算法**、**轮询**、**一致性 hash**、**LRU**`(最近最少使用)`等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。
2. **保障安全**。利用**心跳**机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。
3. **缓存代理**。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。

## 如何理解 HTTP 缓存及缓存代理？

![img](https://pic4.zhimg.com/80/v2-25f787baf5cbdb3bfa91fc41c5618e97_720w.jpg)

- proxy-revalidate `must-revalidate`的意思是**客户端**缓存过期就去源服务器获取，而`proxy-revalidate`则表示**代理服务器**的缓存过期后到源服务器获取。
- max-stale: 5   表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在**5 秒之内**，还是可以从代理中获取的。
- min-fresh: 5   表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在**到期前 5 秒**之前的时间拿，否则拿不到。
- only-if-cached   这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回504



## 域名收敛

PC 时代为了突破浏览器的域名并发限制。有了域名发散。浏览器有并发限制，是为了防止 DDOS 攻击。域名收敛：就是将静态资源放在一个域名下。减少 DNS 解析的开销。域名发散：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。域名发散是 pc 端为了利用浏览器的多线程并行下载能力。而域名收敛多用与移动端，提高性能，因为 dns 解析是是从后向前迭代解析，如果域名过多性能会下降，增加 DNS 的解析开销。

## TCP 和 UDP 的区别？

首先概括一下基本的区别:

TCP 是一个面向连接的、可靠的、基于字节流的传输层协议。

而 UDP 是一个面向无连接的传输层协议。也就是说不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且 UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。UDP 相比 TCP 简单的多，不需要建立连接，不需要验证数据报文，不需要流量控制，只会把想发的数据报文一股脑的丢给对端。虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为 适用场景 直播，王者荣耀

具体来分析，和 `UDP` 相比，`TCP` 有三大核心特性:

1. **面向连接**。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。
2. **可靠性**。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是**有状态**。当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是**可控制**。相应的，UDP 就是`无状态`, `不可控`的。
3. **面向字节流**。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。
4. 建立连接需要三次握手，断开连接需要四次握手
5. 滑动窗口解决了数据的丢包、顺序不对和流量控制问题
6. 拥塞窗口实现了对流量的控制，保证在全天候环境下最优的传递数据

## A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态

b 和 a 沟通过程双方有一份数据， b 重启之后这份数据没有了，就会发送 rst 重置。

![](https://user-images.githubusercontent.com/12479470/53468583-c28bf100-3a95-11e9-806b-62a0481ab714.png)

rst 是 TCP 首部中的 6 个标志比特之一,表示**重置**连接、复位连接

## TCP 三次握手而不是两次四次

三次握手需要确认双方的两样能力: `发送的能力`和`接收的能力`。于是便会有下面的三次握手的过程:

根本原因: 无法确认客户端的接收能力。

如果两次连接上，客户端此时发送一个包，发送包滞留在当前网络，然后与此同时客户端关机了断开连接了，然后这个时候发送包到达了服务端，建立了连接，但客户端已经断开。所以会带来连接资源的浪费。

[![img](http://47.98.159.95/my_blog/tcp/001.jpg)](http://47.98.159.95/my_blog/tcp/001.jpg)

**为什么不是四次？**

三次握手的目的是确认双方`发送`和`接收`的能力，那四次握手可以嘛？

三次就足够了，再多用处就不大了

**三次握手过程中可以携带数据么？**

第三次握手的时候，可以携带。前两次握手不能携带数据。

如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的**时间**和**内存空间**去处理这些数据，增大了服务器被攻击的风险。

第三次握手的时候，客户端已经处于`ESTABLISHED`状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。



## 为什么要四次挥手？

TCP 是基于全双工的可信传输协议。何为全双工就是客户端与服务端建立两条通道。

通道 1: 客户端的输出连接服务端的输入

通道 2:客户端的输入连接服务端的输出。

两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。



客户端：我要关闭输入通道了。     服务端：好的，你关闭吧，我这边也关闭这个通道。

服务端：我也要关闭输入通道了。  客户端：好的你关闭吧，我也把这个通道关闭。



## 半连接队列和 SYN Flood 攻击的关系

半连接队列：当客户端发送第一次握手，服务端收到回复后，这个连接就进入半连接队列。

全连接队列：三次握手完成后，这个连接等待具体应用取走，在之前，会被放入全连接队列。

SYN Flood攻击：伪造大量不存在的IP给服务器发请求，让服务器半连接队列充满，而且也让服务器不断给不存在的IP发消息，直到耗尽服务器的资源。

如何预防：

1. 增大半连接对列的容量
2. 设置半连接队列的重试次数，避免大量的重发。



## TCP 快速打开的原理(TFO)

采用 SYN Cookie 技术。

首轮三次正常握手，但客户端会留下第二次握手服务端发过来的一个 SYN Cookie，等再次进行三次握手的时候会利用这个Cookie，加上http请求，如果验证通过，则直接获取数据。



## TCP 报文中时间戳的作用？

主要解决两大问题:

- 计算往返时延 RTT(Round-Trip Time)

- 防止序列号的回绕问题

  

## TCP 的流量控制？

对于发送端和接收端而言，TCP 需要把发送的数据放到**发送缓存区**, 将接收的数据放到**接收缓存区**。

而流量控制所要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。



## Nagle 算法和延迟确认？

Nagle 算法作用：避免小包的频繁发送

延迟确认作用：这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？ 选择第二种，稍稍延迟，合并后回复



## 如何理解 TCP 的 keep-alive？

轮询检测，主要是为了检测长时间的死连接。但默认设置是

1.两个小时检测一次，时间太长。时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接



## 能不能说说 TCP 的拥塞控制？

TCP 拥塞控制的经典算法: 慢启动、拥塞避免、快速重传和快速恢复。



## 如何理解 URI？

全称统一资源标识符。作用区分互联网上不同的资源。URI有两种，分别是常见的URL和不常见的URN，它通过特定命名空间中的唯一名称来标识资源。例如 urn:isbn:9780141036144

结构一般是 协议 主机 端口 路径 查询 锚点

URI编码：只能使用ASCII    将所有非ASCII码字符和界定符转成十六进制字节值，然后前面加个%，例如空格被转义成%20



## HTTP 中如何处理表单数据的提交？

- application/x-www-form-urlencoded

  - 其中的数据会被编码成以`&`分隔的键值对

  - 字符以**URL 编码方式**编码。

    ```js
    // 转换过程: {a: 1, b: 2} -> a=1&b=2 -> 如下(最终形式)
    'a%3D1%26b%3D2';
    ```

- multipart/form-data

  - 请求头中Content-Type字段包含boundary，且其值有浏览器默认指定。

  - 数据会分为多个部分

在实际的场景中，对于图片等文件的上传，基本采用`multipart/form-data`而不用`application/x-www-form-urlencoded`，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间

