[TOC]

## 闭包

定义： 有权访问另外一个函数作用域中的变量的函数，存在意义在于间接访问函数内部的变量。但也因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用。

```js
var f3;
function f1() {
  var a = 2;
  f3 = function () {
    console.log(a);
  };
}
f1();
f3();
```

闭包经典面试题

原因： 由于 setTimeout 是宏任务，所以每次循环时会新起一个任务队列，等外面的 for 循环完成后，再依次执行，此时，i 已经成为了 6

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, 0);
}
```

1. 采用立即执行函数

   ```js
   for (var i = 1; i <= 5; i++) {
     (function (j) {
       setTimeout(function timer() {
         console.log(j);
       }, 0);
     })(i);
   }
   ```

2. 给定时器传入第三个参数, 作为 timer 函数的第一个函数参数

   ```js
   for (var i = 1; i <= 5; i++) {
     setTimeout(
       function timer(j) {
         console.log(j);
       },
       0,
       i,
     );
   }
   ```

3. 使用 ES6 中的 let（产生块级作用域）

   ```js
   for (let i = 1; i <= 5; i++) {
     setTimeout(function timer() {
       console.log(i);
     }, 0);
   }
   ```

## 0.1+0.2 为什么不等于 0.3？

1. 首先计算机无法直接对十进制的数字进行运算，遵循 IEEE754 标准表示的数字需要先转换成相应的二进制，而 0.1 和 0.2 在转换二进制后会进入无限循环，但是由于 IEEE754 标准，其尾数位数是有限制的，所以将多余的截掉。
2. 然后进行对阶运算，相加后因浮点数小数位的限制截掉的二进制数字会进一步丢失精度，再转换成十进制就会变成 0.30000000000000004

- 为什么 0.1 + 0.2 不等于 0.3。因为计算机不能精确表示 0.1， 0.2 这样的浮点数，计算时使用的是带有舍入误差的数
- 并不是所有的浮点数在计算机内部都存在舍入误差，比如 0.5 就没有舍入误差
- 具有舍入误差的运算结可能会符合我们的期望，原因可能是“负负得正”
- 怎么办？1 个办法是使用整型代替浮点数计算；2 是不要直接比较两个浮点数，而应该使用 bignumber.js 这样的浮点数运算库

## 字符串 replace 方法和实现 replaceAll

如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。

```js
const str = 'dogdogdog';
const str2 = str.replace(new RegExp('dog'), 'cat');
const str3 = str.replace(new RegExp('dog', 'gm'), 'cat');
console.log(str2);

console.log(new RegExp('dog', 'g'));
```

## Math 对象方法和生成随机数的方式

| 方法 | 描述 |
| :-- | :-- |
| [ceil(x)](https://www.runoob.com/jsref/jsref-ceil.html) | 对数进行上舍入，即向上取整。 |
| [floor(x)](https://www.runoob.com/jsref/jsref-floor.html) | 对 x 进行下舍入，即向下取整。 |
| [round(x)](https://www.runoob.com/jsref/jsref-round.html) | 四舍五入。 |
| [random()](https://www.runoob.com/jsref/jsref-random.html) | 返回 0 ~ 1 之间的随机数，包含 0 不包含 1。 |

```js
Math.ceil(Math.random() * 10); // 获取从 1 到 10 的随机整数，取 0 的概率极小。

Math.round(Math.random()); // 可均衡获取 0 到 1 的随机整数。

Math.floor(Math.random() * 10); // 可均衡获取 0 到 9 的随机整数。

Math.round(Math.random() * 10); // 基本均衡获取 0 到 10 的随机整数，其中获取最小值 0 和最大值 10 的几率少一半。
```

## 自执行函数?用于什么场景？好处?

自执行函数:1、声明一个匿名函数 2、马上调用这个匿名函数。作用：创建一个独立的作用域。

好处：防止变量弥散到全局，以免各种 js 库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理

场景：一般用于框架、插件等场景

## 原型、构造函数、实例、原型链

![img](https://pic3.zhimg.com/80/v2-a6b2ab6b93f5b72cee707e2d3ea327e2_720w.jpg)

[![project](http://47.98.159.95/my_blog/017/2.jpg)](http://47.98.159.95/my_blog/017/2.jpg)

特点：

- 构造函数.prototype.constructor === 构造函数
- 构造函数.prototype === 实例对象.`__proto__`

小提示：

- Object.getPrototypeOf(对象)可以取到此对象的原型

- 使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true

## `a.b.c.d` 和 `a['b']['c']['d']` ，哪个性能更高？

应该是 `a.b.c.d` 比 `a['b']['c']['d']` 性能高点，后者还要考虑 `[ ]` 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。

## 变量提升，作用域相关代码题

```js
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

```js
// Goodbye Jack
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    var name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

```js
// Hello Tom
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    let name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
// 打印 Function b
```

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
// undefined 10 20
```

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  // var a = 20;
  console.log(a);
})();
// 10 5 5
```

```js
var b = 10;
(function b() {
  window.b = 20;
  console.log(b); // [Function b]
  console.log(window.b); // 20是必然的
})();
```

```js
var b = 10;
(function b() {
  var b = 20; // IIFE内部变量
  console.log(b); // 20
  console.log(window.b); // 10
})();
```

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
```

```js
var b = 10;
(function b() {
  // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值；
  // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。
  // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）
  b = 20;
  console.log(b); // [Function b]
  console.log(window.b); // 10，不是20
})();
```

```js
var b = 10;
(function b() {
  'use strict';
  b = 20;
  console.log(b);
})(); // "Uncaught TypeError: Assignment to constant variable."
```

1. 函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。

2. 对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。

3. IIFE 中的函数是函数表达式，而不是函数声明。

   b 函数是一个相当于用 const 定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错"Uncaught TypeError: Assignment to constant variable."

```js
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };

console.log(a.x);
console.log(b.x);
```

结果: undefined {n:2}

首先，a 和 b 同时引用了{n:2}对象，接着执行到 a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行 a.x，相当于为 a（或者 b）所指向的{n:1}对象新增了一个属性 x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行 a ={n:2}的时候，a 的引用改变，指向了新对象{n：2},而 b 依然指向的是旧对象。之后执行 a.x = {n：2}的时候，并不会重新解析一遍 a，而是沿用最初解析 a.x 时候的 a，也即旧对象，故此时旧对象的 x 的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被 b 引用着。后面输出 a.x 的时候，又要解析 a 了，此时的 a 是指向新对象的 a，而这个新对象是没有 x 属性的，故访问时输出 undefined；而访问 b.x 的时候，将输出旧对象的 x 的值，即{n:2}。

## requestAnimationFrame 有了解过吗？

`requestAnimationFrame`是浏览器用于定时循环操作的一个接口，类似于`setTimeout`，主要用途是按帧对网页进行重绘。对于`JS`动画，用`requestAnimationFrame` 会比 `setInterval` 效果更好。

## 平常工作中 ES6+主要用到了哪些？

`ES6`：

1. `Class`
2. 模块`import`和`export`
3. 箭头函数
4. 函数默认参数
5. `...`扩展运输符允许展开数组
6. 解构
7. 字符串模版
8. Promise
9. `let const`
10. `Proxy、Map、Set`
11. 对象属性同名能简写

`ES7`：

1. `includes`
2. 求幂运算符

`ES8`：

1. `async/await`
2. Object.values()和 Object.entries()

ES9：

1. `for...await...of`
2. `...`展开符合允许展开对象收集剩余参数
3. `Promise.finally()`
4. 正则中的四个新功能

`ES10`：

1. `flat()`

## 创建对象的几种方法

```js
//创建对象的几种方式
//1.字面量
var obj1 = { name: 'solo obj1' };
//2.new Object
var obj2 = new Object({ name: 'solo obj2' });
//3.构造函数创建
var M = function (name) {
  this.name = name;
};
var obj3 = new M('solo obj3');
//4.Object.create
var p = { name: 'p' };
var obj4 = Object.create(p);
```

## BigInt 使用

BigInt 是一种新的数据类型，用于当整数值大于 Number 数据类型支持的范围时。这种数据类型允许我们安全地对`大整数`执行算术操作，表示高分辨率的时间戳，使用大整数 id，等等，而不需要使用库。

- 为什么需要 BigInt?

  在 JS 中，所有的数字都以双精度 64 位浮点格式表示，那这会带来什么问题呢？

  这导致 JS 中的 Number 无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS 中的 Number 类型只能安全地表示-9007199254740991(-(2^53-1))和 9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。

## call 和 apply 的区别

共同点：

- 都能够改变函数执行时的上下文，将一个对象的方法交给另一个对象来执行，并且是立即执行的。
- 调用 call 和 apply 的对象，必须是一个函数 Function

区别主要体现在参数上。 在`参数少`的情况下，call 的性能优于 apply，反之 apply 的性能更好。

调用 call 的对象，必须是个函数 Function。 call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。

```js
function func(a, b, c) {}
func.call(obj, 1, 2, 3);
// func 接收到的参数实际上是 1,2,3
func.call(obj, [1, 2, 3]);
// func 接收到的参数实际上是 [1,2,3],undefined,undefined
```

apply 的写法 Function.apply(obj[,argArray]) 复制代码

- 它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。
- 第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。

```js
func.apply(obj, [1, 2, 3]);
// func 接收到的参数实际上是 1,2,3
func.apply(obj, {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
});
// func 接收到的参数实际上是 1,2,3
```

## call 和 apply 的用途

下面会分别列举 call 和 apply 的一些使用场景。声明：例子中没有哪个场景是必须用 call 或者必须用 apply 的，只是个人习惯这么用而已。

- call 的使用场景

**1、对象的继承**。如下面这个例子：

```js
function superClass() {
  this.a = 1;
  this.print = function () {
    console.log(this.a);
  };
}
function subClass() {
  superClass.call(this);
  this.print();
}
subClass();
// 1
```

- apply 的使用场景

**1、Math.max**。用它来获取数组中最大的一项。

```js
let max = Math.max.apply(null, array);
```

同理，要获取数组中最小的一项，可以这样：

```js
let min = Math.min.apply(null, array);
```

**2、实现两个数组合并**。在 ES6 的扩展运算符出现之前，我们可以用 Array.prototype.push 来实现。

```js
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
Array.prototype.push.apply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5, 6]
```

## bind 的使用

最后来说说 bind。在 MDN 上的解释是：bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。它的语法如下：

```js
Function.bind(thisArg[, arg1[, arg2[, ...]]])
```

bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，**bind 方法的返回值是函数，并且需要稍后调用，才会执行**。而 apply 和 call 则是立即调用。

来看下面这个例子：

```js
function add(a, b) {
  return a + b;
}
function sub(a, b) {
  return a - b;
}

add.bind(sub, 5, 3); // 这时，并不会返回 8
add.bind(sub, 5, 3)(); // 调用后，返回 8
```

如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。总结 call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。 bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。

## 请简述`JavaScript`中的`this`。

是什么：是函数运行时内部自动生成的一个内部对象，只能在函数内部使用

粗略地讲，函数的调用方式决定了`this`的值。

1. 在调用函数时使用`new`关键字，函数内的`this`是一个全新的对象，会绑定到新生成的实例对象上。

2. 如果`apply`、`call`或`bind`方法用于调用、创建一个函数，函数内的 this 就是作为参数传入这些方法的对象。

3. 当函数作为对象里的方法被调用时，函数内的`this`是调用该函数的对象。比如当`obj.method()`被调用时，函数内的 this 将绑定到`obj`对象。

4. 如果调用函数不符合上述规则，那么`this`的值指向全局对象（global object）。浏览器环境下`this`的值指向`window`对象，但是在严格模式下(`'use strict'`)，`this`的值为`undefined`。

5. 如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定`this`的值。

   > 优先级: new > call、apply、bind > 对象.方法 > 直接调用。

6. 如果该函数是 ES2015 中的箭头函数，将忽略上面的所有规则，`this`被设置为它被创建时的上下文。

如何确定：如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。 1. 由 new 调用？绑定到新创建的对象。 2. 由 call 或者 apply （或者 bind ）调用？ 绑定到指定的对象。3. 由上下文对象调用？绑定到那个上下文对象。 4. 默认：在严格模式下绑定到 undefined ，否则绑定到全局对象。

箭头函数的 this:

箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：

1、函数体内的 this 对象，里面的 this 会指向当前最近的非箭头函数的 this，就是定义时所在的对象，而不是使用时所在的对象，用 call，apply，bind 也不能改变`this`指向

2、不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

3、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

4、不可以使用 new 命令，因为：

- 没有自己的 this，无法调用 call，apply，bind。
- 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 **proto**

## 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？

在 ES5 中，顶层对象的属性和全局变量是等价的，var 命令和 function 命令声明的全局变量，自然也是顶层对象。

但 ES6 规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。

在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中

在定义变量的块级作用域中就能获取

const 和 let 会生成块级作用域，可以理解为

```js
let a = 10;
const b = 20;
相当于：
(function(){
    var  a = 10;
    var b = 20;
})()
```

ES5 没有块级作用域的概念，只有函数作用域，可以近似理解成这样。 所以外层 window 必然无法访问。

## 使用 let、var 和 const 创建变量有什么区别

- `var`声明的变量会挂到 window 上，而`let`和`const`不会
- `var`声明的变量存在变量提升，而`let`和`const`不会
- `let`和`const`声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问
- 同一作用域下`let`和`const`不能声明同名变量，而`var`可以
- 暂时性死区，`let`和`const`声明的变量不能在声明前被使用

用 var 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。let 和 const 是块级作用域，意味着它们只能在最近的一组花括号（function、if-else 代码块或 for 循环中）中访问。

```js
function foo() {
  // 所有变量在函数中都可访问
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';

  console.log(bar); // bar
  console.log(baz); // baz
  console.log(qux); // qux
}

console.log(bar); // ReferenceError: bar is not defined
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
if (true) {
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';
}

// 用 var 声明的变量在函数作用域上都可访问
console.log(bar); // bar
// let 和 const 定义的变量在它们被定义的语句块之外不可访问
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
```

var 会使变量提升，这意味着变量可以在声明之前使用。let 和 const 不会使变量提升，提前使用会报错。

```js
console.log(foo); // undefined

var foo = 'foo';

console.log(baz); // ReferenceError: can't access lexical declaration 'baz' before initialization

let baz = 'baz';

console.log(bar); // ReferenceError: can't access lexical declaration 'bar' before initialization

const bar = 'bar';
```

用 var 重复声明不会报错，但 let 和 const 会。

```js
var foo = 'foo';
var foo = 'bar';
console.log(foo); // "bar"

let baz = 'baz';
let baz = 'qux'; // Uncaught SyntaxError: Identifier 'baz' has already been declared
```

let 和 const 的区别在于：let 允许多次赋值，而 const 只允许一次。

```js
// 这样不会报错。
let foo = 'foo';
foo = 'bar';

// 这样会报错。
const baz = 'baz';
baz = 'qux';
```

## 数组去重

ES5

```js
function unique(arry) {
  const temp = [];
  arry.forEach(function (item) {
    if (temp.indexOf(item) == -1) {
      temp.push(item);
    }
  });

  return temp;
}
```

ES6

```js
function unique(arry) {
  return Array.from(new Set(arry));
}
```

## 如何判断数组与对象

```js
Array.isArray([]); // true
Array.isArray({}); // false

typeof []; // "object"
typeof {}; // "object"

Object.prototype == [].__proto__; // false
Object.prototype == {}.__proto__; // true
Array.prototype == [].__proto__; // true
Array.prototype == {}.__proto__; // false
```

## 对象引用相关代码题

```js
function changeObjProperty(o) {
  o.siteUrl = 'http://www.baidu.com';
  o = new Object();
  o.siteUrl = 'http://www.google.com';
}
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl);
```

对象传值传的是引用，但是引用是 copy 给函数形参。

```js
// 这里把o改成a
// webSite引用地址的值copy给a了
function changeObjProperty(a) {
  // 改变对应地址内的对象属性值
  a.siteUrl = 'http://www.baidu.com';
  // 变量a指向新的地址 以后的变动和旧地址无关
  a = new Object();
  a.siteUrl = 'http://www.google.com';
  a.name = 456;
}
var webSite = new Object();
webSite.name = '123';
changeObjProperty(webSite);
console.log(webSite); // {name: 123, siteUrl: 'http://www.baidu.com'}
```

`parseInt()` 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。

## 对象浅拷贝和深拷贝有什么区别

在 `JS` 中，除了基本数据类型，还存在对象、数组这种引用类型。 基本数据类型，拷贝是直接拷贝变量的值，而引用类型拷贝的其实是变量的地址。

```js
let o1 = { a: 1 };
let o2 = o1;
```

在这种情况下，如果改变 `o1` 或 `o2` 其中一个值的话，另一个也会变，因为它们都指向同一个地址。

```js
o2.a = 3;
console.log(o1.a); // 3
```

而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有重新创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。

## 浅拷贝的方式有几种

专属数组的浅拷贝

- slice

  ```js
  const arr = [1, 2, 3];
  const newArr = arr.slice();
  newArr[1] = 100;
  console.log(arr); //[ 1, 2, 3 ]
  ```

- concat

  ```js
  const arr = [1, 2, 3];
  const newArr = arr.contat();
  newArr[1] = 100;
  console.log(arr); //[ 1, 2, 3 ]
  ```

都可用的浅拷贝

- Object.assign（只会拷贝源对象自身的并且可枚举的属性到目标对象）

  ```js
  const obj = { name: 'sy', age: 18 };
  const obj2 = Object.assign({}, obj, { name: 'sss' });
  console.log(obj2); //{ name: 'sss', age: 18 }
  ```

- ...展开符

  ```js
  let arr = [1, 2, 3];
  let newArr = [...arr]; //跟arr.slice()是一样的效果
  ```

## 实现一个深拷贝

```js
JSON.parse(JSON.stringify());
```

这种方式会造成

- 无法解决循环引用的问题，拷贝时会报错
- 会忽略掉函数
- 会忽略掉 undefined
- 会忽略掉 Symbol
- 会将 RegExp,Set, Map 拷贝成空对象

推荐使用 lodash 的深拷贝函数

## 字符串和数组的关系

在很大程度上，可以将字符串看成字符串数组，

都有 length 属性

都有 concat() / indexOf() / includes() / slice() 方法

不过值得注意的是， string 上没有方法可以原地修改它自身的内容，都是返回新的 string

string 还有个 repeat() 方法，创建指定数量的字符串副本

## Object 上的一些值得注意的方法

- **Object.prototype.hasOwnProperty(prop)**

  所有继承了 Object 的对象，用来监测一个对象是否含有特定的自身属性，会忽略原型链上继承的属性。

  ```js

  o = new Object();

  o.prop = 'exists';

  o.hasOwnProperty('prop'); *// 返回 true*

  o.hasOwnProperty('toString'); *// 返回 false*

  o.hasOwnProperty('hasOwnProperty'); *// 返回 false*

  ```

- **Object.create(proto[, propertiesObject])**

  第一个参数为新创建对象的原型对象，第二个参数可选，选定添加到新创建对象的不可枚举属性中（自身）。

  ```js
  var my_obj = Object.create(
    {},
    {
      getFoo: {
        value: function () {
          return this.foo;
        },
        // 可选择控制此属性是否可枚举 默认为 false
        // enumerable: false
      },
      // getFoo: function() { return this.foo; },
    },
  );
  ```

* **Object.defineProperties(obj, props)**

  直接在一个对象上定义新的属性或修改现有属性，并返回该对象。

  ```js
  var obj = {};
  Object.defineProperties(obj, {
    property1: {
      value: true,
      writable: true,
    },
    property2: {
      value: 'Hello',
      writable: false,
    },
    // etc. etc.
  });
  ```

* **Object.defineProperty(obj, prop, descriptor)**

  Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。

* **Object.getOwnPropertyNames()**

  返回一个给定元素自身属性对应的字符串数组，包括可枚举和不可枚举属性，但不包括 Symbol 值作为名称的属性

  ```js
  //不可枚举属性
  var my_obj = Object.create(
    {},
    {
      getFoo: {
        value: function () {
          return this.foo;
        },
        enumerable: false,
      },
    },
  );

  my_obj.foo = 1;

  console.log(Object.getOwnPropertyNames(my_obj).sort()); // ["foo", "getFoo"]
  ```

- **Object.assign(target, ...sources)**

  Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

  与解构运算符...的区别在于，他会改变目标值，也就是 target，并且返回他。

- **Object.getPrototypeOf(object)**

  特别注意：Object.getPrototypeOf(Object) 不是 Object.prototype

  ```js
  // Object 是构造函数
  Object.getPrototypeOf(Object) === Function.prototype
  ```
  
- **Object.prototype.toString.call()**

  每一个继承 Object 的对象都有 `toString` 方法，如果 `toString` 方法没有重写的话，会返回 `[Object type]`，其中 type 为对象的类型。



## Proxy和Object.defineProperty(obj, prop, descriptor)

