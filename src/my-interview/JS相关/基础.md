[TOC]

## 闭包

定义： 有权访问另外一个函数作用域中的变量的函数，存在意义在于间接访问函数内部的变量。但也因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用。

```js
var f3;
function f1() {
  var a = 2;
  f3 = function () {
    console.log(a);
  };
}
f1();
f3();
```

闭包经典面试题

原因： 由于 setTimeout 是宏任务，所以每次循环时会新起一个任务队列，等外面的 for 循环完成后，再依次执行，此时，i 已经成为了 6

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, 0);
}
```

1. 采用立即执行函数

   ```js
   for (var i = 1; i <= 5; i++) {
     (function (j) {
       setTimeout(function timer() {
         console.log(j);
       }, 0);
     })(i);
   }
   ```

2. 给定时器传入第三个参数, 作为 timer 函数的第一个函数参数

   ```js
   for (var i = 1; i <= 5; i++) {
     setTimeout(
       function timer(j) {
         console.log(j);
       },
       0,
       i,
     );
   }
   ```

3. 使用 ES6 中的 let（产生块级作用域）

   ```js
   for (let i = 1; i <= 5; i++) {
     setTimeout(function timer() {
       console.log(i);
     }, 0);
   }
   ```

## 0.1+0.2 为什么不等于 0.3？

1. 首先计算机无法直接对十进制的数字进行运算，遵循 IEEE754 标准表示的数字需要先转换成相应的二进制，而 0.1 和 0.2 在转换二进制后会进入无限循环，但是由于 IEEE754 标准，其尾数位数是有限制的，所以将多余的截掉。
2. 然后进行对阶运算，相加后因浮点数小数位的限制截掉的二进制数字会进一步丢失精度，再转换成十进制就会变成 0.30000000000000004

- 为什么 0.1 + 0.2 不等于 0.3。因为计算机不能精确表示 0.1， 0.2 这样的浮点数，计算时使用的是带有舍入误差的数
- 并不是所有的浮点数在计算机内部都存在舍入误差，比如 0.5 就没有舍入误差
- 具有舍入误差的运算结可能会符合我们的期望，原因可能是“负负得正”
- 怎么办？1 个办法是使用整型代替浮点数计算；2 是不要直接比较两个浮点数，而应该使用 bignumber.js 这样的浮点数运算库

## 自执行函数?用于什么场景？好处?

自执行函数:1、声明一个匿名函数 2、马上调用这个匿名函数。作用：创建一个独立的作用域。

好处：防止变量弥散到全局，以免各种 js 库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理

场景：一般用于框架、插件等场景

## 原型、构造函数、实例、原型链

![img](https://pic3.zhimg.com/80/v2-a6b2ab6b93f5b72cee707e2d3ea327e2_720w.jpg)

[![project](http://47.98.159.95/my_blog/017/2.jpg)](http://47.98.159.95/my_blog/017/2.jpg)

特点：

- 构造函数.prototype.constructor === 构造函数
- 构造函数.prototype === 实例对象.`__proto__`

小提示：

- Object.getPrototypeOf(对象)可以取到此对象的原型

- 对象的 hasOwnProperty() 来检查对象自身中是否含有该属性

  ```js
  o = new Object();
  o.prop = 'exists';
  o.hasOwnProperty('prop'); // 返回 true
  o.hasOwnProperty('toString'); // 返回 false
  o.hasOwnProperty('hasOwnProperty'); // 返回 false
  ```

- 使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true

## `a.b.c.d` 和 `a['b']['c']['d']` ，哪个性能更高？

应该是 `a.b.c.d` 比 `a['b']['c']['d']` 性能高点，后者还要考虑 `[ ]` 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。

## 变量提升，作用域相关代码题

```js
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

```js
// Goodbye Jack
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    var name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

```js
// Hello Tom
var name = 'Tom';
(function () {
  if (typeof name == 'undefined') {
    let name = 'Jack';
    console.log('Goodbye ' + name);
  } else {
    console.log('Hello ' + name);
  }
})();
```

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
// 打印 Function b
```

1. 函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。

2. 对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。

3. IIFE 中的函数是函数表达式，而不是函数声明。

   b 函数是一个相当于用 const 定义的常量，内部无法进行重新赋值，如果在严格模式下，会报错"Uncaught TypeError: Assignment to constant variable."

如果用 ' use strict ' 的话 会导致报错

```js
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };

console.log(a.x);
console.log(b.x);
```

结果: undefined {n:2}

首先，a 和 b 同时引用了{n:2}对象，接着执行到 a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行 a.x，相当于为 a（或者 b）所指向的{n:1}对象新增了一个属性 x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行 a ={n:2}的时候，a 的引用改变，指向了新对象{n：2},而 b 依然指向的是旧对象。之后执行 a.x = {n：2}的时候，并不会重新解析一遍 a，而是沿用最初解析 a.x 时候的 a，也即旧对象，故此时旧对象的 x 的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被 b 引用着。后面输出 a.x 的时候，又要解析 a 了，此时的 a 是指向新对象的 a，而这个新对象是没有 x 属性的，故访问时输出 undefined；而访问 b.x 的时候，将输出旧对象的 x 的值，即{n:2}。

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  // var a = 20;
  console.log(a);
})();
// 10 5 5
```

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
// undefined 10 20
```

在立即执行函数中，`var a = 20;` 语句定义了一个局部变量 `a`，由于 js 的变量声明提升机制，局部变量`a`的声明会被提升至立即执行函数的函数体最上方，且由于这样的提升并不包括赋值，因此第一条打印语句会打印`undefined`，最后一条语句会打印`20`。

由于变量声明提升，`a = 5;` 这条语句执行时，局部的变量`a`已经声明，因此它产生的效果是对局部的变量`a`赋值，此时`window.a` 依旧是最开始赋值的`10`.

分别为 undefined 　 10 　 20，原因是作用域问题，在内部声名 var a = 20;相当于先声明 var a;然后再执行赋值操作，这是在ＩＩＦＥ内形成的独立作用域，如果把 var a=20 注释掉，那么 a 只有在外部有声明，显示的就是外部的Ａ变量的值了。结果Ａ会是 10 　 5 　 5

```js
var b = 10;
(function b() {
  // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值；
  // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。
  // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）
  b = 20;
  console.log(b); // [Function b]
  console.log(window.b); // 10，不是20
})();
```

所以严格模式下能看到错误：`Uncaught TypeError: Assignment to constant variable`

```js
var b = 10;
(function b() {
  'use strict';
  b = 20;
  console.log(b);
})(); // "Uncaught TypeError: Assignment to constant variable."
```

其他情况例子：

有`window`：

```js
var b = 10;
(function b() {
  window.b = 20;
  console.log(b); // [Function b]
  console.log(window.b); // 20是必然的
})();
```

有`var`:

```js
var b = 10;
(function b() {
  var b = 20; // IIFE内部变量
  console.log(b); // 20
  console.log(window.b); // 10
})();
```

## 变量提升，作用域相关代码题

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
```

## 对象引用相关代码题

```js
function changeObjProperty(o) {
  o.siteUrl = 'http://www.baidu.com';
  o = new Object();
  o.siteUrl = 'http://www.google.com';
}
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl);
```

对象传值传的是引用，但是引用是 copy 给函数形参。

```js
// 这里把o改成a
// webSite引用地址的值copy给a了
function changeObjProperty(a) {
  // 改变对应地址内的对象属性值
  a.siteUrl = 'http://www.baidu.com';
  // 变量a指向新的地址 以后的变动和旧地址无关
  a = new Object();
  a.siteUrl = 'http://www.google.com';
  a.name = 456;
}
var webSite = new Object();
webSite.name = '123';
changeObjProperty(webSite);
console.log(webSite); // {name: 123, siteUrl: 'http://www.baidu.com'}
```

`parseInt()` 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。

## setTimeout 的执行原理(EventLoop)

`setTimeout`的运行机制：执行该语句时，是立即把当前定时器代码推入事件队列，当定时器在事件列表中满足设置的时间值时将传入的函数加入任务队列，之后的执行就交给任务队列负责。但是如果此时任务队列不为空，则需等待，所以执行定时器内代码的时间可能会大于设置的时间

## requestAnimationFrame 有了解过吗？

`requestAnimationFrame`是浏览器用于定时循环操作的一个接口，类似于`setTimeout`，主要用途是按帧对网页进行重绘。对于`JS`动画，用`requestAnimationFrame` 会比 `setInterval` 效果更好。

## 平常工作中 ES6+主要用到了哪些？

`ES6`：

1. `Class`
2. 模块`import`和`export`
3. 箭头函数
4. 函数默认参数
5. `...`扩展运输符允许展开数组
6. 解构
7. 字符串模版
8. Promise
9. `let const`
10. `Proxy、Map、Set`
11. 对象属性同名能简写

`ES7`：

1. `includes`
2. `**`求幂运算符

`ES8`：

1. `async/await`
2. `Object.values()和Object.entries()`
3. `padStart()和padEnd()`
4. `Object.getOwnPropertyDescriptors()`
5. 函数参数允许尾部`,`

`ES9`：

1. `for...await...of`
2. `...`展开符合允许展开对象收集剩余参数
3. `Promise.finally()`
4. 正则中的四个新功能

`ES10`：

1. `flat()`
2. `flatMap()`
3. `fromEntries()`
4. `trimStart`和`trimEnd`
5. `matchAll`
6. `BigInt`
7. `try/catch`中报错允许没有`err`异常参数
8. `Symbol.prototype.description`
9. `Function.toString()`调用时呈现原本源码的样子

## 不使用框架如何实现组件按需加载以及原理

当时答的是是用`import`来按需引入，以及提到了`Vue.use`。

但后来有去了解，`babel-plugin-import`就可以实现。

## 创建对象的几种方法

```js
//创建对象的几种方式
//1.字面量
var obj1 = { name: 'solo obj1' };
//2.new Object
var obj2 = new Object({ name: 'solo obj2' });
//3.构造函数创建
var M = function (name) {
  this.name = name;
};
var obj3 = new M('solo obj3');
//4.Object.create
var p = { name: 'p' };
var obj4 = Object.create(p);
```

## BigInt 使用

BigInt 是一种新的数据类型，用于当整数值大于 Number 数据类型支持的范围时。这种数据类型允许我们安全地对`大整数`执行算术操作，表示高分辨率的时间戳，使用大整数 id，等等，而不需要使用库。

- 为什么需要 BigInt?

  在 JS 中，所有的数字都以双精度 64 位浮点格式表示，那这会带来什么问题呢？

  这导致 JS 中的 Number 无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS 中的 Number 类型只能安全地表示-9007199254740991(-(2^53-1))和 9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。

## 类的声明和实例化

声明类有两种方法：

```js
function Animal(name) {
  this.name = name;
}

class Animal2 {
  constructor(name) {
    this.name = name;
  }
}
```

类的实例化只有一种方式

```js
var a1 = new Animal('shape');
var a2 = new Animal2('cat');
```

## call 和 apply 的区别

共同点：

- 都能够改变函数执行时的上下文，将一个对象的方法交给另一个对象来执行，并且是立即执行的。
- 调用 call 和 apply 的对象，必须是一个函数 Function

区别主要体现在参数上。 在`参数少`的情况下，call 的性能优于 apply，反之 apply 的性能更好。

调用 call 的对象，必须是个函数 Function。 call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。

```js
function func(a, b, c) {}
func.call(obj, 1, 2, 3);
// func 接收到的参数实际上是 1,2,3
func.call(obj, [1, 2, 3]);
// func 接收到的参数实际上是 [1,2,3],undefined,undefined
```

apply 的写法 Function.apply(obj[,argArray]) 复制代码

- 它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。
- 第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。

```js
func.apply(obj, [1, 2, 3]);
// func 接收到的参数实际上是 1,2,3
func.apply(obj, {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
});
// func 接收到的参数实际上是 1,2,3
```

## call 和 apply 的用途

下面会分别列举 call 和 apply 的一些使用场景。声明：例子中没有哪个场景是必须用 call 或者必须用 apply 的，只是个人习惯这么用而已。

- call 的使用场景

**1、对象的继承**。如下面这个例子：

```js
function superClass () {
    this.a = 1;
    this.print = function () {
        console.log(this.a);
    }
}
function subClass () {
    superClass.call(this);
    this.print();
}
subClass();
// 1
```

subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。此外，subClass 还可以扩展自己的其他方法。 **2、借用方法**。还记得刚才的类数组么？如果它想使用 Array 原型链上的方法，可以这样： let domNodes = Array.prototype.slice.call(document.getElementsByTagName("\*"));

这样，domNodes 就可以应用 Array 下的所有方法了。

- apply 的使用场景

**1、Math.max**。用它来获取数组中最大的一项。

```text
let max = Math.max.apply(null, array);
```

同理，要获取数组中最小的一项，可以这样：

```text
let min = Math.min.apply(null, array);
```

**2、实现两个数组合并**。在 ES6 的扩展运算符出现之前，我们可以用 Array.prototype.push 来实现。

```text
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
Array.prototype.push.apply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5, 6]
```

## bind 的使用

最后来说说 bind。在 MDN 上的解释是：bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。它的语法如下：

```text
Function.bind(thisArg[, arg1[, arg2[, ...]]])
```

bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，**bind 方法的返回值是函数，并且需要稍后调用，才会执行**。而 apply 和 call 则是立即调用。

来看下面这个例子：

```text
function add (a, b) {
    return a + b;
}
function sub (a, b) {
    return a - b;
}
add.bind(sub, 5, 3); // 这时，并不会返回 8
add.bind(sub, 5, 3)(); // 调用后，返回 8
```

如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。总结 call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。 bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。

## 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？

在 ES5 中，顶层对象的属性和全局变量是等价的，var 命令和 function 命令声明的全局变量，自然也是顶层对象。

但 ES6 规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。

在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中

在定义变量的块级作用域中就能获取

const 和 let 会生成块级作用域，可以理解为

```js
let a = 10;
const b = 20;
相当于：
(function(){
    var  a = 10;
    var b = 20;
})()
```

ES5 没有块级作用域的概念，只有函数作用域，可以近似理解成这样。 所以外层 window 必然无法访问。

## 如何在 ES5 环境下实现 let

babel 在 let 定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数来模拟块级作用域

```js
(function () {
  for (var i = 0; i < 5; i++) {
    console.log(i); // 0 1 2 3 4
  }
})();

console.log(i); // Uncaught ReferenceError: i is not defined
```

不过这个问题并没有结束，我们回到`var`和`let/const`的区别上：

- `var`声明的变量会挂到 window 上，而`let`和`const`不会
- `var`声明的变量存在变量提升，而`let`和`const`不会
- `let`和`const`声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问
- 同一作用域下`let`和`const`不能声明同名变量，而`var`可以
- 暂时性死区，`let`和`const`声明的变量不能在声明前被使用

babel 的转化，其实只实现了第 2、3、5 点

## 如何在 ES5 环境下实现 const

对于 const 不可修改的特性，我们通过设置 writable 属性来实现

```js
function _const(key, value) {
  const desc = {
    value,
    writable: false,
  };
  Object.defineProperty(window, key, desc);
}

_const('obj', { a: 1 }); //定义obj
obj.b = 2; //可以正常给obj的属性赋值
obj = {}; //无法赋值新对象
```

## 

## 使用 let、var 和 const 创建变量有什么区别

用 var 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。let 和 const 是块级作用域，意味着它们只能在最近的一组花括号（function、if-else 代码块或 for 循环中）中访问。

```js
function foo() {
  // 所有变量在函数中都可访问
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';

  console.log(bar); // bar
  console.log(baz); // baz
  console.log(qux); // qux
}

console.log(bar); // ReferenceError: bar is not defined
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
if (true) {
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';
}

// 用 var 声明的变量在函数作用域上都可访问
console.log(bar); // bar
// let 和 const 定义的变量在它们被定义的语句块之外不可访问
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
```

var 会使变量提升，这意味着变量可以在声明之前使用。let 和 const 不会使变量提升，提前使用会报错。

```js
console.log(foo); // undefined

var foo = 'foo';

console.log(baz); // ReferenceError: can't access lexical declaration 'baz' before initialization

let baz = 'baz';

console.log(bar); // ReferenceError: can't access lexical declaration 'bar' before initialization

const bar = 'bar';
```

用 var 重复声明不会报错，但 let 和 const 会。

```js
var foo = 'foo';
var foo = 'bar';
console.log(foo); // "bar"

let baz = 'baz';
let baz = 'qux'; // Uncaught SyntaxError: Identifier 'baz' has already been declared
```

let 和 const 的区别在于：let 允许多次赋值，而 const 只允许一次。

```js
// 这样不会报错。
let foo = 'foo';
foo = 'bar';

// 这样会报错。
const baz = 'baz';
baz = 'qux';
```

[https://github.com/yangshun/fro](https://link.zhihu.com/?target=https%3A//github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Chinese/questions/javascript-questions.md%23%E4%BD%BF%E7%94%A8letvar%E5%92%8Cconst%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)



## 数组去重

ES5

```js
function unique(arry) {
  const temp = [];
  arry.forEach(function (item) {
    if (temp.indexOf(item) == -1) {
      temp.push(item);
    }
  });

  return temp;
}
```

ES6

```js
function unique(arry) {
  return Array.from(new Set(arry));
}
```

## 如何判断数组与对象

```js
Array.isArray([]); // true
Array.isArray({}); // false

typeof []; // "object"
typeof {}; // "object"

Object.prototype == [].__proto__; // false
Object.prototype == {}.__proto__; // true
Array.prototype == [].__proto__; // true
Array.prototype == {}.__proto__; // false
```

## 请简述`JavaScript`中的`this`。

是什么：是函数运行时内部自动生成的一个内部对象，只能在函数内部使用

JS 中的`this`是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了`this`的值。我阅读了网上很多关于`this`的文章，[Arnav Aggrawal](https://link.zhihu.com/?target=https%3A//medium.com/%40arnav_aggarwal) 写的比较清楚。`this`取值符合以下规则：

1. 在调用函数时使用`new`关键字，函数内的`this`是一个全新的对象，会绑定到新生成的实例对象上。

2. 如果`apply`、`call`或`bind`方法用于调用、创建一个函数，函数内的 this 就是作为参数传入这些方法的对象。

3. 当函数作为对象里的方法被调用时，函数内的`this`是调用该函数的对象。比如当`obj.method()`被调用时，函数内的 this 将绑定到`obj`对象。

4. 如果调用函数不符合上述规则，那么`this`的值指向全局对象（global object）。浏览器环境下`this`的值指向`window`对象，但是在严格模式下(`'use strict'`)，`this`的值为`undefined`。

5. 如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定`this`的值。

   > 优先级: new > call、apply、bind > 对象.方法 > 直接调用。

6. 如果该函数是 ES2015 中的箭头函数，将忽略上面的所有规则，`this`被设置为它被创建时的上下文。

如何确定：如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。 1. 由 new 调用？绑定到新创建的对象。 2. 由 call 或者 apply （或者 bind ）调用？绑定到指定的对象。 3. 由上下文对象调用？绑定到那个上下文对象。 4. 默认：在严格模式下绑定到 undefined ，否则绑定到全局对象。

一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null) ，以保护全局对象。 ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this ，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这其实和 ES6 之前代码中的 self = this 机制一样

## 箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？

箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：

1、函数体内的 this 对象，里面的this会指向当前最近的非箭头函数的this，就是定义时所在的对象，而不是使用时所在的对象，用 call，apply，bind 也不能改变`this`指向

2、不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

3、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

4、不可以使用 new 命令，因为：

- 没有自己的 this，无法调用 call，apply，bind。
- 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 **proto**



## 对象浅拷贝和深拷贝有什么区别

在 `JS` 中，除了基本数据类型，还存在对象、数组这种引用类型。 基本数据类型，拷贝是直接拷贝变量的值，而引用类型拷贝的其实是变量的地址。

```text
let o1 = {a: 1}
let o2 = o1
```

在这种情况下，如果改变 `o1` 或 `o2` 其中一个值的话，另一个也会变，因为它们都指向同一个地址。

```text
o2.a = 3
console.log(o1.a) // 3
```

而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有重新创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。



## 浅拷贝的方式有几种

专属数组的浅拷贝

- slice

  ```js
  const arr = [1,2,3];
  const newArr = arr.slice();
  newArr[1] = 100;
  console.log(arr);//[ 1, 2, 3 ]
  ```

- concat

  ```js
  const arr = [1,2,3];
  const newArr = arr.contat();
  newArr[1] = 100;
  console.log(arr);//[ 1, 2, 3 ]
  ```

都可用的浅拷贝

- Object.assign（只会拷贝源对象自身的并且可枚举的属性到目标对象）

  ```js
  const obj = { name: 'sy', age: 18 };
  const obj2 = Object.assign({}, obj, {name: 'sss'});
  console.log(obj2);//{ name: 'sss', age: 18 }
  ```

- ...展开符

  ```js
  let arr = [1, 2, 3];
  let newArr = [...arr];//跟arr.slice()是一样的效果
  ```




## 实现一个深拷贝

```js
JSON.parse(JSON.stringify());
```

这种方式会造成

- 无法解决循环引用的问题，拷贝时会报错
- 会忽略掉函数
- 会忽略掉undefined
- 会忽略掉Symbol
- 会将RegExp,Set, Map 拷贝成空对象



推荐使用lodash的深拷贝函数