[TOC]

## react-router 里的 **<Link>** 标签和**<a>** 标签有什么区别

Link 做了 3 件事情：

1. 有 onclick 那就执行 onclick
2. click 的时候阻止 a 标签默认事件（这样子点击`[123]()`就不会跳转和刷新页面）
3. 再取得跳转 href（即是 to），用 history（前端路由两种方式之一，history & hash）跳转，此时只是链接变了，并没有刷新页面

而 a 标签就是普通的超链接了，用于从当前页面跳转到 href 指向的另一个页面（非锚点情况）。

Link 的本质也是 a 标签。只不过在 Link 中禁用了 a 标签的默认事件 event.preventDefault()，改用了 history 对象提供的方法(history.pushState)进行跳转，这个方法会触发页面的 hashchange 事件，在 react-router 中监听了这个事件，使得整个应用不必刷新页面，只更新组件。

## React 中 setState 什么时候是同步的，什么时候是异步的

在 React 中，**如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state** 。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。

**原因：** 在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，**有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state**。

**注意：** setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。

## 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

key 的作用就是更新组件时**判断两个节点是否相同**。相同就复用，不相同就删除旧的创建新的。

## 为什么自定义的 React 组件必须大写

babel 在编译过程中会判断 JSX 组件的首字母，如果是小写，则当做原生的 DOM 标签解析，就编译成字符串。如果是大写，则认为是自定义组件，编译成对象。

## React setState 打印输出问题

```js
 componentDidMount() {
    this.setState({val: this.state.val + 1});
    console.log(this.state.val);    // 第 1 次 log

    this.setState({val: this.state.val + 1});
    console.log(this.state.val);    // 第 2 次 log

    setTimeout(() => {
      this.setState({val: this.state.val + 1});
      console.log(this.state.val);  // 第 3 次 log

      this.setState({val: this.state.val + 1});
      console.log(this.state.val);  // 第 4 次 log
    }, 0);
  }


  componentDidMount() {
    this.setState((prevState) => ({
      val: prevState.val + 1,
    }));
    console.log(this.state.val); // 第 1 次 log

    this.setState((prevState) => ({
      val: prevState.val + 1,
    }));
    console.log(this.state.val); // 第 2 次 log

    setTimeout(() => {
      this.setState((prevState) => ({
        val: prevState.val + 1,
      }));
      console.log(this.state.val); // 第 3 次 log

      this.setState((prevState) => ({
        val: prevState.val + 1,
      }));
      console.log(this.state.val); // 第 4 次 log
    }, 0);
  }

const [val, setVal] = useState(0);

useEffect(() => {
    setVal((val1) => val1 + 1);
    // console.log('1', val);
    setVal((val1) => val1 + 1);
    // console.log('2', val);
    setTimeout(() => {
      setVal((val1) => val1 + 1);
      // console.log('3', val);
      setVal((val1) => val1 + 1);
      // console.log('4', val);
    }, 0);
  }, []);

  useEffect(() => {
    setVal(val + 1);
    // console.log('1', val);
    setVal(val + 1);
    // console.log('2', val);
    setTimeout(() => {
      setVal(val + 1);
      // console.log('3', val);
      setVal(val + 1);
      // console.log('4', val);
    }, 0);
  }, []);

  console.log(val);
```

## 聊聊 Redux 和 Vuex 的设计思想

https://zhuanlan.zhihu.com/p/53599723

思路：**把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测**

## Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。

这里面有好几个方面的问题。

**1. 原生 DOM 操作 vs. 通过框架封装操作。**

这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。

**2. 对 React 的 Virtual DOM 的误解。**

React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作... 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。

我们可以比较一下 innerHTML vs. Virtual DOM 的重绘性能消耗：

- innerHTML: render html string **O(template size)** + 重新创建所有 DOM 元素 **O(DOM size)**
- Virtual DOM: render Virtual DOM + diff **O(template size)** + 必要的 DOM 更新 **O(DOM change)**

Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。

**3. MVVM vs. Virtual DOM**

相比起 React，其他 MVVM 系框架比如 Angular, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive/Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。MVVM 的性能也根据变动检测的实现原理有所不同：Angular 的脏检查使得任何变动都有固定的 **O(watcher count)** 的代价；Knockout/Vue/Avalon 都采用了依赖收集，在 js 和 DOM 层面都是 **O(change)**：

- 脏检查：scope digest **O(watcher count)** + 必要 DOM 更新 **O(DOM change)**
- 依赖收集：重新收集依赖 **O(data change)** + 必要 DOM 更新 **O(DOM change)**

可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。

MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的 "scope" 对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel / scope 实例比起 Virtual DOM 来说要昂贵很多。这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。假如没有任何复用方面的优化，由于数据是 “全新” 的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 angular/knockout 实现都相对比较慢。相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。

Angular 和 Vue 都提供了列表重绘的优化机制，也就是 “提示” 框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 Angular 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。或者，你也可以直接 track by $index 来进行 “原地复用”：直接根据在数组里的位置进行复用。在题目给出的例子里，如果 angular 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，Angular 和 Vue 用了 track by \$index 以后都比 React 快: [dbmon](https://link.zhihu.com/?target=http%3A//vuejs.github.io/js-repaint-perfs/) (注意 Angular 默认版本无优化，优化过的在下面）

顺道说一句，React 渲染列表的时候也需要提供 key 这个特殊 prop，本质上和 track-by 是一回事。

**4. 性能比较也要看场合**

在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。

- 初始渲染：Virtual DOM > 脏检查 >= 依赖收集
- 小量数据更新：依赖收集 >> Virtual DOM + 优化 > 脏检查（无法优化） > Virtual DOM 无优化
- 大量数据更新：脏检查 + 优化 >= 依赖收集 + 优化 > Virtual DOM（无法/无需优化）>> MVVM 无优化

不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative。

**5. 总结**

以上这些比较，更多的是对于框架开发研究者提供一些参考。主流的框架 + 合理的优化，足以应对绝大部分应用的性能需求。如果是对性能有极致需求的特殊情况，其实应该牺牲一些可维护性采取手动优化：比如 Atom 编辑器在文件渲染的实现上放弃了 React 而采用了自己实现的 tile-based rendering；又比如在移动端需要 DOM-pooling 的虚拟滚动，不需要考虑顺序变化，可以绕过框架的内置实现自己搞一个。

## 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？

reducer 的作用就是 **接收旧的 state 和 action，返回新的 state**，因为 redux 把 reducer 设计成只负责这个作用，如果 reducer 有副作用，副作用简单说就是不确定性，那么这样的返回的 state 就不确定。不能实现应用状态的可预测性，相同的输入可能得不到相同的输出。

## 在 Vue 中，子组件为何不可以修改父组件传递的 Prop

1. 采用单一数据流，易于监测数据的流动，出现错误能准确定位。
2. 一个父组件可以包含很多子组件，如果每个字组件都可以修改 props 的话，会导致数据的源头不止一处，不易于监测。

## React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？

优化策略：

1. 对比两个不同类型的元素会产生出不同的树； 当对比两颗树时，React 首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态。
2. 开发者可以通过 `key` prop 来暗示哪些子元素在不同的渲染下能保持稳定；

## MVC,MVVC,MVVM 模式的理解

1. MVC(Model-View-Controller) Model(模型):数据层，负责存储数据。 View(视图):展现层，用户所看到的页面 Controller(控制器):协调层，负责协调 Model 和 View，根据用户在 View 上的动作在 Model 上作出对应的更改，同时将更改的信息返回到 View 上。三者之间的关系 Controller 可以直接访问 Model，也可以直接控制 View,但是 Model 和 View 不能相互通信，相当于 COntroller 就是介于这两者之间的协调者。

2. MVVM(Model-View-ViewModel) Model(模型):数据层，负责存储数据。 View(控制器):就是 ViewController 层，他的任务就是从 ViewModel 层获取数据，然后显示。 ViewModel(视图模型):就是 View 和 Model 层的粘合剂，封装业务逻辑处理，封装网络处理，封装数据缓存。就是把原来 ViewController 层的业务逻辑和页面逻辑等剥离出来放到 ViewModel 层。

3. MVVC(Model-View-View-Controller) Model(模型):数据层，负责存储数据。 View(视图):展现层，创建需求创建 cell View(视图):定义数组，用来接收控制中的数据。处理回调（比如:刷新回调、点击 cell 回调、加载更多回调、动态视图高度回调等等）Controller(控制器):加载网络数据懒加载

## vue 与 react 优缺点对比

**vue**

1. API 设计上简单，语法简单，学习成本低
2. 构建方面不包含路由和 ajax 功能，使用 vuex, vue-router
3. 指令（dom）和组件（视图，数据，逻辑）处理清晰
4. 性能好，容易优化
5. 基于依赖追踪的观察系统，并且异步队列更新
6. 独立触发
7. v-model 实时渲染
8. 适用于：模板和渲染函数的弹性选择
9. 简单的语法及项目搭建
10. 更快的渲染速度和更小的体积

**react**

1. 利用 jsx 创建虚拟 dom, 是一种在内存中描述 dom 数状态的数据结构
2. 函数式的方法描述视图
3. 使用虚拟 dom 作为模板
4. 程序片段
5. 不好控制 dom
6. 服务端渲染：react 的虚拟 dom 的生成可以在任何支持 js 的环境生成的，所以可以在 node 环境生成，直接转为 string,然后插入到 html 文件中输出浏览器便可
7. 适用于：大型应用和更好的可测试性；同时适用于 web 端和原生 app;更大的生态圈
8. 优点 React 伟大之处就在于，提出了 Virtual Dom 这种新颖的思路，并且这种思路衍生出了 React Native，有可能会统一 Web/Native 开发。在性能方面，由于运用了 Virtual Dom 技术，Reactjs 只在调用 setState 的时候会更新 dom，而且还是先更新 Virtual Dom，然后和实际 Dom 比较，最后再更新实际 Dom。这个过程比起 Angularjs 的 bind 方式来说，一是更新 dom 的次数少，二是更新 dom 的内容少，速度肯定快
9. ReactJS 更关注 UI 的组件化，和数据的单向更新，提出了 FLUX 架构的新概念，现在 React 可以直接用 Js ES6 语法了，然后通过 webpack 编译成浏览器兼容的 ES5，开发效率上有些优势.
10. React Native 生成的 App 不是运行在 WebView 上，而是系统原生的 UI，React 通过 jsx 生成系统原生的 UI，iOS 和 Android 的 React UI 组件还是比较相似的，大量代码可以复用
11. 维护 UI 的状态,Angular 里面使用的是 \$scope，在 React 里面使用的是 this.setState。 而 React 的好处在于，它更简单直观。所有的状态改变都只有唯一一个入口 this.setState()
12. React 是目标是 UI 组件，通常可以和其它框架组合使用，目前并不适合单独做一个完整的框架。React 即使配上 redux 的组合，也不能称之一个完整的框架，比如你想用 Promise 化的 AJAX？对不起没有，自己找现成的库去。而且第三方组件远远不如 Angular 多。目前在大的稳定的项目上采用 React 的，我也就只知道有 Yahoo 的 Email。React 本身只是一个 V 而已，所以如果是大型项目想要一套完整的框架的话，也许还需要引入 Redux 和 route 相关的东西。

**vue,react 共性：**

1.虚拟 dom 实现快速渲染轻量级响应式组件服务端渲染易于集成路由工具，打包工具及状态管理工具

## 什么是 mvvm

MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 JavaScript 对象表示，View 负责显示，两者做到了最大限度的分离 把 Model 和 View 关联起来的就是 ViewModel。 ViewModel 负责把 Model 的数据同步到 View 显示出来，还负责把 View 的修改同步回 Model View 和 Model 之间的同步工作完全是自动的，无需人为干涉（由 viewModel 完成，在这里指 VUE）因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理
