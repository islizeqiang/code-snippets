[TOC]

## XSS 攻击(跨站脚本)

全称是 Cross Site Scripting。是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。

> XSS 即 Cross Site Scripting（跨站脚本），指的是通过利用网页开发时留下的漏洞，注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。常见的例如在评论区植入 JS 代码，用户进入评论页时代码被执行，造成页面被植入广告、账号信息被窃取

实现：

- 存储型。常见例子在留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中`直接执行`

- 反射型。通过作为网络请求的参数，经过服务器，然后再反射到 HTML 文档中，执行解析。
- 文档型。作为中间人的角色，在数据传输过程劫持到网络数据包，然后**修改里面的 html 文档**！

防范：

- 一个信念: 不要相信用户的输入，对输入内容转码或者过滤，让其不可执行。
- 两个利用:
  1. 利用 CSP，即开启白名单，可阻止白名单以外的资源加载和运行
  2. 利用 Cookie 的 HttpOnly 属性。
     - 很多 XSS 攻击脚本都是用来窃取 Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。

## CSRF 攻击(跨站请求伪造)

全称是 Cross-site request forgery。是指利用服务器的验证漏洞和**用户之前的登录状态**来模拟用户进行操作

> CSRF 即 Cross-site request forgery(跨站请求伪造)，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。

实现：

- 自动 GET 请求
- 自动 POST 请求
- 诱导点击发送 GET 请求。

防范：

- 利用 Cookie 的 SameSite 属性。其可以设置三个值，当设置 Strict 时，完全禁止第三方请求携带 Cookie，只允许相同站点下才能携带 Cookie。但浏览器兼容不一。

- 验证来源站点，Origin 只包含域名信息，Referer 包含具体的 URL 路径，但两者都可在请求时伪造。
- 携带 Token，浏览器请求服务器时，服务器返回一个 token，每个请求都需要同时带上 token 和 cookie 才会被认为是合法请求

## cookie 和 token 都存放在 header 中，为什么不会劫持 token？

1、首先 token 不是防止 XSS 的，而是为了防止 CSRF 的；

2、CSRF 攻击的原因是浏览器会自动带上 cookie，而浏览器不会自动带上 token

> cookie：登陆后后端生成一个 sessionid 放在 cookie 中返回给客户端，并且服务端一直记录着这个 sessionid，客户端以后每次请求都会带上这个 sessionid，服务端通过这个 sessionid 来验证身份之类的操作。所以别人拿到了 cookie 拿到了 sessionid 后，就可以完全替代你。

> token：登陆后后端不返回一个 token 给客户端，客户端将这个 token 存储起来，然后每次客户端请求都需要开发者手动将 token 放在 header 中带过去，服务端每次只需要对这个 token 进行验证就能使用 token 中的信息来进行下一步操作了。

> xss：用户通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求，之类的操作。

> csrf：跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：**简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的**。csrf 并不能够拿到用户的任何信息，它只是欺骗用户浏览器，让其以用户的名义进行操作。

> csrf 例子：假如一家银行用以运行转账操作的 URL 地址如下： http://www.examplebank.com/withdraw?account=AccoutName&amount=1000&for=PayeeName 那么，一个恶意攻击者可以在另一个网站上放置如下代码： `<img src="<http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman>">` 如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 资金。

上面的两种攻击方式，如果被 xss 攻击了，不管是 token 还是 cookie，都能被拿到，所以对于 xss 攻击来说，cookie 和 token 没有什么区别。但是对于 csrf 来说就有区别了。

以上面的 csrf 攻击为例：

- cookie：用户点击了链接，cookie 未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作。
- token：用户点击链接，由于浏览器不会自动带上 token，所以即使发了请求，后端的 token 验证不会通过，所以不会进行扣款操作。

这是个人理解的为什么只劫持 cookie 不劫持 token 的原因。

## 介绍下如何实现 token 加密

1. 需要一个 secret（随机数）
2. 后端利用 secret（随机数） 和加密算法(如：HMAC-SHA256)对 payload(如账号密码)生成一个字符串(token)，返回前端
3. 前端每次 request 在 header 中带上 token
4. 后端用同样的算法解密

## 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？

1. 能够完成整个 HTTP 请求+响应（尽管不需要响应内容）
2. 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据
3. 跨域友好（img 天然支持跨域）
4. 执行过程无阻塞
5. 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好
6. GIF 的最低合法体积最小（最小的 BMP 文件需要 74 个字节，PNG 需要 67 个字节，而合法的 GIF，只需要 43 个字节）

## 浏览器缓存策略

缓存策略都是通过设置 HTTP Header 来实现的。浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。

浏览器中的缓存作用分为两种情况，一种是需要发送`HTTP`请求，一种是不需要发送。

#### 强缓存（不需要发送 HTTP）

- **Expires** **存在于 HTTP 1**

  `Expires`即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。表示资源在`2019年11月22号8点41分`过期，过期了就得向服务端发请求。

  ```reStructuredText
  Expires: Wed, 22 Nov 2019 08:41:00 GMT
  ```

  缺点：服务器的时间和浏览器的时间可能并不一致导致这个过期时间就是不准确的。也可能用户修改本地时间，也会失效。

- **Cache-Control** **存在于 HTTP 1.1**

  它和`Expires`本质的不同在于它并没有采用`具体的过期时间点`这个方式，而是采用过期时间来控制缓存，对应的字段是**max-age**。代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。

  ```reStructuredText
  Cache-Control: max-age=3600
  ```

  它可以组合很多指令

  ![img](https://pic4.zhimg.com/80/v2-25f787baf5cbdb3bfa91fc41c5618e97_720w.jpg)

值得注意的是，当**Expires**和**Cache-Control**同时存在的时候，**Cache-Control**会优先考虑。

#### 协商缓存 需要发送 HTTP 由服务器决定是否采用

协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

- 协商缓存生效，返回 304 和 Not Modified
- 协商缓存失效，返回 200 和请求结果

协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

- Last-Modified 和 If-Modified-Since

  即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

  浏览器接收到后，如果第二次再发起这个请求，则会在请求头中携带`If-Modified-Since`字段，值就是 Last-Modified 中的值。

  服务器拿到请求头中的`If-Modified-Since`的字段后，会和这个服务器中`该资源的最后修改时间`对比:

  - 如果请求头中的这个值小于最后修改时间，说明有更新。返回新的资源和 200，跟常规的 HTTP 请求响应的流程一样。
  - 如果没有变化则返回 304 和空的响应体，告诉浏览器直接用缓存。

  缺点：

- ETag 和 If-None-Match

  `ETag` 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过`响应头`把这个值给浏览器。

  浏览器接收到`ETag`的值，会在下次请求时，将这个值作为**If-None-Match**这个字段的内容，并放到请求头中，然后发给服务器。

  服务器接收到**If-None-Match**后，会跟服务器上该资源的**ETag**进行比对:

  - 如果两者不一样，说明要更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。
  - 否则返回 304，告诉浏览器直接用缓存。

#### 两者对比

1. 在`精准度`上，`ETag`优于`Last-Modified`。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:
   - 如果本地打开或编辑了缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
   - 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源
2. 在性能上，`Last-Modified`优于`ETag`，也很简单理解，`Last-Modified`仅仅只是记录一个时间点，而 `Etag`需要根据文件的具体内容生成哈希值。

另外，如果两种方式都支持的话，服务器会优先考虑`ETag`。

#### 缓存位置

前面我们已经提到，当`强缓存`命中或者协商缓存中服务器返回 304 的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

1. Service Worker

   Service Worker 借鉴了 Web Worker 的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问`DOM`。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如`离线缓存`、`消息推送`和`网络代理`等功能。Service Worker 同时也是 PWA 的重要实现机制。

2. Memory Cache

   **Memory Cache**指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当进程结束后，内存缓存也就不存在了。

3. Disk Cache

   **Disk Cache**就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。

   - 比较大的 JS、CSS 文件会直接被丢进磁盘，反之丢进内存

- 内存使用率比较高的时候，文件优先进入磁盘

4. Push Cache

   即推送缓存，这是浏览器缓存的最后一道防线。它是 `HTTP/2` 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。

#### 总结

对浏览器的缓存机制来做个简要的总结:

首先通过 `Cache-Control` 验证强缓存是否可用

- 如果强缓存可用，直接使用

- 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的

  ```
  If-Modified-Since
  ```

  或者

  ```
  If-None-Match
  ```

  这些条件请求字段检查资源是否更新

  - 若资源更新，返回资源和 200 状态码
  - 否则，返回 304，告诉浏览器直接从缓存获取资源
  - 如果什么缓存策略都没有设置，那么浏览器会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间

![img](https://user-gold-cdn.xitu.io/2020/4/5/1714a298b93c3208?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 能不能说一说浏览器的本地存储？各自优劣如何？

#### Cookie

由于 HTTP 协议是无状态协议，Cookie 最开始是为了做状态存储的。

缺点

1. 容量缺陷。Cookie 的体积上限只有`4KB`，只能用来存储少量的信息。
2. 性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。
3. 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在`HttpOnly`为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

#### localStorage

- 和 Cookie 异同

`localStorage`有一点跟`Cookie`一样，就是针对一个域名，即在同一个域名下，会存储相同的一段**localStorage**。

不过它相对`Cookie`还是有相当多的区别的:

1. 容量。localStorage 的容量上限为**5M**，相比于`Cookie`的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。
2. 只存在客户端，默认不参与服务端的通信。这样就很好地避免了 Cookie 带来的**性能问题**和**安全问题**。
3. 接口封装。通过`localStorage`暴露在全局，并通过它的 `setItem` 和 `getItem`等方法进行操作，非常方便

- 应用场景

利用`localStorage`的较大容量和持久特性，可以利用`localStorage`存储一些内容稳定的资源，比如官网的`logo`，存储`Base64`格式的图片资源，因此利用`localStorage`

#### sessionStorage

- 特点

  `sessionStorage`以下方面和`localStorage`一致:

  - 容量。容量上限也为 5M。
  - 只存在客户端，默认不参与与服务端的通信。
  - 接口封装。除了`sessionStorage`名字有所变化，存储方式、操作方式均和`localStorage`一样。

  但`sessionStorage`和`localStorage`有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分`sessionStorage`就不复存在了。

- 应用场景
  1. 可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
  2. 可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用`sessionStorage`就再合适不过了。事实上微博就采取了这样的存储方式。

#### IndexDB

`IndexDB`是运行在浏览器中的`非关系型数据库`, 本质上是数据库，绝不是和刚才 WebStorage 的 5M 一个量级，理论上这个容量是没有上限的。

## 实现图片懒加载

1. 给 scroll 添加监听事件，进行节流处理，通过 clientHeight、scrollTop 和 offsetTop 判断元素是否出现在视图中

2. 给 scroll 添加监听事件，进行节流处理，通过 getBoundingClientRect 判断元素是否出现在视图中

3. 采用 IntersectionObserver API，其可以实现监听 window 的 scroll 事件，判断是否在视图中及节流功能

   ```js
   let img = document.document.getElementsByTagName('img');

   const observer = new IntersectionObserver((changes) => {
     //changes 是被观察的元素集合
     for (let i = 0, len = changes.length; i < len; i++) {
       let change = changes[i];
       // 通过这个属性判断是否在视口中
       if (change.isIntersecting) {
         const imgElement = change.target;
         imgElement.src = imgElement.getAttribute('data-src');
         observer.unobserve(imgElement);
       }
     }
   });

   observer.observe(img);
   ```

## 做过 H5 页面没有？你怎样适配移动端的

在程序初始化的时候可以使用以下方式来修改根节点的字体大小：

(假设你需要的`1rem = 20px`)

```js
(function () {
  var html = document.documentElement;
  function onWindowResize() {
    html.style.fontSize = html.getBoundingClientRect().width / 20 + 'px';
  }
  window.addEventListener('resize', onWindowResize);
  onWindowResize();
})();
```

- `document.documentElement`：获取`document`的根元素
- `html.getBoundingClientRect().width`：获取`html`的宽度(窗口的宽度)
- 监听`window`的`resize`事件

一般还需要配合一个`meta`头：

```html
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, minimum-sacle=1.0, maximum-scale=1.0, user-scalable=no"
/>
```

## addEventListener 函数的第三个参数

指定有关 listener 属性的可选参数对象。

- once 表示添加后只执行一次，执行完会被移除。
- passive 表示该 listener 永远不会冒泡 （即永远不会调用 preventDefault()）
- capture 表示 listener 会在该类型的事件捕获阶段传播到 EventTarget 时触发

## 所有的事件都有冒泡吗？

并不是所有的事件都有冒泡的，例如以下事件就没有：

- `onblur`
- `onfocus`
- `onmouseenter`
- `onmouseleave`

## DOM 事件捕获

具体流程捕获的流程为：window -> document -> html -> body -> ... -> 目标元素。

冒泡的流程为：目标元素 -> ... -> body -> html -> document -> window。

## 事件绑定的方式

- 嵌入 dom

```html
<button onclick="func()">按钮</button>
```

- 直接绑定

```html
btn.onclick = function(){}
```

- 事件监听

```html
btn.addEventListener('click',function(){})
```

## 有写过原生的自定义事件吗

- 使用`Event`
- 使用`customEvent` （可以传参数）
- 使用`document.createEvent('CustomEvent')和initEvent()`

**创建自定义事件**

原生自定义事件有三种写法：

1. 使用`Event`

```js
let myEvent = new Event('event_name');
```

2. 使用`customEvent` （可以传参数）

```js
let myEvent = new CustomEvent('event_name', {
  detail: {
    // 将需要传递的参数放到这里
    // 可以在监听的回调函数中获取到：event.detail
  },
});
```

3. 使用`document.createEvent('CustomEvent')和initEvent()`

```js
let myEvent = document.createEvent('CustomEvent'); // 注意这里是为'CustomEvent'
myEvent
  .initEvent
  // 1. event_name: 事件名称
  // 2. canBubble: 是否冒泡
  // 3. cancelable: 是否可以取消默认行为
  ();
```

- `createEvent`：创建一个事件
- `initEvent`：初始化一个事件

**事件的监听**

自定义事件的监听其实和普通事件的一样，使用`addEventListener`来监听：

```
button.addEventListener('event_name', function (e) {})
复制代码
```

**事件的触发**

触发自定义事件使用`dispatchEvent(myEvent)`。

注意 ⚠️，这里的参数是要自定义事件的对象(也就是`myEvent`)，而不是自定义事件的名称(`'myEvent'`)

**案例**

来看个案例吧：

```js
// 1.
// let myEvent = new Event('myEvent');
// 2.
// let myEvent = new CustomEvent('myEvent', {
//   detail: {
//     name: 'lindaidai'
//   }
// })
// 3.
let myEvent = document.createEvent('CustomEvent');
myEvent.initEvent('myEvent', true, true);

let btn = document.getElementsByTagName('button')[0];
btn.addEventListener('myEvent', function (e) {
  console.log(e);
  console.log(e.detail);
});
setTimeout(() => {
  btn.dispatchEvent(myEvent);
}, 2000);
```

## 事件委托

事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。

## target 和 currentTarget 区别

- event.target 返回触发事件的元素
- event.currentTarget 返回绑定事件的元素

## Event 对象常见应用

- event. preventDefault() 取消事件的默认动作

- event.stopPropagation() 阻止捕获和冒泡阶段中当前事件的进一步传播。

- event.stopImmediatePropagation() 阻止剩下的事件处理程序被执行。如果一个元素上绑定了三个事件，在其中一个事件上调用了这个方法，那其他 的两个事件将不会被执行。

## 为何会出现浏览器兼容问题

渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

处理兼容问题的思路：

1. 产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）

2. 成本的角度 (有无必要做某件事)

   - 做到什么程度，让哪些浏览器支持哪些效果

   - 如何做：根据兼容需求选择技术框架/库(jquery)，可以选择兼容工具(css reset、normalize.css、 条件注释、js 能力检测)做一些修补

页面性能

面试必考，这五个最好都能记住。异步加载和浏览器缓存都会延伸了问，其他三个只要说出来即可。

提升页面性能的方法有哪些？

1. 资源压缩合并，减少 HTTP 请求
2. 非核心代码异步加载（异步加载的方式，异步加载的区别）
3. 利用浏览器缓存（缓存的分类，缓存原理）
4. 使用 CDN
5. 预解析 DNS

```html
// DNS预解析
<link rel="dns-prefetch" href="//host_name_to_prefetch.com" />
```

## 能说说首屏加载优化有哪些方案么

- Vue-Router 路由懒加载（利用 Webpack 的代码切割）
- 使用 CDN 加速，将通用的库从 vendor 进行抽离
- Nginx 的 gzip 压缩
- Vue 异步组件
- 服务端渲染 SSR
- 如果使用了一些 UI 库，采用按需加载
- Webpack 开启 gzip 压缩
- 如果首屏为登录页，可以做成多入口
- Service Worker 缓存文件处理
- 使用 link 标签的 rel 属性设置 prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch 通常用于加速下一次导航）、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）

## 白屏时间

白屏时间是指浏览器从输入网址，到浏览器开始显示内容的时间。

`startTime`：有些浏览器实现为`navigationStart`，代表浏览器开始 unload 前一个页面文档的开始时间节点。比如我们当前正在浏览 baidu.com，在地址栏输入 google.com 并回车，浏览器的执行动作依次为：unload 当前文档（即 baidu.com）->请求下一文档（即 google.com）。navigationStart 的值便是触发 unload 当前文档的时间节点。如果当前文档为空，则 navigationStart 的值等于 fetchStart。

`domLoading`代表浏览器开始解析 html 文档的时间节点。我们知道 IE 浏览器下的 document 有 readyState 属性，domLoading 的值就等于 readyState 改变为 loading 的时间节点；

白屏时间

```js
performance.timing.domLoading -
  (performance.timing.navigationStart || performance.timing.pageStartTime);
```

## 首屏时间

首屏时间：从浏览器输入地址并回车后到首屏内容渲染完毕的时间

`domContentLoadedEventStart`：代表 DOMContentLoaded 事件触发的时间节点： 页面文档完全加载并解析完毕之后,会触发 DOMContentLoaded 事件，HTML 文档不会等待样式文件,图片文件,子框架页面的加载(load 事件可以用来检测 HTML 页面是否完全加载完毕(fully-loaded))。

- 如果页面首屏没有图片

```js
performance.timing.domContentLoadedEventStart - performance.timing.navigationStart;
```

- H5 如果页面首屏有图片可以在每个 img 中添加 onload 时间并绑定到 window 属性上, 等 window.onload 事件触发再进行计算

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>首屏</title>
    <script>
      // 不兼容 performance.timing 的浏览器
      window.pageStartTime = Date.now();
    </script>
  </head>
  <body>
    <img src="https://lz5z.com/assets/img/google_atf.png" alt="img" onload="load()" />
    <img src="https://lz5z.com/assets/img/css3_gpu_speedup.png" alt="img" onload="load()" />
    <script>
      function load() {
        window.firstScreen = Date.now();
      }
      window.onload = function () {
        // 首屏时间
        console.log(window.firstScreen - performance.timing.navigationStart);
      };
    </script>
  </body>
</html>
```

```reStructuredText
首屏图片全部加载完毕的时刻 - performance.timing.navigationStart
```

## 跨域通信的几种方式

- JSONP(利用 script 标签的异步加载实现的)
- WebSocket
- cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息
- 反向代理 nginx 服务内部配置 Access-Control-Allow-Origin \*

## 什么是跨域？浏览器如何拦截响应？如何解决？

回顾一下 URI 的组成:

[![img](http://47.98.159.95/my_blog/http/004.png)](http://47.98.159.95/my_blog/http/004.png)

浏览器遵循**同源政策**(`scheme(协议)`、`host(主机)`和`port(端口)`都相同则为`同源`)。非同源站点有这样一些限制:

- 不能读取和修改对方的 DOM
- 不读访问对方的 Cookie、IndexDB 和 LocalStorage
- 限制 XMLHttpRequest 请求。(后面的话题着重围绕这个)

当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，则产生跨域，被称为`跨域请求`。

跨域请求的响应一般会被浏览器所拦截，注意，是被浏览器拦截，响应其实是成功到达客户端了。那这个拦截是如何发生呢？

首先要知道的是，浏览器是多进程的，以 Chrome 为例，进程组成如下： [![img](http://47.98.159.95/my_blog/http/007.jpg)](http://47.98.159.95/my_blog/http/007.jpg)[![img](http://47.98.159.95/my_blog/http/008.jpg)](http://47.98.159.95/my_blog/http/008.jpg)

**WebKit 渲染引擎**和**V8 引擎**都在渲染进程当中。

当`xhr.send`被调用，即 Ajax 请求准备发送的时候，其实还只是在渲染进程的处理。为了防止黑客通过脚本触碰到系统资源，浏览器将每一个渲染进程装进了沙箱，在沙箱当中的渲染进程是没有办法发送网络请求的，那怎么办？只能通过主进程来发送。利用`Unix Domain Socket`套接字，配合事件驱动的高性能网络并发库`libevent`完成进程的通信过程。好，现在数据传递给了浏览器主进程，主进程接收到后，才真正地发出相应的网络请求。

在服务端处理完数据后，将响应返回，主进程检查到跨域，且没有 cors(后面会详细说)响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。

接下来我们来说一说解决跨域问题的几种方案。

**CORS**

CORS 其实是 W3C 的一个标准，全称是`跨域资源共享`。它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持 CORS，服务器需要附加特定的响应头，后面具体拆解。不过在弄清楚 CORS 的原理之前，我们需要清楚两个概念: **简单请求**和**非简单请求**。

浏览器根据请求方法和请求头的特定字段，将请求做了一下分类，具体来说规则是这样，凡是满足下面条件的属于**简单请求**:

- 请求方法为 GET、POST 或者 HEAD
- 请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`)

浏览器画了这样一个圈，在这个圈里面的就是**简单请求**, 圈外面的就是**非简单请求**，然后针对这两种不同的请求进行不同的处理。

**简单请求**:

请求发出去之前，浏览器做了什么？

它会自动在请求头当中，添加一个`Origin`字段，用来说明请求来自哪个`源`。服务器拿到请求之后，在回应时对应地添加`Access-Control-Allow-Origin`字段，如果`Origin`不在这个字段的范围中，那么浏览器就会将响应拦截。

因此，`Access-Control-Allow-Origin`字段是服务器用来决定浏览器是否拦截这个响应，这是必需的字段。与此同时，其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。

**Access-Control-Allow-Credentials**。这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为`true`, 并且在前端也需要设置`withCredentials`属性:

```js
let xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```

**Access-Control-Expose-Headers**。这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`和`Pragma`）, 还能拿到这个字段声明的**响应头字段**。比如这样设置:

```text
Access-Control-Expose-Headers: aaa
```

那么在前端可以通过 `XMLHttpRequest.getResponseHeader('aaa')` 拿到 `aaa` 这个字段的值。

**非简单请求**

非简单请求相对而言会有些不同，体现在两个方面: **预检请求**和**响应字段**。

我们以 PUT 方法为例。

```js
var url = 'http://xxx.com';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'xxx');
xhr.send();
```

当这段代码执行后，首先会发送**预检请求**。这个预检请求的请求行和请求体是下面这个格式:

```text
OPTIONS / HTTP/1.1
Origin: 当前地址
Host: xxx.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
```

预检请求的方法是`OPTIONS`，同时会加上`Origin`源地址和`Host`目标地址，这很简单。同时也会加上两个关键的字段:

- Access-Control-Request-Method, 列出 CORS 请求用到哪个 HTTP 方法
- Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头

这是`预检请求`。接下来是**响应字段**，响应字段也分为两部分，一部分是对于**预检请求**的响应，一部分是对于 **CORS 请求**的响应。

**预检请求的响应**。如下面的格式:

```text
HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
```

其中有这样几个关键的**响应头字段**:

- Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填`*`表示允许任意源请求。
- Access-Control-Allow-Methods: 表示允许的请求方法列表。
- Access-Control-Allow-Credentials: 简单请求中已经介绍。
- Access-Control-Allow-Headers: 表示允许发送的请求头字段
- Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。

在预检请求的响应返回后，如果请求不满足响应头的条件，则触发`XMLHttpRequest`的`onerror`方法，当然后面真正的**CORS 请求**也不会发出去了。

**CORS 请求的响应**。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和**简单请求**的情况是一样的。浏览器自动加上`Origin`字段，服务端响应头返回**Access-Control-Allow-Origin**。可以参考以上简单请求部分的内容。

**JSONP**

虽然`XMLHttpRequest`对象遵循同源政策，但是`script`标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:

```js
const jsonp = ({ url, params, callbackName }) => {
  const generateURL = (callback) => {
    const allParams = { ...params, callback };
    const dataStr = Object.entries(allParams).reduce((acc, [key, value]) => {
      return `${acc}${key}=${value}&`;
    }, '');
    return `${url}?${dataStr}`;
  };
  return new Promise((resolve) => {
    // 初始化回调函数名称
    const callback = callbackName || `callback${Date.now()}`;
    // 创建 script 元素并加入到当前文档中
    const scriptEle = document.createElement('script');
    scriptEle.src = generateURL(callback);
    document.body.appendChild(scriptEle);
    // 绑定到 window 上，为了后面调用
    window[callback] = (data) => {
      resolve(data);
      // script 执行完了，成为无用元素，需要清除
      document.body.removeChild(scriptEle);
    };
  });
};

jsonp({
  url: 'http://localhost:3000',
  params: {
    a: 1,
    b: 2,
  },
}).then((data) => {
  console.log('data: ', data);
  // 拿到数据进行处理
  // 数据包
});
```

当然在服务端也会有响应的操作, 以 express 为例:

```js
let express = require('express');
let app = express();
app.get('/', function (req, res) {
  let { a, b, callback } = req.query;
  console.log(a); // 1
  console.log(b); // 2
  // 注意哦，返回给script标签，浏览器直接把这部分字符串执行
  res.end(`${callback}('数据包')`);
});
app.listen(3000);
```

和`CORS`相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。

**Nginx**

Nginx 是一种高性能的`反向代理`服务器，可以用来轻松解决跨域问题。

what？反向代理？我给你看一张图你就懂了。

[<img src="http://47.98.159.95/my_blog/http/009.jpg" alt="img" style="zoom:50%;" />](http://47.98.159.95/my_blog/http/009.jpg)

正向代理帮助客户端**访问**客户端自己访问不到的服务器，然后将结果返回给客户端。

反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的**负载均衡**，换句话说，反向代理帮**其它的服务器**拿到请求，然后选择一个合适的服务器，将请求转交给它。

因此，两者的区别就很明显了，正向代理服务器是帮**客户端**做事情，而反向代理服务器是帮其它的**服务器**做事情。

好了，那 Nginx 是如何来解决跨域的呢？

比如说现在客户端的域名为**client.com**，服务器的域名为**server.com**，客户端向服务器发送 Ajax 请求，当然会跨域了，那这个时候让 Nginx 登场了，通过下面这个配置:

```text
server {
  listen  80;
  server_name  client.com;
  location /api {
    proxy_pass server.com;
  }
}
```

Nginx 相当于起了一个跳板机，这个跳板机的域名也是`client.com`，让客户端首先访问 `client.com/api`，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给`server.com`，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。

简答：

首先，跨域只存在于浏览器端，因为我们知道浏览器的形态是很开放的，所以我们需要对它有所限制。

其次，同源策略主要是为了保证用户信息的安全，可分为两种：`Ajax`同源策略和`DOM`同源策略。

`Ajax`同源策略主要是使得不同源的页面不能获取`cookie`且不能发起`Ajax`请求，这样在一定层度上防止了`CSRF`攻击。

`DOM`同源策略也一样，它限制了不同源页面不能获取`DOM`，这样可以防止一些恶意网站在自己的网站中利用`iframe`嵌入正 gui 的网站并迷惑用户，以此来达到窃取用户信息。

**深答**：

- 首先，跨域只存在于浏览器端。浏览器它为`web`提供了访问入口，并且访问的方式很简单，在地址栏输入要访问的地址或者点击某个链接就可以了，正是这种**开放的形态**，所以我们需要对它有所限制。

- 所以同源策略它的产生主要是为了保证用户信息的安全，防止恶意的网站窃取数据。分为两种：`Ajax`同源策略与`DOM`同源策略：

  - `Ajax`同源策略它主要做了这两种限制：1.不同源页面不能获取`cookie`；2.不同源页面不能发起`Ajax`请求。我认为它是防止`CSRF`攻击的一种方式吧。因为我们知道`cookie`这个东西它主要是为了解决浏览器与服务器会话状态的问题，它本质上是存储在浏览器或本地文件中一个小小的文本文件，那么它里面一般都会存储了用户的一些信息，包括隐私信息。如果没有`Ajax`同源策略，恶意网站只需要一段脚本就可以获取你的`cookie`，从而冒充你的身份去给其它网站发送恶意的请求。
  - `DOM`同源策略也一样，它限制了不同源页面不能获取`DOM`。例如一个假的网站利用`iframe`嵌套了一个银行网站[mybank.com]()，并把宽高或者其它部分调整的和原银行网站一样，仅仅只是地址栏上的域名不同，若是用户没有注意的话就以为这个是个真的网站。如果这时候用户在里面输入了账号密码，如果没有同源策略，那么这个恶意网站就可以获取到银行网站中的`DOM`，也就能拿到用户的输入内容以此来达到窃取用户信息的攻击。

  同源策略它算是浏览器安全的第一层屏障吧，因为就像`CSRF`攻击，它只能限制不同源页面`cookie`的获取，但是攻击者还可能通过其它的方式来达到攻击效果。

  ```
  // HTML
  <iframe name="yinhang" src="www.yinhang.com"></iframe>
  // JS
  // 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Dom
  const iframe = window.frames['yinhang']
  const node = iframe.document.getElementById('你输入账号密码的Input')
  console.log(`拿到了这个${node}，我还拿不到你刚刚输入的账号密码吗`)
  ```

## Ajax 和 Fetch 区别

- Ajax 是使用 XMLHttpRequest 对象发起的，但是用起来很麻烦，所以 ES6 新规范就有了 fetch，fetch 发一个请求不用像 ajax 那样写一大堆代码。
- 使用 fetch 无法取消一个请求，这是因为 fetch 基于 Promise，而 Promise 无法做到这一点。
- 在默认情况下，fetch 不会发送 cookies
- fetch 没有办法原生监测请求的进度，而 XMLHttpRequest 可以
- fetch 只对网络请求报错，对 400，500 都当做成功的请求，需要封装去处理
- fetch 由于是 ES6 规范，兼容性上比不上 XMLHttpRequest
