[TOC]

## XSS 攻击(跨站脚本)

全称是 Cross Site Scripting。是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。

> XSS 即 Cross Site Scripting（跨站脚本），指的是通过利用网页开发时留下的漏洞，注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。常见的例如在评论区植入 JS 代码，用户进入评论页时代码被执行，造成页面被植入广告、账号信息被窃取

实现：

- 存储型。常见例子在留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中`直接执行`

- 反射型。通过作为网络请求的参数，经过服务器，然后再反射到 HTML 文档中，执行解析。
- 文档型。作为中间人的角色，在数据传输过程劫持到网络数据包，然后**修改里面的 html 文档**！

防范：

- 一个信念: 不要相信用户的输入，对输入内容转码或者过滤，让其不可执行。
- 两个利用:
  1. 利用 CSP，即开启白名单，可阻止白名单以外的资源加载和运行
  2. 利用 Cookie 的 HttpOnly 属性。
     - 很多 XSS 攻击脚本都是用来窃取 Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。

## CSRF 攻击(跨站请求伪造)

全称是 Cross-site request forgery。是指利用服务器的验证漏洞和**用户之前的登录状态**来模拟用户进行操作

> CSRF 即 Cross-site request forgery(跨站请求伪造)，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。

实现：

- 自动 GET 请求
- 自动 POST 请求
- 诱导点击发送 GET 请求。

防范：

- 利用 Cookie 的 SameSite 属性。其可以设置三个值，当设置 Strict 时，完全禁止第三方请求携带 Cookie，只允许相同站点下才能携带 Cookie。但浏览器兼容不一。

- 验证来源站点，Origin 只包含域名信息，Referer 包含具体的 URL 路径，但两者都可在请求时伪造。
- 携带 Token，浏览器请求服务器时，服务器返回一个 token，每个请求都需要同时带上 token 和 cookie 才会被认为是合法请求

## cookie 和 token 都存放在 header 中，为什么不会劫持 token？

1、首先 token 不是防止 XSS 的，而是为了防止 CSRF 的；

2、CSRF 攻击的原因是浏览器会自动带上 cookie，而浏览器不会自动带上 token

> cookie：登陆后后端生成一个 sessionid 放在 cookie 中返回给客户端，并且服务端一直记录着这个 sessionid，客户端以后每次请求都会带上这个 sessionid，服务端通过这个 sessionid 来验证身份之类的操作。所以别人拿到了 cookie 拿到了 sessionid 后，就可以完全替代你。

> token：登陆后后端不返回一个 token 给客户端，客户端将这个 token 存储起来，然后每次客户端请求都需要开发者手动将 token 放在 header 中带过去，服务端每次只需要对这个 token 进行验证就能使用 token 中的信息来进行下一步操作了。

> xss：用户通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求，之类的操作。

> csrf：跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：**简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的**。csrf 并不能够拿到用户的任何信息，它只是欺骗用户浏览器，让其以用户的名义进行操作。

> csrf 例子：假如一家银行用以运行转账操作的 URL 地址如下： http://www.examplebank.com/withdraw?account=AccoutName&amount=1000&for=PayeeName 那么，一个恶意攻击者可以在另一个网站上放置如下代码： `<img src="<http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman>">` 如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 资金。

上面的两种攻击方式，如果被 xss 攻击了，不管是 token 还是 cookie，都能被拿到，所以对于 xss 攻击来说，cookie 和 token 没有什么区别。但是对于 csrf 来说就有区别了。

以上面的 csrf 攻击为例：

- cookie：用户点击了链接，cookie 未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作。
- token：用户点击链接，由于浏览器不会自动带上 token，所以即使发了请求，后端的 token 验证不会通过，所以不会进行扣款操作。

这是个人理解的为什么只劫持 cookie 不劫持 token 的原因。

## 介绍下如何实现 token 加密

1. 需要一个 secret（随机数）
2. 后端利用 secret 和加密算法(如：HMAC-SHA256)对 payload(如账号密码)生成一个字符串(token)，返回前端
3. 前端每次 request 在 header 中带上 token
4. 后端用同样的算法解密

## 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？

1. 能够完成整个 HTTP 请求+响应（尽管不需要响应内容）
2. 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据
3. 跨域友好（img 天然支持跨域）
4. 执行过程无阻塞
5. 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好
6. GIF 的最低合法体积最小（最小的 BMP 文件需要 74 个字节，PNG 需要 67 个字节，而合法的 GIF，只需要 43 个字节）

## 浏览器缓存策略

缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点

#### 强缓存

浏览器中的缓存作用分为两种情况，一种是需要发送`HTTP`请求，一种是不需要发送。

首先是检查强缓存，这个阶段`不需要`发送 HTTP 请求。

如何来检查呢？通过相应的字段来进行，但是说起这个字段就有点门道了。

在`HTTP/1.0`和`HTTP/1.1`当中，这个字段是不一样的。在早期，也就是`HTTP/1.0`时期，使用的是**Expires**，而`HTTP/1.1`使用的是**Cache-Control**。让我们首先来看看 Expires。

- **Expires**

  `Expires`即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:

  ```js
  Expires: Wed, 22 Nov 2019 08:41:00 GMT
  ```

  表示资源在`2019年11月22号8点41分`过期，过期了就得向服务端发请求。

  这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是**服务器的时间和浏览器的时间可能并不一致**，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的 HTTP1.1 版本中被抛弃了。

- **Cache-Control**

  在 HTTP1.1 中，采用了一个非常关键的字段：`Cache-Control`。这个字段也是存在于

  它和`Expires`本质的不同在于它并没有采用`具体的过期时间点`这个方式，而是采用过期时长来控制缓存，对应的字段是**max-age**。比如这个例子:

  ```js
  Cache-Control:max-age=3600
  ```

  代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。

  如果你觉得它只有`max-age`一个属性的话，那就大错特错了。

  它其实可以组合非常多的指令，完成更多场景的缓存判断, 将一些关键的属性列举如下: **public**: 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的`代理服务器`最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。

  **private**： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。

  **no-cache**: 跳过当前的强缓存，发送 HTTP 请求，即直接进入`协商缓存阶段`。

  **no-store**：非常粗暴，不进行任何形式的缓存。

  **s-maxage**：这和`max-age`长得比较像，但是区别在于 s-maxage 是针对代理服务器的缓存时间。

  **must-revalidate**: 是缓存就会有过期的时候，加上这个字段一旦缓存过期，就必须回到源服务器验证。

  值得注意的是，当**Expires**和**Cache-Control**同时存在的时候，**Cache-Control**会优先考虑。

  当然，还存在一种情况，当资源缓存时间超时了，也就是`强缓存`失效了，接下来怎么办？没错，这样就进入到第二级屏障——**协商缓存**了。

#### 协商缓存

强缓存失效之后，浏览器在请求头中携带相应的`缓存tag`来向服务器发请求，由服务器根据这个 tag，来决定是否使用缓存，这就是**协商缓存**。

具体来说，这样的缓存 tag 分为两种: **Last-Modified** 和 **ETag**。这两者各有优劣，并不存在谁对谁有`绝对的优势`，跟上面强缓存的两个 tag 不一样。

- Last-Modified

  即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

  浏览器接收到后，如果再次请求，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间。

  服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中`该资源的最后修改时间`对比:

  - 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。
  - 否则返回 304，告诉浏览器直接用缓存。

- ETag

  `ETag` 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过`响应头`把这个值给浏览器。

  浏览器接收到`ETag`的值，会在下次请求时，将这个值作为**If-None-Match**这个字段的内容，并放到请求头中，然后发给服务器。

  服务器接收到**If-None-Match**后，会跟服务器上该资源的**ETag**进行比对:

  - 如果两者不一样，说明要更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。
  - 否则返回 304，告诉浏览器直接用缓存。

#### 两者对比

1. 在`精准度`上，`ETag`优于`Last-Modified`。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:
   - 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
   - Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。
2. 在性能上，`Last-Modified`优于`ETag`，也很简单理解，`Last-Modified`仅仅只是记录一个时间点，而 `Etag`需要根据文件的具体内容生成哈希值。

另外，如果两种方式都支持的话，服务器会优先考虑`ETag`。

#### 缓存位置

前面我们已经提到，当`强缓存`命中或者协商缓存中服务器返回 304 的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

1. Service Worker

   Service Worker 借鉴了 Web Worker 的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问`DOM`。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如`离线缓存`、`消息推送`和`网络代理`等功能。其中的`离线缓存`就是 **Service Worker Cache**。

   Service Worker 同时也是 PWA 的重要实现机制，关于它的细节和特性，我们将会在后面的 PWA 的分享中详细介绍。

2. Memory Cache

   **Memory Cache**指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。

3. Disk Cache

   **Disk Cache**就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。稍微有些计算机基础的应该很好理解，就不展开了。

   好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：

   - 比较大的 JS、CSS 文件会直接被丢进磁盘，反之丢进内存
   - 内存使用率比较高的时候，文件优先进入磁盘

4. Push Cache

   即推送缓存，这是浏览器缓存的最后一道防线。它是 `HTTP/2` 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。

#### 总结

对浏览器的缓存机制来做个简要的总结:

首先通过 `Cache-Control` 验证强缓存是否可用

- 如果强缓存可用，直接使用

- 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的

  ```
  If-Modified-Since
  ```

  或者

  ```
  If-None-Match
  ```

  这些条件请求字段检查资源是否更新

  - 若资源更新，返回资源和 200 状态码
  - 否则，返回 304，告诉浏览器直接从缓存获取资源

## 浏览器缓存策略

> 强缓存(不要向服务器询问的缓存)

**设置 Expires**

- 即过期时间，例如`「Expires: Thu, 26 Dec 2019 10:30:42 GMT」`表示缓存会在这个时间后失效，这个过期日期是绝对日期，如果修改了本地日期，或者本地日期与服务器日期不一致，那么将导致缓存过期时间错误。

**设置 Cache-Control**

- HTTP/1.1 新增字段，Cache-Control 可以通过`max-age`字段来设置过期时间，例如`「Cache-Control:max-age=3600」`除此之外 Cache-Control 还能设置`private/no-cache`等多种字段

> 协商缓存(需要向服务器询问缓存是否已经过期)

**Last-Modified**

- 即最后修改时间，浏览器第一次请求资源时，服务器会在响应头上加上`Last-Modified` ，当浏览器再次请求该资源时，浏览器会在请求头中带上`If-Modified-Since` 字段，字段的值就是之前服务器返回的最后修改时间，服务器对比这两个时间，若相同则返回 304，否则返回新资源，并更新 Last-Modified

**ETag**

- HTTP/1.1 新增字段，表示文件唯一标识，只要文件内容改动，ETag 就会重新计算。缓存流程和 Last-Modified 一样：服务器发送 ETag 字段 -> 浏览器再次请求时发送 If-None-Match -> 如果 ETag 值不匹配，说明文件已经改变，返回新资源并更新 ETag，若匹配则返回 304

> 两者对比

- ETag 比 Last-Modified 更准确：如果我们打开文件但并没有修改，Last-Modified 也会改变，并且 Last-Modified 的单位时间为一秒，如果一秒内修改完了文件，那么还是会命中缓存
- 如果什么缓存策略都没有设置，那么浏览器会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间

![img](https://user-gold-cdn.xitu.io/2020/4/5/1714a298b93c3208?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 浏览器缓存策略

缓存策略的分类：

- 强缓存
- 协商缓存

缓存策略都是通过设置 HTTP Header 来实现的。浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。

##### 强缓存

强缓存：不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 Network 选项中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。

1. Expires **缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点**。也就是说，Expires=max-age + 请求时间，需要和 Last-modified 结合使用。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 **Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效**。`Expires: Wed, 22 Oct 2018 08:41:00 GMT`表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。

2. Cache-Control 在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。比如当`Cache-Control:max-age=300`时，则代表在这个请求正确返回时间（浏览器也会记录下来）的 5 分钟内再次加载资源，就会命中强缓存。 Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：

![img](https://pic4.zhimg.com/80/v2-25f787baf5cbdb3bfa91fc41c5618e97_720w.jpg)

3. Expires 和 Cache-Control 两者对比其实这两者差别不大，区别就在于 Expires 是 http1.0 的产物，Cache-Control 是 http1.1 的产物，**两者同时存在的话，Cache-Control 优先级高于 Expires**；在某些不支持 HTTP1.1 的环境下，Expires 就会发挥用处。所以 Expires 其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。

##### 协商缓存

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

- 协商缓存生效，返回 304 和 Not Modified
- 协商缓存失效，返回 200 和请求结果

协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

1. Last-Modified 和 If-Modified-Since 浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header； Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT 复制代码浏览器下一次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是添加 If-Modified-Since 这个 header，值就是 Last-Modified 中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 304 和空的响应体，直接从缓存读取，如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和 200。 **但是 Last-Modified 存在一些弊端：**

- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
- 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 `ETag` 和`If-None-Match`

2. ETag 和 If-None-Match

**Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag 就会重新生成**。

浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 Etag 值放到 request header 里的 If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现 ETag 匹配不上，那么直接以常规 GET 200 回包形式将新的资源（当然也包括了新的 ETag）发给客户端；如果 ETag 是一致的，则直接返回 304 知会客户端直接使用本地缓存即可。

3. 两者之间对比：

- 首先在精确度上，Etag 要优于 Last-Modified。

  Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的 Last- Modified 也有可能不一致。

- 第二在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。

- 第三在优先级上，服务器校验优先考虑 Etag

##### 缓存机制

强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag / If-None-Match)。

协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回 304，继续使用缓存。

##### 强缓存与协商缓存的区别

强缓存与协商缓存的区别可以用下表来表示：

??? 需要查

缓存类型 获取资源形式 状态码 发送请求到服务器

强缓存 从缓存取 200（from cache） 否，直接从缓存取

协商缓存 从缓存取 304（Not Modified）是，通过服务器来告知缓存是否可用用户行为对缓存的影响

用户操作

Expires/Cache-Control Last-Modied/Etag

地址栏回车 有效 有效

页面链接跳转 有效 有效

新开窗口 有效 有效

前进回退 有效 有效

F5 刷新 无效 有效

Ctrl+F5 强制刷新 无效 无效

##### from memory cache 与 from disk cache 对比

在 chrome 浏览器中的控制台 Network 中 size 栏通常会有三种状态

1.from memory cache 2.from disk cache 3.资源本身的大小(如：1.5k)

三种的区别：

- **from memory cache**：字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，不会请求服务器一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现 from memory cache 的情况。
- **from disk cache**：同上类似，此资源是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会 from disk cache
- **资源本身大小数值**：当 http 状态为 200 是实实在在从浏览器获取的资源，当 http 状态为 304 时该数字是与服务端通信报文的大小，并不是该资源本身的大小，该资源是从本地获取的

状态 类型 说明

200 form memory cache 不请求网络资源，资源在内存当中，一般脚本、字体、图片会存在内存中。

200 form disk ceche 不请求网络资源，在磁盘当中，一般非脚本会存在内存当中，如 css 等。

200 资源大小数值 资源大小数值 从服务器下载最新资源。

304 报文大小 请求服务端发现资源没有更新，使用本地资源，即命中协商缓存。

## 能不能说一说浏览器的本地存储？各自优劣如何？

浏览器的本地存储主要分为`Cookie`、`WebStorage`和`IndexDB`, 其中`WebStorage`又可以分为`localStorage`和`sessionStorage`。接下来我们就来一一分析这些本地存储方案。

#### Cookie

`Cookie` 最开始被设计出来其实并不是来做本地存储的，而是为了弥补`HTTP`在**状态管理上的不足**。

`HTTP` 协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？

这种背景下，就产生了 `Cookie`.

Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在 chrome 开发者面板的`Application`这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。

Cookie 的作用很好理解，就是用来做**状态存储**的，但它也是有诸多致命的缺陷的：

1. 容量缺陷。Cookie 的体积上限只有`4KB`，只能用来存储少量的信息。
2. 性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。
3. 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在`HttpOnly`为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

#### localStorage

- 和 Cookie 异同

`localStorage`有一点跟`Cookie`一样，就是针对一个域名，即在同一个域名下，会存储相同的一段**localStorage**。

不过它相对`Cookie`还是有相当多的区别的:

1. 容量。localStorage 的容量上限为**5M**，相比于`Cookie`的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。
2. 只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的**性能问题**和**安全问题**。
3. 接口封装。通过`localStorage`暴露在全局，并通过它的 `setItem` 和 `getItem`等方法进行操作，非常方便。

- 操作方式

接下来我们来具体看看如何来操作`localStorage`。

```js
let obj = { name: 'sanyuan', age: 18 };
localStorage.setItem('name', 'sanyuan');
localStorage.setItem('info', JSON.stringify(obj));
```

接着进入相同的域名时就能拿到相应的值:

```js
let name = localStorage.getItem('name');
let info = JSON.parse(localStorage.getItem('info'));
```

从这里可以看出，`localStorage`其实存储的都是字符串，如果是存储对象需要调用`JSON`的`stringify`方法，并且用`JSON.parse`来解析成对象。

- 应用场景

利用`localStorage`的较大容量和持久特性，可以利用`localStorage`存储一些内容稳定的资源，比如官网的`logo`，存储`Base64`格式的图片资源，因此利用`localStorage`

#### sessionStorage

- 特点

  `sessionStorage`以下方面和`localStorage`一致:

  - 容量。容量上限也为 5M。
  - 只存在客户端，默认不参与与服务端的通信。
  - 接口封装。除了`sessionStorage`名字有所变化，存储方式、操作方式均和`localStorage`一样。

  但`sessionStorage`和`localStorage`有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分`sessionStorage`就不复存在了。

- 应用场景
  1. 可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
  2. 可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用`sessionStorage`就再合适不过了。事实上微博就采取了这样的存储方式。

#### IndexDB

`IndexDB`是运行在浏览器中的`非关系型数据库`, 本质上是数据库，绝不是和刚才 WebStorage 的 5M 一个量级，理论上这个容量是没有上限的。

接着我们来分析一下`IndexDB`的一些重要特性，除了拥有数据库本身的特性，比如`支持事务`，`存储二进制数据`，还有这样一些特性需要格外注意：

1. 键值对存储。内部采用`对象仓库`存放数据，在这个对象仓库中数据采用**键值对**的方式来存储。
2. 异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。
3. 受同源策略限制，即无法访问跨域的数据库。

#### 总结

浏览器中各种本地存储和缓存技术的发展，给前端应用带来了大量的机会，PWA 也正是依托了这些优秀的存储方案才得以发展起来。重新梳理一下这些本地存储方案:

1. `cookie`并不适合存储，而且存在非常多的缺陷。
2. `Web Storage`包括`localStorage`和`sessionStorage`, 默认不会参与和服务器的通信。
3. `IndexDB`为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口。

## 实现图片懒加载

1. 给 scroll 添加监听事件，进行节流处理，通过 clientHeight、scrollTop 和 offsetTop 判断元素是否出现在视图中

2. 给 scroll 添加监听事件，进行节流处理，通过 getBoundingClientRect 判断元素是否出现在视图中

3. 采用 IntersectionObserver API，其可以实现监听 window 的 scroll 事件，判断是否在视图中及节流功能

   ```js
   let img = document.document.getElementsByTagName('img');

   const observer = new IntersectionObserver((changes) => {
     //changes 是被观察的元素集合
     for (let i = 0, len = changes.length; i < len; i++) {
       let change = changes[i];
       // 通过这个属性判断是否在视口中
       if (change.isIntersecting) {
         const imgElement = change.target;
         imgElement.src = imgElement.getAttribute('data-src');
         observer.unobserve(imgElement);
       }
     }
   });

   observer.observe(img);
   ```

## 什么是 Graphql

GraphQL 是一种 API 查询语言。API 接口的返回值可以从静态变为动态，即调用者来声明接口返回什么数据，可以进一步解耦前后端。在 Graphal 中，预先定义 Schema 和声明 Type 来达到动态获取接口数据的目的：

## 做过 H5 页面没有？你怎样适配移动端的

做的少，然后我提到了在程序初始化的时候可以使用以下方式来修改根节点的字体大小：

(假设你需要的`1rem = 20px`)

```
(function () {
  var html = document.documentElement;
  function onWindowResize() {
    html.style.fontSize = html.getBoundingClientRect().width / 20 + 'px';
  }
  window.addEventListener('resize', onWindowResize);
  onWindowResize();
})();
```

- `document.documentElement`：获取`document`的根元素
- `html.getBoundingClientRect().width`：获取`html`的宽度(窗口的宽度)
- 监听`window`的`resize`事件

一般还需要配合一个`meta`头：

```
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-sacle=1.0, maximum-scale=1.0, user-scalable=no" />
```

## 点击一个 input 依次触发的事件

```js
const text = document.getElementById('text');
text.onclick = function (e) {
  console.log('onclick');
};
text.onfocus = function (e) {
  console.log('onfocus');
};
text.onmousedown = function (e) {
  console.log('onmousedown');
};
text.onmouseenter = function (e) {
  console.log('onmouseenter');
};
// 'onmouseenter'
// 'onmousedown'
// 'onfocus'
// 'onclick'
```

## addEventListener 函数的第三个参数

第三个参数涉及到冒泡和捕获，是`true`时为捕获，是`false`则为冒泡。

或者是一个对象`{passive: true}`，针对的是`Safari`浏览器，禁止/开启使用滚动的时候要用到。

## 有写过原生的自定义事件吗

- 使用`Event`
- 使用`customEvent` （可以传参数）
- 使用`document.createEvent('CustomEvent')和initEvent()`

**创建自定义事件**

原生自定义事件有三种写法：

1. 使用`Event`

```js
let myEvent = new Event('event_name');
```

2. 使用`customEvent` （可以传参数）

```js
let myEvent = new CustomEvent('event_name', {
  detail: {
    // 将需要传递的参数放到这里
    // 可以在监听的回调函数中获取到：event.detail
  },
});
```

3. 使用`document.createEvent('CustomEvent')和initEvent()`

```js
let myEvent = document.createEvent('CustomEvent'); // 注意这里是为'CustomEvent'
myEvent
  .initEvent
  // 1. event_name: 事件名称
  // 2. canBubble: 是否冒泡
  // 3. cancelable: 是否可以取消默认行为
  ();
```

- `createEvent`：创建一个事件
- `initEvent`：初始化一个事件

**事件的监听**

自定义事件的监听其实和普通事件的一样，使用`addEventListener`来监听：

```
button.addEventListener('event_name', function (e) {})
复制代码
```

**事件的触发**

触发自定义事件使用`dispatchEvent(myEvent)`。

注意 ⚠️，这里的参数是要自定义事件的对象(也就是`myEvent`)，而不是自定义事件的名称(`'myEvent'`)

**案例**

来看个案例吧：

```js
// 1.
// let myEvent = new Event('myEvent');
// 2.
// let myEvent = new CustomEvent('myEvent', {
//   detail: {
//     name: 'lindaidai'
//   }
// })
// 3.
let myEvent = document.createEvent('CustomEvent');
myEvent.initEvent('myEvent', true, true);

let btn = document.getElementsByTagName('button')[0];
btn.addEventListener('myEvent', function (e) {
  console.log(e);
  console.log(e.detail);
});
setTimeout(() => {
  btn.dispatchEvent(myEvent);
}, 2000);
```

## 所有的事件都有冒泡吗？

并不是所有的事件都有冒泡的，例如以下事件就没有：

- `onblur`
- `onfocus`
- `onmouseenter`
- `onmouseleave`

## DOM 事件捕获

具体流程捕获的流程为：window -> document -> html -> body -> ... -> 目标元素。

冒泡的流程为：目标元素 -> ... -> body -> html -> document -> window。

## 事件绑定的方式

- 嵌入 dom

```html
<button onclick="func()">按钮</button>
```

- 直接绑定

```html
btn.onclick = function(){}
```

- 事件监听

```html
btn.addEventListener('click',function(){})
```

## 事件委托

事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。

## target 和 currentTarget 区别

- event.target 返回触发事件的元素
- event.currentTarget 返回绑定事件的元素

## Event 对象常见应用

- event. preventDefault() 取消事件的默认动作

- event.stopPropagation() 阻止事件冒泡

- event.stopImmediatePropagation() 阻止剩下的事件处理程序被执行。如果一个元素上绑定了三个事件，在其中一个事件上调用了这个方法，那其他 的两个事件将不会被执行。

## 前端错误分类

前端错误分为两大类：

- 即时运行错误（代码错误）
- 资源加载错误

## 错误的捕获方式

即时运行错误的捕获方式

- try...catch
- window.onerror

资源加载错误捕获：

- object.onerror
- performance.getEntries()
- Error 事件捕获

window.onerror 只能捕获即时运行错误，不能捕获资源加载错误，因为资源加载错误不会冒泡。

## 浏览器的渲染过程

这个问题照着这张图讲清楚就好。浏览器拿到 HTML 和 CSS 之后，通过 `HTML Parser` 把 HTML 解析成 `DOM Tree` , 通过 `CSS Parser` 把 CSS 解析成 `Style Rules` 即 CSS 规则，然后 `DOM Tree` 和 CSS 规则 结合起来形成 `Render Tree` 。然后进行布局 Layout 和绘制 Painting，最终 Display 显示在页面上。

![img](https://pic3.zhimg.com/80/v2-cbed1132b3a2e868757c274e54e9e6a6_720w.jpg)

## 浏览器的渲染过程

1. 解析 HTML 生成 DOM 树。
2. 解析 CSS 生成 CSSOM 规则树。
3. 将 DOM 树与 CSSOM 规则树合并在一起生成渲染树。
4. 遍历渲染树开始布局，计算每个节点的位置大小信息。
5. 将渲染树每个节点绘制到屏幕。

## 为何会出现浏览器兼容问题

渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

处理兼容问题的思路：

1. 产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）

2. 成本的角度 (有无必要做某件事)

   - 做到什么程度，让哪些浏览器支持哪些效果

   - 如何做：根据兼容需求选择技术框架/库(jquery)，可以选择兼容工具(css reset、normalize.css、 条件注释、js 能力检测)做一些修补

页面性能

面试必考，这五个最好都能记住。异步加载和浏览器缓存都会延伸了问，其他三个只要说出来即可。

提升页面性能的方法有哪些？

1. 资源压缩合并，减少 HTTP 请求
2. 非核心代码异步加载（异步加载的方式，异步加载的区别）
3. 利用浏览器缓存（缓存的分类，缓存原理）
4. 使用 CDN
5. 预解析 DNS

```html
// 强制打开 <a> 标签的 dns 解析
<meta http-equiv="x-dns-prefetch-controller" content="on">
// DNS预解析
<link rel="dns-prefetch" href="//host_name_to_prefetch.com">
```

## 能说说首屏加载优化有哪些方案么

- Vue-Router 路由懒加载（利用 Webpack 的代码切割）
- 使用 CDN 加速，将通用的库从 vendor 进行抽离
- Nginx 的 gzip 压缩
- Vue 异步组件
- 服务端渲染 SSR
- 如果使用了一些 UI 库，采用按需加载
- Webpack 开启 gzip 压缩
- 如果首屏为登录页，可以做成多入口
- Service Worker 缓存文件处理
- 使用 link 标签的 rel 属性设置 prefetch（这段资源将会在未来某个导航或者功能要用到，但是本资源的下载顺序权重比较低，prefetch 通常用于加速下一次导航）、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）

## 白屏时间

白屏时间是指浏览器从输入网址，到浏览器开始显示内容的时间。

`startTime`：有些浏览器实现为`navigationStart`，代表浏览器开始 unload 前一个页面文档的开始时间节点。比如我们当前正在浏览 baidu.com，在地址栏输入 google.com 并回车，浏览器的执行动作依次为：unload 当前文档（即 baidu.com）->请求下一文档（即 google.com）。navigationStart 的值便是触发 unload 当前文档的时间节点。如果当前文档为空，则 navigationStart 的值等于 fetchStart。

`domLoading`代表浏览器开始解析 html 文档的时间节点。我们知道 IE 浏览器下的 document 有 readyState 属性，domLoading 的值就等于 readyState 改变为 loading 的时间节点；

白屏时间

```js
performance.timing.domLoading -
  (performance.timing.navigationStart || performance.timing.pageStartTime);
```

## 首屏时间

首屏时间：从浏览器输入地址并回车后到首屏内容渲染完毕的时间

`domContentLoadedEventStart`：代表 DOMContentLoaded 事件触发的时间节点： 页面文档完全加载并解析完毕之后,会触发 DOMContentLoaded 事件，HTML 文档不会等待样式文件,图片文件,子框架页面的加载(load 事件可以用来检测 HTML 页面是否完全加载完毕(fully-loaded))。

- 如果页面首屏没有图片

```js
performance.timing.domContentLoadedEventStart - performance.timing.navigationStart;
```

- H5 如果页面首屏有图片可以在每个 img 中添加 onload 时间并绑定到 window 属性上, 等 window.onload 事件触发再进行计算

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>首屏</title>
    <script>
      // 不兼容 performance.timing 的浏览器
      window.pageStartTime = Date.now();
    </script>
  </head>
  <body>
    <img src="https://lz5z.com/assets/img/google_atf.png" alt="img" onload="load()" />
    <img src="https://lz5z.com/assets/img/css3_gpu_speedup.png" alt="img" onload="load()" />
    <script>
      function load() {
        window.firstScreen = Date.now();
      }
      window.onload = function () {
        // 首屏时间
        console.log(window.firstScreen - performance.timing.navigationStart);
      };
    </script>
  </body>
</html>
```

```reStructuredText
首屏图片全部加载完毕的时刻 - performance.timing.navigationStart
```

## 同源策略及限制

同源策略可防止 JavaScript 发起跨域请求。源被定义为 URI、主机名和端口号的组合。此策略可防止页面上的恶意脚本通过该页面的文档对象模型，访问另一个网页上的敏感数据。

- Cookie、LocalStorage、IndexDB 无法获取

- DOM 无法获取

- Ajax 请求不能发送(Ajax 只限于同源使用，不能跨域使用)

## 跨域通信的几种方式

- JSONP(利用 script 标签的异步加载实现的)
- Hash（window.location.hash + iframe）
- postMessage (H5 中新增的)
- WebSocket
- cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息
- 反向代理 nginx 服务内部配置 Access-Control-Allow-Origin \*

## 什么是跨域？浏览器如何拦截响应？如何解决？

回顾一下 URI 的组成:

[![img](http://47.98.159.95/my_blog/http/004.png)](http://47.98.159.95/my_blog/http/004.png)

浏览器遵循**同源政策**(`scheme(协议)`、`host(主机)`和`port(端口)`都相同则为`同源`)。非同源站点有这样一些限制:

- 不能读取和修改对方的 DOM
- 不读访问对方的 Cookie、IndexDB 和 LocalStorage
- 限制 XMLHttpRequest 请求。(后面的话题着重围绕这个)

当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，则产生跨域，被称为`跨域请求`。

跨域请求的响应一般会被浏览器所拦截，注意，是被浏览器拦截，响应其实是成功到达客户端了。那这个拦截是如何发生呢？

首先要知道的是，浏览器是多进程的，以 Chrome 为例，进程组成如下： [![img](http://47.98.159.95/my_blog/http/007.jpg)](http://47.98.159.95/my_blog/http/007.jpg)[![img](http://47.98.159.95/my_blog/http/008.jpg)](http://47.98.159.95/my_blog/http/008.jpg)

**WebKit 渲染引擎**和**V8 引擎**都在渲染进程当中。

当`xhr.send`被调用，即 Ajax 请求准备发送的时候，其实还只是在渲染进程的处理。为了防止黑客通过脚本触碰到系统资源，浏览器将每一个渲染进程装进了沙箱，在沙箱当中的渲染进程是没有办法发送网络请求的，那怎么办？只能通过主进程来发送。利用`Unix Domain Socket`套接字，配合事件驱动的高性能网络并发库`libevent`完成进程的通信过程。好，现在数据传递给了浏览器主进程，主进程接收到后，才真正地发出相应的网络请求。

在服务端处理完数据后，将响应返回，主进程检查到跨域，且没有 cors(后面会详细说)响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。

接下来我们来说一说解决跨域问题的几种方案。

**CORS**

CORS 其实是 W3C 的一个标准，全称是`跨域资源共享`。它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持 CORS，服务器需要附加特定的响应头，后面具体拆解。不过在弄清楚 CORS 的原理之前，我们需要清楚两个概念: **简单请求**和**非简单请求**。

浏览器根据请求方法和请求头的特定字段，将请求做了一下分类，具体来说规则是这样，凡是满足下面条件的属于**简单请求**:

- 请求方法为 GET、POST 或者 HEAD
- 请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`)

浏览器画了这样一个圈，在这个圈里面的就是**简单请求**, 圈外面的就是**非简单请求**，然后针对这两种不同的请求进行不同的处理。

**简单请求**:

请求发出去之前，浏览器做了什么？

它会自动在请求头当中，添加一个`Origin`字段，用来说明请求来自哪个`源`。服务器拿到请求之后，在回应时对应地添加`Access-Control-Allow-Origin`字段，如果`Origin`不在这个字段的范围中，那么浏览器就会将响应拦截。

因此，`Access-Control-Allow-Origin`字段是服务器用来决定浏览器是否拦截这个响应，这是必需的字段。与此同时，其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。

**Access-Control-Allow-Credentials**。这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为`true`, 并且在前端也需要设置`withCredentials`属性:

```js
let xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```

**Access-Control-Expose-Headers**。这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`和`Pragma`）, 还能拿到这个字段声明的**响应头字段**。比如这样设置:

```text
Access-Control-Expose-Headers: aaa
```

那么在前端可以通过 `XMLHttpRequest.getResponseHeader('aaa')` 拿到 `aaa` 这个字段的值。

**非简单请求**

非简单请求相对而言会有些不同，体现在两个方面: **预检请求**和**响应字段**。

我们以 PUT 方法为例。

```js
var url = 'http://xxx.com';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'xxx');
xhr.send();
```

当这段代码执行后，首先会发送**预检请求**。这个预检请求的请求行和请求体是下面这个格式:

```text
OPTIONS / HTTP/1.1
Origin: 当前地址
Host: xxx.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
```

预检请求的方法是`OPTIONS`，同时会加上`Origin`源地址和`Host`目标地址，这很简单。同时也会加上两个关键的字段:

- Access-Control-Request-Method, 列出 CORS 请求用到哪个 HTTP 方法
- Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头

这是`预检请求`。接下来是**响应字段**，响应字段也分为两部分，一部分是对于**预检请求**的响应，一部分是对于 **CORS 请求**的响应。

**预检请求的响应**。如下面的格式:

```text
HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
```

其中有这样几个关键的**响应头字段**:

- Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填`*`表示允许任意源请求。
- Access-Control-Allow-Methods: 表示允许的请求方法列表。
- Access-Control-Allow-Credentials: 简单请求中已经介绍。
- Access-Control-Allow-Headers: 表示允许发送的请求头字段
- Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。

在预检请求的响应返回后，如果请求不满足响应头的条件，则触发`XMLHttpRequest`的`onerror`方法，当然后面真正的**CORS 请求**也不会发出去了。

**CORS 请求的响应**。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和**简单请求**的情况是一样的。浏览器自动加上`Origin`字段，服务端响应头返回**Access-Control-Allow-Origin**。可以参考以上简单请求部分的内容。

**JSONP**

虽然`XMLHttpRequest`对象遵循同源政策，但是`script`标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:

```js
const jsonp = ({ url, params, callbackName }) => {
  const generateURL = (callback) => {
    const allParams = { ...params, callback };
    const dataStr = Object.entries(allParams).reduce((acc, [key, value]) => {
      return `${acc}${key}=${value}&`;
    }, '');
    return `${url}?${dataStr}`;
  };
  return new Promise((resolve) => {
    // 初始化回调函数名称
    const callback = callbackName || `callback${Date.now()}`;
    // 创建 script 元素并加入到当前文档中
    const scriptEle = document.createElement('script');
    scriptEle.src = generateURL(callback);
    document.body.appendChild(scriptEle);
    // 绑定到 window 上，为了后面调用
    window[callback] = (data) => {
      resolve(data);
      // script 执行完了，成为无用元素，需要清除
      document.body.removeChild(scriptEle);
    };
  });
};

jsonp({
  url: 'http://localhost:3000',
  params: {
    a: 1,
    b: 2,
  },
}).then((data) => {
  console.log('data: ', data);
  // 拿到数据进行处理
  // 数据包
});
```

当然在服务端也会有响应的操作, 以 express 为例:

```js
let express = require('express');
let app = express();
app.get('/', function (req, res) {
  let { a, b, callback } = req.query;
  console.log(a); // 1
  console.log(b); // 2
  // 注意哦，返回给script标签，浏览器直接把这部分字符串执行
  res.end(`${callback}('数据包')`);
});
app.listen(3000);
```

和`CORS`相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。

**Nginx**

Nginx 是一种高性能的`反向代理`服务器，可以用来轻松解决跨域问题。

what？反向代理？我给你看一张图你就懂了。

[<img src="http://47.98.159.95/my_blog/http/009.jpg" alt="img" style="zoom:50%;" />](http://47.98.159.95/my_blog/http/009.jpg)

正向代理帮助客户端**访问**客户端自己访问不到的服务器，然后将结果返回给客户端。

反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的**负载均衡**，换句话说，反向代理帮**其它的服务器**拿到请求，然后选择一个合适的服务器，将请求转交给它。

因此，两者的区别就很明显了，正向代理服务器是帮**客户端**做事情，而反向代理服务器是帮其它的**服务器**做事情。

好了，那 Nginx 是如何来解决跨域的呢？

比如说现在客户端的域名为**client.com**，服务器的域名为**server.com**，客户端向服务器发送 Ajax 请求，当然会跨域了，那这个时候让 Nginx 登场了，通过下面这个配置:

```text
server {
  listen  80;
  server_name  client.com;
  location /api {
    proxy_pass server.com;
  }
}
```

Nginx 相当于起了一个跳板机，这个跳板机的域名也是`client.com`，让客户端首先访问 `client.com/api`，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给`server.com`，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。

简答：

首先，跨域只存在于浏览器端，因为我们知道浏览器的形态是很开放的，所以我们需要对它有所限制。

其次，同源策略主要是为了保证用户信息的安全，可分为两种：`Ajax`同源策略和`DOM`同源策略。

`Ajax`同源策略主要是使得不同源的页面不能获取`cookie`且不能发起`Ajax`请求，这样在一定层度上防止了`CSRF`攻击。

`DOM`同源策略也一样，它限制了不同源页面不能获取`DOM`，这样可以防止一些恶意网站在自己的网站中利用`iframe`嵌入正 gui 的网站并迷惑用户，以此来达到窃取用户信息。

**深答**：

- 首先，跨域只存在于浏览器端。浏览器它为`web`提供了访问入口，并且访问的方式很简单，在地址栏输入要访问的地址或者点击某个链接就可以了，正是这种**开放的形态**，所以我们需要对它有所限制。

- 所以同源策略它的产生主要是为了保证用户信息的安全，防止恶意的网站窃取数据。分为两种：`Ajax`同源策略与`DOM`同源策略：

  - `Ajax`同源策略它主要做了这两种限制：1.不同源页面不能获取`cookie`；2.不同源页面不能发起`Ajax`请求。我认为它是防止`CSRF`攻击的一种方式吧。因为我们知道`cookie`这个东西它主要是为了解决浏览器与服务器会话状态的问题，它本质上是存储在浏览器或本地文件中一个小小的文本文件，那么它里面一般都会存储了用户的一些信息，包括隐私信息。如果没有`Ajax`同源策略，恶意网站只需要一段脚本就可以获取你的`cookie`，从而冒充你的身份去给其它网站发送恶意的请求。
  - `DOM`同源策略也一样，它限制了不同源页面不能获取`DOM`。例如一个假的网站利用`iframe`嵌套了一个银行网站[mybank.com]()，并把宽高或者其它部分调整的和原银行网站一样，仅仅只是地址栏上的域名不同，若是用户没有注意的话就以为这个是个真的网站。如果这时候用户在里面输入了账号密码，如果没有同源策略，那么这个恶意网站就可以获取到银行网站中的`DOM`，也就能拿到用户的输入内容以此来达到窃取用户信息的攻击。

  同源策略它算是浏览器安全的第一层屏障吧，因为就像`CSRF`攻击，它只能限制不同源页面`cookie`的获取，但是攻击者还可能通过其它的方式来达到攻击效果。

  ```
  // HTML
  <iframe name="yinhang" src="www.yinhang.com"></iframe>
  // JS
  // 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Dom
  const iframe = window.frames['yinhang']
  const node = iframe.document.getElementById('你输入账号密码的Input')
  console.log(`拿到了这个${node}，我还拿不到你刚刚输入的账号密码吗`)
  ```
