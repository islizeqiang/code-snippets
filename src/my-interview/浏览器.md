[TOC]

## XSS 攻击(跨站脚本)

 Cross Site Scripting  在浏览器执行恶意脚本。

几种实现

1. 留言评论区提交一段脚本代码，在页面渲染时直接执行
2. 作为中间人身份，截取html，修改内容

防范：

1. 不相信用户的输入，对输入内容转码或者过滤，让其不可执行
2. 利用 CSP，即开启白名单，可阻止白名单以外的资源加载和运行
3. 设置Cookie的HttpOnly属性，使JS无法读取，让攻击者无法读取到Cookie



## CSRF 攻击(跨站请求伪造)

Cross-site request forgery。利用服务器验证漏洞和用户之前的登录状态（Cookie）模拟用户操作。

实现：

- 模拟用户进行恶意攻击操作

防范：

- 利用 Cookie 的 SameSite 属性。其可以设置三个值，当设置 Strict 时，完全禁止第三方请求携带 Cookie，只允许相同站点下才能携带 Cookie。但浏览器兼容不一。
- 验证来源站点，Origin 只包含域名信息，Referer 包含具体的 URL 路径，但两者都可在请求时伪造。
- 携带 Token，浏览器请求服务器时，服务器返回一个 token，每个请求都需要同时带上 token 和 cookie 才会被认为是合法请求



## cookie 和 token 都存放在 header 中，为什么不会劫持 token？

- 首先 token 不是防止 XSS 的，而是为了防止 CSRF 的，因为 浏览器会自动带上cookie，而浏览器不会自动带上 token
- 用户点击链接，Cookie未失效，让后端以为还在登录，进行了操作，而Token需要手动放置。Authorization: xxxx



## 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？

1. 能够完成整个 HTTP 请求+响应（尽管不需要响应内容）
2. 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据
3. 跨域友好（img 天然支持跨域）
4. 执行过程无阻塞
5. 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好
6. GIF 的最低合法体积最小（最小的 BMP 文件需要 74 个字节，PNG 需要 67 个字节，而合法的 GIF，只需要 43 个字节）



## 浏览器缓存策略

缓存策略都是通过设置 HTTP Header 来实现的。浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。

浏览器中的缓存作用分为两种情况，一种是需要发送`HTTP`请求，一种是不需要发送。

#### 强缓存（不需要发送 HTTP）

- **Expires** **存在于 HTTP 1**

  `Expires`即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。表示资源在`2019年11月22号8点41分`过期，过期了就得向服务端发请求。

  ```reStructuredText
  Expires: Wed, 22 Nov 2019 08:41:00 GMT
  ```

  缺点：服务器的时间和浏览器的时间可能并不一致导致这个过期时间就是不准确的。也可能用户修改本地时间，也会失效。

- **Cache-Control** **存在于 HTTP 1.1**

  它和`Expires`本质的不同在于它并没有采用`具体的过期时间点`这个方式，而是采用过期时间来控制缓存，对应的字段是**max-age**。代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。

  ```reStructuredText
  Cache-Control: max-age=3600
  ```

  它可以组合很多指令

  ![img](https://pic4.zhimg.com/80/v2-25f787baf5cbdb3bfa91fc41c5618e97_720w.jpg)

值得注意的是，当**Expires**和**Cache-Control**同时存在的时候，**Cache-Control**会优先考虑。

#### 协商缓存 需要发送 HTTP 由服务器决定是否采用

协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

- 协商缓存生效，返回 304 和 Not Modified
- 协商缓存失效，返回 200 和请求结果

协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

- Last-Modified 和 If-Modified-Since

  即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

  浏览器接收到后，如果第二次再发起这个请求，则会在请求头中携带`If-Modified-Since`字段，值就是 Last-Modified 中的值。

  服务器拿到请求头中的`If-Modified-Since`的字段后，会和这个服务器中`该资源的最后修改时间`对比:

  - 如果请求头中的这个值小于最后修改时间，说明有更新。返回新的资源和 200，跟常规的 HTTP 请求响应的流程一样。
  - 如果没有变化则返回 304 和空的响应体，告诉浏览器直接用缓存。

  缺点：

- ETag 和 If-None-Match

  `ETag` 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过`响应头`把这个值给浏览器。

  浏览器接收到`ETag`的值，会在下次请求时，将这个值作为**If-None-Match**这个字段的内容，并放到请求头中，然后发给服务器。

  服务器接收到**If-None-Match**后，会跟服务器上该资源的**ETag**进行比对:

  - 如果两者不一样，说明要更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。
  - 否则返回 304，告诉浏览器直接用缓存。

#### 两者对比

1. 在`精准度`上，`ETag`优于`Last-Modified`。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:
   - 如果本地打开或编辑了缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
   - 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源
2. 在性能上，`Last-Modified`优于`ETag`，也很简单理解，`Last-Modified`仅仅只是记录一个时间点，而 `Etag`需要根据文件的具体内容生成哈希值。

另外，如果两种方式都支持的话，服务器会优先考虑`ETag`。

#### 缓存位置

前面我们已经提到，当`强缓存`命中或者协商缓存中服务器返回 304 的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

1. Service Worker

   Service Worker 借鉴了 Web Worker 的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问`DOM`。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如`离线缓存`、`消息推送`和`网络代理`等功能。Service Worker 同时也是 PWA 的重要实现机制。

2. Memory Cache

   **Memory Cache**指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当进程结束后，内存缓存也就不存在了。

3. Disk Cache

   **Disk Cache**就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。

   - 比较大的 JS、CSS 文件会直接被丢进磁盘，反之丢进内存

- 内存使用率比较高的时候，文件优先进入磁盘

4. Push Cache

   即推送缓存，这是浏览器缓存的最后一道防线。它是 `HTTP/2` 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。

#### 总结

对浏览器的缓存机制来做个简要的总结:

首先通过 `Cache-Control` 验证强缓存是否可用

- 如果强缓存可用，直接使用

- 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的

  ```
  If-Modified-Since
  ```

  或者

  ```
  If-None-Match
  ```

  这些条件请求字段检查资源是否更新

  - 若资源更新，返回资源和 200 状态码
  - 否则，返回 304，告诉浏览器直接从缓存获取资源
  - 如果什么缓存策略都没有设置，那么浏览器会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间

![img](https://user-gold-cdn.xitu.io/2020/4/5/1714a298b93c3208?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



## 能不能说一说浏览器的本地存储？各自优劣如何？

#### Cookie

由于 HTTP 协议是无状态协议，Cookie 最开始是为了做状态存储的。

缺点

1. 容量缺陷。Cookie 的体积上限只有`4KB`，只能用来存储少量的信息。
2. 性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。
3. 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在`HttpOnly`为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

#### localStorage

- 和 Cookie 异同

`localStorage`有一点跟`Cookie`一样，就是针对一个域名，即在同一个域名下，会存储相同的一段**localStorage**。

不过它相对`Cookie`还是有相当多的区别的:

1. 容量。localStorage 的容量上限为**5M**，相比于`Cookie`的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。
2. 只存在客户端，默认不参与服务端的通信。这样就很好地避免了 Cookie 带来的**性能问题**和**安全问题**。
3. 接口封装。通过`localStorage`暴露在全局，并通过它的 `setItem` 和 `getItem`等方法进行操作，非常方便

- 应用场景

利用`localStorage`的较大容量和持久特性，可以利用`localStorage`存储一些内容稳定的资源，比如官网的`logo`，存储`Base64`格式的图片资源，因此利用`localStorage`

#### sessionStorage

- 特点

  `sessionStorage`以下方面和`localStorage`一致:

  - 容量。容量上限也为 5M。
  - 只存在客户端，默认不参与与服务端的通信。
  - 接口封装。除了`sessionStorage`名字有所变化，存储方式、操作方式均和`localStorage`一样。

  但`sessionStorage`和`localStorage`有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分`sessionStorage`就不复存在了。

- 应用场景
  1. 可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
  2. 可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用`sessionStorage`就再合适不过了。事实上微博就采取了这样的存储方式。

#### IndexDB

`IndexDB`是运行在浏览器中的`非关系型数据库`, 本质上是数据库，绝不是和刚才 WebStorage 的 5M 一个量级，理论上这个容量是没有上限的。

## 实现图片懒加载

1. 给 scroll 添加监听事件，进行节流处理，通过 clientHeight、scrollTop 和 offsetTop 判断元素是否出现在视图中

2. 给 scroll 添加监听事件，进行节流处理，通过 getBoundingClientRect 判断元素是否出现在视图中

3. 采用 IntersectionObserver API，其可以实现监听 window 的 scroll 事件，判断是否在视图中及节流功能

   ```js
   let img = document.document.getElementsByTagName('img');

   const observer = new IntersectionObserver((changes) => {
     //changes 是被观察的元素集合
     for (let i = 0, len = changes.length; i < len; i++) {
       let change = changes[i];
       // 通过这个属性判断是否在视口中
       if (change.isIntersecting) {
         const imgElement = change.target;
         imgElement.src = imgElement.getAttribute('data-src');
         observer.unobserve(imgElement);
       }
     }
   });

   observer.observe(img);
   ```

## 做过 H5 页面没有？你怎样适配移动端的

在程序初始化的时候可以使用以下方式来修改根节点的字体大小：

(假设你需要的`1rem = 20px`)

```js
(function () {
  var html = document.documentElement;
  function onWindowResize() {
    html.style.fontSize = html.getBoundingClientRect().width / 20 + 'px';
  }
  window.addEventListener('resize', onWindowResize);
  onWindowResize();
})();
```

- `document.documentElement`：获取`document`的根元素
- `html.getBoundingClientRect().width`：获取`html`的宽度(窗口的宽度)
- 监听`window`的`resize`事件

一般还需要配合一个`meta`头：

```html
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, minimum-sacle=1.0, maximum-scale=1.0, user-scalable=no"
/>
```

## addEventListener 函数的第三个参数

指定有关 listener 属性的可选参数对象。

- once 表示添加后只执行一次，执行完会被移除。
- passive 表示该 listener 永远不会调用 preventDefault()
- capture 表示 listener 会在该类型的事件捕获阶段传播到 EventTarget 时触发

## 所有的事件都有冒泡吗？

并不是所有的事件都有冒泡的，例如以下事件就没有：

- `onblur`
- `onfocus`
- `onmouseenter`
- `onmouseleave`

## DOM 事件捕获

具体流程捕获的流程为：window -> document -> html -> body -> ... -> 目标元素。

冒泡的流程为：目标元素 -> ... -> body -> html -> document -> window。

## 事件绑定的方式

- 嵌入 dom

```html
<button onclick="func()">按钮</button>
```

- 直接绑定

```html
btn.onclick = function(){}
```

- 事件监听

```html
btn.addEventListener('click',function(){})
```

## 有写过原生的自定义事件吗

- 使用`Event`
- 使用`customEvent` （可以传参数）
- 使用`document.createEvent('CustomEvent')和initEvent()`

**创建自定义事件**

原生自定义事件有三种写法：

1. 使用Event

```js
let myEvent = new Event('event_name');
```

2. 使用CustomEvent （可以传参数）

```js
let myEvent = new CustomEvent('event_name', {
  detail: {
    // 将需要传递的参数放到这里
    // 可以在监听的回调函数中获取到：event.detail
  },
});
```

3. 使用document.createEvent('CustomEvent') 和 initEvent()

```js
let myEvent = document.createEvent('CustomEvent'); // 注意这里是为'CustomEvent'
myEvent
  .initEvent
  // 1. event_name: 事件名称
  // 2. canBubble: 是否冒泡
  // 3. cancelable: 是否可以取消默认行为
  ();
```

**事件的监听**

自定义事件的监听其实和普通事件的一样，使用`addEventListener`来监听：

```
button.addEventListener('event_name', function (e) {})
```



**事件的触发**

触发自定义事件使用`dispatchEvent(myEvent)`。

注意 ，这里的参数是要自定义事件的对象(也就是`myEvent`)，而不是自定义事件的名称(`'myEvent'`)

**案例**

来看个案例吧：

```js
// 1.
// let myEvent = new Event('myEvent');
// 2.
// let myEvent = new CustomEvent('myEvent', {
//   detail: {
//     name: 'lindaidai'
//   }
// })
// 3.
let myEvent = document.createEvent('CustomEvent');
myEvent.initEvent('myEvent', true, true);

let btn = document.getElementsByTagName('button')[0];
btn.addEventListener('myEvent', function (e) {
  console.log(e);
  console.log(e.detail);
});
setTimeout(() => {
  btn.dispatchEvent(myEvent);
}, 2000);
```

## 事件委托

事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。

## target 和 currentTarget 区别

- event.target 返回触发事件的元素
- event.currentTarget 返回绑定事件的元素

## DOM 事件模型及阻止冒泡和阻止默认行为

**DOM 事件模型分为捕获和冒泡**。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。

（1）捕获阶段：事件从 window 对象自上而下向目标节点传播的阶段；

（2）目标阶段：真正的目标节点正在处理事件的阶段；

（3）冒泡阶段：事件从目标节点自下而上向 window 对象传播的阶段。

- 阻止冒泡

  1. event.stopPropagation() 方法阻止事件冒泡到父元素，阻止任何父事件处理程序被执行。

  2. event.stopImmediatePropagation() 既能阻止事件向父元素冒泡，也能阻止元素同事件类型的其它监听器被触发

- 阻止默认行为 例如a标签跳转 ，form表单提交跳转

  event. preventDefault()



## 为何会出现浏览器兼容问题

渐进增强：针对低版本浏览器开发基本的功能，在高级版本浏览器里用更好的效果提升用户体验。

优雅降级：从一开始就构建完整更好的效果，针对低版本浏览器进行兼容。

处理兼容问题的思路：

1. 产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）

2. 成本的角度 (有无必要做某件事)

   - 做到什么程度，让哪些浏览器支持哪些效果
- 如何做：根据兼容需求选择技术框架/库(jquery)，可以选择兼容工具(css reset、normalize.css、 条件注释、js 能力检测)做一些修补



## 页面性能

1. 资源压缩合并，减少 HTTP 请求
2. 非核心代码异步加载（异步加载的方式，异步加载的区别）
3. 利用浏览器缓存（缓存的分类，缓存原理）
4. 使用 CDN
5. 预解析 DNS

```html
// DNS预解析 <link rel="dns-prefetch" href="//host_name_to_prefetch.com" />
```

## 能说说首屏加载优化有哪些方案么

-  路由懒加载（利用 Webpack 的代码切割）
- Nginx 的 gzip 压缩
- 异步组件
- 服务端渲染 SSR
- 三方库采用按需加载
- Service Worker 缓存文件处理
- 合理使用link标签的rel属性设置prefetch和preload
  - prefetch  告诉浏览器这个资源将来可能需要，但是什么时间加载这个资源是由浏览器来决定的，可以加速下一次的导航。
  - preload  下载顺序权重提高，可以放一些页面必须的web字体包，因中文字体包一般较大。

## 白屏时间

白屏时间是指浏览器从输入网址，到浏览器开始显示内容的时间。

`startTime`：有些浏览器实现为`navigationStart`，代表浏览器开始 unload 前一个页面文档的开始时间节点。比如我们当前正在浏览 baidu.com，在地址栏输入 google.com 并回车，浏览器的执行动作依次为：unload 当前文档（即 baidu.com）->请求下一文档（即 google.com）。navigationStart 的值便是触发 unload 当前文档的时间节点。如果当前文档为空，则 navigationStart 的值等于 fetchStart。

`domLoading`代表浏览器开始解析 html 文档的时间节点。我们知道 IE 浏览器下的 document 有 readyState 属性，domLoading 的值就等于 readyState 改变为 loading 的时间节点；

白屏时间

```js
performance.timing.domLoading -
  (performance.timing.navigationStart || performance.timing.pageStartTime);
```

## 首屏时间

首屏时间：从浏览器输入地址并回车后到首屏内容渲染完毕的时间

`domContentLoadedEventStart`：代表 DOMContentLoaded 事件触发的时间节点： 页面文档完全加载并解析完毕之后,会触发 DOMContentLoaded 事件，HTML 文档不会等待样式文件,图片文件,子框架页面的加载(load 事件可以用来检测 HTML 页面是否完全加载完毕(fully-loaded))。

- 如果页面首屏没有图片

```js
performance.timing.domContentLoadedEventStart - performance.timing.navigationStart;
```

- H5 如果页面首屏有图片可以在每个 img 中添加 onload 时间并绑定到 window 属性上, 等 window.onload 事件触发再进行计算

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>首屏</title>
    <script>
      // 不兼容 performance.timing 的浏览器
      window.pageStartTime = Date.now();
    </script>
  </head>
  <body>
    <img src="https://lz5z.com/assets/img/google_atf.png" alt="img" onload="load()" />
    <img src="https://lz5z.com/assets/img/css3_gpu_speedup.png" alt="img" onload="load()" />
    <script>
      function load() {
        window.firstScreen = Date.now();
      }
      window.onload = function () {
        // 首屏时间
        console.log(window.firstScreen - performance.timing.navigationStart);
      };
    </script>
  </body>
</html>
```

```reStructuredText
首屏图片全部加载完毕的时刻 - performance.timing.navigationStart
```

## 跨域通信的几种方式

- JSONP(利用 script 标签的异步加载实现的)
- WebSocket
- cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息
- 反向代理 nginx 服务内部配置 Access-Control-Allow-Origin \*

## 什么是跨域？浏览器如何拦截响应？如何解决？

回顾一下 URI 的组成:

[![img](http://47.98.159.95/my_blog/http/004.png)](http://47.98.159.95/my_blog/http/004.png)

浏览器遵循**同源政策**(`scheme(协议)`、`host(主机)`和`port(端口)`都相同则为`同源`)。非同源站点有这样一些限制:

- 不能读取和修改对方的 DOM 银行系统嵌入恶意网站进行读取操作
- 不读访问对方的 Cookie、IndexDB 和 LocalStorage
- 限制 XMLHttpRequest 请求。 登录用户 Cookie 进行 CSRF 攻击

跨域只存在于浏览器端。浏览器它为`web`提供了访问入口，并且访问的方式很简单，在地址栏输入要访问的地址或者点击某个链接就可以了，正是这种**开放的形态**，所以我们需要对它有所限制。

渲染进程被装进了沙箱，以防止黑客触碰到系统资源，在沙箱里是无法发送网络请求的，所以需要主进程来发送。

发送到服务端之后，将响应返回，主进程检查到跨域，且没有 cors(后面会详细说)响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。

#### JSONP

虽然`XMLHttpRequest`对象遵循同源政策，但是`script`标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。和`CORS`相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。

```js
const jsonp = ({ url, params, callbackName }) => {
  const generateURL = (callback) => {
    const allParams = { ...params, callback };
    const dataStr = Object.entries(allParams).reduce((acc, [key, value]) => {
      return `${acc}${key}=${value}&`;
    }, '');
    return `${url}?${dataStr}`;
  };

  return new Promise((resolve) => {
    // 初始化回调函数名称
    const callback = callbackName || `callback${Date.now()}`;
    // 创建 script 元素并加入到当前文档中
    const scriptEle = document.createElement('script');
    scriptEle.src = generateURL(callback);
    document.body.appendChild(scriptEle);
    // 绑定到 window 上，为了后面调用
    window[callback] = (data) => {
      resolve(data);
      // script 执行完了，成为无用元素，需要清除
      document.body.removeChild(scriptEle);
    };
  });
};

jsonp({
  url: 'http://localhost:3000',
  params: {
    a: 1,
    b: 2,
  },
}).then((data) => {
  console.log('data: ', data);
  // 拿到数据进行处理
  // 数据包
});
```

当然在服务端也会有响应的操作, 以 express 为例:

```js
let express = require('express');
let app = express();
app.get('/', function (req, res) {
  let { a, b, callback } = req.query;
  console.log(a); // 1
  console.log(b); // 2
  // 注意哦，返回给script标签，浏览器直接把这部分字符串执行
  res.end(`${callback}('数据包')`);
});
app.listen(3000);
```

#### Nginx 做反向代理设置设置 Header 头

Nginx 相当于起了一个跳板机，这个跳板机的域名也是`client.com`，让客户端首先访问 `client.com/api`，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给`server.com`，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。

```
server {
  listen  80;
  server_name  client.com;
  location /api {
    proxy_pass server.com;
  }
}
```

#### CORS

跨域资源共享，需要浏览器支持和后端服务支持。

一些重要的 Response 头

- 最重要的 通过 Access-Control-Allow-Origin 来判断请求头里的 Origin 是否在其中。判断是否是跨域请求。
- Access-Control-Allow-Credentials 表示是否允许发送 Cookie

* 简单请求
  - 请求方法为 GET、POST 或者 HEAD
  - 请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`)
* 除了上述情况就非简单请求

非简单请求流程

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

会先发送预检请求， 这个请求对服务器是安全的，也就是说不会对服务器的资源做任何改变，仅仅用于确认 header 响应

请求如下

```http
OPTIONS / HTTP/1.1
// 当前请求地址
Origin: 当前地址
// 目标地址
Host: xxx.com
// 这次请求要用到的HTTP方法
Access-Control-Request-Method: PUT
```

响应如下

```http
HTTP/1.1 200 OK
// 表示可以允许请求的源，可以填具体的源名，也可以填`*`表示允许任意源请求
Access-Control-Allow-Origin: *
// 表示允许的请求方法列表。
Access-Control-Allow-Methods: GET, POST, PUT
// 表示允许携带Cookie
Access-Control-Allow-Credentials: true
// 预检请求的有效期，在此期间，不用发出另外一条预检请求。
Access-Control-Max-Age: 1728000
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
```

如果成功则进行下步真正发送请求。



## Ajax 和 Fetch 区别

- Ajax 是使用 XMLHttpRequest 对象发起的，但是用起来很麻烦，所以 ES6 新规范就有了 fetch，fetch 发一个请求不用像 ajax 那样写一大堆代码。
- 使用 fetch 无法取消一个请求，这是因为 fetch 基于 Promise，而 Promise 无法做到这一点。
- 在默认情况下，fetch 不会发送 cookies
- fetch 没有办法原生监测请求的进度，而 XMLHttpRequest 可以
- fetch 只对网络请求报错，对 400，500 都当做成功的请求，需要封装去处理
- fetch 由于是 ES6 规范，兼容性上比不上 XMLHttpRequest
