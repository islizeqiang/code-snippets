## V8 如何执行一段 JS 代码

**预解析**：检查语法错误但不生成 AST

**生成 AST**：经过词法/语法分析，生成抽象语法树

**生成字节码**：基线编译器(Ignition)将 AST 转换成字节码

**生成机器码**：优化编译器(Turbofan)将字节码转换成优化过的机器码，此外在逐行执行字节码的过程中，如果一段代码经常被执行，那么 V8 会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码，优化了执行速度

## 介绍一下引用计数和标记清除

- **引用计数**：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为 0 的对象。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。
- **标记清除**：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。

## V8 如何进行垃圾回收

JS 引擎中对变量的存储主要有两种位置，栈内存和堆内存，栈内存存储基本类型数据以及引用类型数据的内存地址，堆内存储存引用类型的数据

![img](https://user-gold-cdn.xitu.io/2020/4/5/17149730709e41a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 栈内存的回收：栈内存调用栈上下文切换后就被回收，比较简单

- 堆内存的回收：V8 的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代内存存在时间长

![img](https://user-gold-cdn.xitu.io/2020/4/5/1714980cac75fc32?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 新生代内存回收机制：
  - 新生代内存容量小，64 位系统下仅有 32M。新生代内存分为**From、To**两部分，进行垃圾回收时，先扫描 From，将非存活对象回收，将存活对象顺序复制到 To 中，之后调换 From/To，等待下一次回收
- 老生代内存回收机制
  - **晋升**：如果新生代的变量经过多次回收依然存在，那么就会被放入老生代内存中
  - **标记清除**：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收被标记的对象
  - **整理内存碎片**：把对象挪到内存的一端

## JS 相较于 C++等语言为什么慢，V8 做了哪些优化

1. JS 的问题：
   - **动态类型**：导致每次存取属性/寻求方法时候，都需要先检查类型；此外动态类型也很难在编译阶段进行优化
   - **属性存取**：C++/Java 等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而 JS 存储在对象中，每次获取都要进行哈希查询
2. V8 的优化：
   - **优化 JIT(即时编译)**：相较于 C++/Java 这类编译型语言，JS 一边解释一边执行，效率低。V8 对这个过程进行了优化：如果一段代码被执行多次，那么 V8 会把这段代码转化为机器码缓存下来，下次运行时直接使用机器码。
   - **隐藏类**：对于 C++这类语言来说，仅需几个指令就能通过偏移量获取变量信息，而 JS 需要进行字符串匹配，效率低，V8 借用了类和偏移位置的思想，将对象划分成不同的组，即隐藏类
   - **内嵌缓存**：即缓存对象查询的结果。常规查询过程是：获取隐藏类地址 -> 根据属性名查找偏移值 -> 计算该属性地址，内嵌缓存就是对这一过程结果的缓存
   - **垃圾回收管理**：上文已介绍

![img](https://user-gold-cdn.xitu.io/2020/4/5/1714a1f7c054c657?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

# 设计模式

设计模式有许多种，这里挑出几个常用的：

|  设计模式  |                    描述                    |                例子                |
| :--------: | :----------------------------------------: | :--------------------------------: |
|  单例模式  |          一个类只能构造出唯一实例          |        Redux/Vuex 的 store         |
|  工厂模式  |            对创建对象逻辑的封装            |       jQuery 的\$(selector)        |
| 观察者模式 | 当一个对象被修改时，会自动通知它的依赖对象 | Redux 的 subscribe、Vue 的双向绑定 |
| 装饰器模式 |       对类的包装，动态地拓展类的功能       |     React 高阶组件、ES7 装饰器     |
| 适配器模式 |          兼容新旧接口，对类的包装          |             封装旧 API             |
|  代理模式  |               控制对象的访问               |       事件代理、ES6 的 Proxy       |

## 1. 介绍一下单一职责原则和开放封闭原则

- **单一职责原则**：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。
- **开放封闭原则**：核心的思想是软件实体（类、模块、函数等）是可扩展的、但不可修改的。也就是说,对扩展是开放的,而对修改是封闭的。

## 2. 单例模式

单例模式即一个类只能构造出唯一实例，单例模式的意义在于**共享、唯一**，`Redux/Vuex`中的 store、`JQ`的\$或者业务场景中的购物车、登录框都是单例模式的应用

```js
class SingletonLogin {
  constructor(name, password) {
    this.name = name;
    this.password = password;
  }
  static getInstance(name, password) {
    //判断对象是否已经被创建,若创建则返回旧对象
    if (!this.instance) this.instance = new SingletonLogin(name, password);
    return this.instance;
  }
}

let obj1 = SingletonLogin.getInstance('CXK', '123');
let obj2 = SingletonLogin.getInstance('CXK', '321');

console.log(obj1 === obj2); // true
console.log(obj1); // {name:CXK,password:123}
console.log(obj2); // 输出的依然是{name:CXK,password:123}
```

## 3. 工厂模式

工厂模式即对创建对象逻辑的封装，或者可以简单理解为对`new`的封装，这种封装就像创建对象的工厂，故名工厂模式。工厂模式常见于大型项目，比如 JQ 的$对象，我们创建选择器对象时之所以没有new selector就是因为$()已经是一个工厂方法，其他例子例如`React.createElement()`、`Vue.component()`都是工厂模式的实现。工厂模式有多种：`简单工厂模式`、`工厂方法模式`、`抽象工厂模式`，这里只以简单工厂模式为例：

```js
class User {
  constructor(name, auth) {
    this.name = name;
    this.auth = auth;
  }
}

class UserFactory {
  static createUser(name, auth) {
    //工厂内部封装了创建对象的逻辑:
    //权限为admin时,auth=1, 权限为user时, auth为2
    //使用者在外部创建对象时,不需要知道各个权限对应哪个字段, 不需要知道赋权的逻辑，只需要知道创建了一个管理员和用户
    if (auth === 'admin') new User(name, 1);
    if (auth === 'user') new User(name, 2);
  }
}

const admin = UserFactory.createUser('cxk', 'admin');
const user = UserFactory.createUser('cxk', 'user');
```

## 4. 观察者模式

观察者模式算是前端最常用的设计模式了，观察者模式概念很简单：观察者监听被观察者的变化，被观察者发生改变时，通知所有的观察者。观察者模式被广泛用于监听事件的实现，有关观察者模式的详细应用，可以看我另一篇讲解[Redux 实现的文章](https://juejin.im/post/5def4831e51d45584b585000#heading-3)

```js
//观察者
class Observer {
  constructor(fn) {
    this.update = fn;
  }
}
//被观察者
class Subject {
  constructor() {
    this.observers = []; //观察者队列
  }
  addObserver(observer) {
    this.observers.push(observer); //往观察者队列添加观察者
  }
  notify() {
    //通知所有观察者,实际上是把观察者的update()都执行了一遍
    this.observers.forEach((observer) => {
      observer.update(); //依次取出观察者,并执行观察者的update方法
    });
  }
}

var subject = new Subject(); //被观察者
const update = () => {
  console.log('被观察者发出通知');
}; //收到广播时要执行的方法
var ob1 = new Observer(update); //观察者1
var ob2 = new Observer(update); //观察者2
subject.addObserver(ob1); //观察者1订阅subject的通知
subject.addObserver(ob2); //观察者2订阅subject的通知
subject.notify(); //发出广播,执行所有观察者的update方法
```

有些文章也把观察者模式称为发布订阅模式，其实二者是有所区别的，发布订阅相较于观察者模式多一个调度中心。

## 5. 装饰器模式

装饰器模式，可以理解为对类的一个包装，动态地拓展类的功能，ES7 的`装饰器`语法以及 React 中的`高阶组件`（HoC）都是这一模式的实现。react-redux 的 connect()也运用了装饰器模式，这里以 ES7 的装饰器为例：

```js
function info(target) {
  target.prototype.name = '张三';
  target.prototype.age = 10;
}

@info
class Man {}

let man = new Man();
man.name; // 张三
```

## 6. 适配器模式

适配器模式，将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。我们在生活中就常常有使用适配器的场景，例如出境旅游插头插座不匹配，这时我们就需要使用转换插头，也就是适配器来帮我们解决问题。

```js
class Adaptee {
  test() {
    return '旧接口';
  }
}

class Target {
  constructor() {
    this.adaptee = new Adaptee();
  }
  test() {
    let info = this.adaptee.test();
    return `适配${info}`;
  }
}

let target = new Target();
console.log(target.test());
```

## 7. 代理模式

代理模式，为一个对象找一个替代对象，以便对原对象进行访问。即在访问者与目标对象之间加一层代理，通过代理做授权和控制。最常见的例子是经纪人代理明星业务，假设你作为一个投资者，想联系明星打广告，那么你就需要先经过代理经纪人，经纪人对你的资质进行考察，并通知你明星排期，替明星本人过滤不必要的信息。事件代理、`JQuery的$.proxy`、ES6 的`proxy`都是这一模式的实现，下面以 ES6 的 proxy 为例：

```js
const idol = {
  name: '蔡x抻',
  phone: 10086,
  price: 1000000, //报价
};

const agent = new Proxy(idol, {
  get: function (target) {
    //拦截明星电话的请求,只提供经纪人电话
    return '经纪人电话:10010';
  },
  set: function (target, key, value) {
    if (key === 'price') {
      //经纪人过滤资质
      if (value < target.price) throw new Error('报价过低');
      target.price = value;
    }
  },
});

agent.phone; //经纪人电话:10010
agent.price = 100; //Uncaught Error: 报价过低
```

![img](https://user-gold-cdn.xitu.io/2020/4/5/171465b92f6ded5e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
