# 第 117 题：介绍下 http1.0、1.1、2.0 协议的区别？

http/1 :

1. 默认不支持长连接，需要设置 keep-alive 参数指定
2. 强缓存 expired、协商缓存 last-modified\if-modified-since 有一定的缺陷

http 1.1 :

1. 默认长连接(keep-alive)，http 请求可以复用 Tcp 连接，但是同一时间只能对应一个 http 请求(http 请求在一个 Tcp 中是串行的)
2. 增加了强缓存 cache-control、协商缓存 etag\if-none-match 是对 http/1 缓存的优化

http/2 :

1. 多路复用，一个 Tcp 中多个 http 请求是并行的 (雪碧图、多域名散列等优化手段 http/2 中将变得多余)
2. 二进制格式编码传输
3. header 压缩
4. 服务端推送

参考： https://juejin.im/entry/5981c5df518825359a2b9476

# 第 15 题：简单讲解一下 http2 的多路复用

**HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。**

举例来说，在一个 TCP 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送 A 请求已经处理好的部分， 接着回应 B 请求，完成后，再发送 A 请求剩下的部分。

多路复用，就是在一个 TCP 连接中可以存在多条流，帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

数据流以消息的形式发送，消息由一个或多个帧组成；帧可以乱序发送，根据帧头部的流标识重新组装。所以可以设置一个 31 bit 的优先级，有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。

明白版本 http://www.ruanyifeng.com/blog/2016/08/http.html

tcp 协议 http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html

#### 历史原因解释：

##### 1、HTTP/1.0 版本

该版本主要缺点是，每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。为了解决这个问题，需要使用 `Connection: keep-alive` 这个字段。

##### 2、HTTP/1.1 版本

该版本引入了持久连接（persistent connection），即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。还引入了管道机制（pipelining），即在同一个 TCP 连接里面，客户端可以同时发送多个请求。这样就进一步改进了 HTTP 协议的效率。

虽然 1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）。

# HTTP 状态码

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status

# 第 44 题：介绍 HTTPS 握手过程

https 是使用 SSL/TLS 的 HTTP 通信

应用最广泛的是 TLS 1.0，接下来是 SSL 3.0。但是，主流浏览器都已经实现了 TLS 1.2 的支持。 TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3。

1. 客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello 请求。给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
2. 服务器收到客户端请求后，向客户端发出回应，这叫做 SeverHello。确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
3. 客户端收到服务器回应以后，确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器。
4. 服务器使用自己的私钥，解密出客户端发来的随机数（即 Premaster secret）。
5. 客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。

参考全部： http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html

# 第 45 题：HTTPS 握手过程中，客户端如何验证证书的合法性

（1）首先第一步是浏览器校验证书的有效期，以及是否被吊销(**_证书撤销名单_**, **_在线证书状态协议_**)，还有证书的网站域名和证书的颁发域名是否是一致的。

（2）第二步浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者做比对，校验是否为合法机构颁发。

（3）如果是合法机构颁发， 那么浏览器就会从操作系统中取出本地的这个机构的公钥，用这个公钥解密出服务器发来证书的签名。 接下来用相同的算法， 生成一个自己的证书签名，和解密出的签名做对比。

# 第 91 题：介绍下 HTTPS 中间人攻击

1. 服务器向客户端发送公钥。
2. 攻击者截获公钥，保留在自己手上。
3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
4. 客户端收到伪造的公钥后，生成加密 hash 值发给服务器。
5. 攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。
6. 同时生成假的加密 hash 值，发给服务器。
7. 服务器用私钥解密获得假秘钥。服务器用加秘钥加密传输信息

# HTTP协议

# 如何理解 HTTP 的请求方法？

## 有哪些请求方法？

`http/1.1`规定了以下请求方法(注意，都是大写):

- GET: 通常用来获取资源
- HEAD: 获取资源的元信息
- POST: 提交数据，即上传数据
- PUT: 修改数据
- DELETE: 删除资源(几乎用不到)
- CONNECT: 建立连接隧道，用于代理服务器
- OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
- TRACE: 追踪请求-响应的传输路径

## GET 和 POST 有什么区别？

首先最直观的是语义上的区别。

而后又有这样一些具体的差别:

- 从**缓存**的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 从**编码**的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 从**参数**的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- 从**幂等性**的角度，`GET`是**幂等**的，而`POST`不是。(`幂等`表示执行相同的操作，结果也是相同的)
- 从**TCP**的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(**火狐**浏览器除外，它的 POST 请求只发一个 TCP 包)