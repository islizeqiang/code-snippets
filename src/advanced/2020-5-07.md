### CSS 盒模型

CSS 盒模型是前端的基石，这个问题由浅入深，由易到难，可以依次问出下面几个问题

- 基本概念：标准模型 + IE 模型
- 标准模型 和 IE 模型的区别
- CSS 如何设置这两种模型
- JS 如何设置和获取盒模型对应的宽和高
- 实例题（根据盒模型解释边距重叠）
- BFC（边距重叠解决方案）

1、基本概念所有 HTML 元素可以看作盒子，在 CSS 中，"box model"这一术语是用来设计和布局时使用。 CSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边距，边框，填充，和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。下面的图片说明了盒子模型(Box Model)：

2、标准模型与 IE 模型的区别标准模型与 IE 模型的区别在于宽高的计算方式不同。标准模型计算元素的宽高只算 content 的宽高，IE 模型是 content + padding + border 的总尺寸。假如 content 宽高是 100*100px，padding 为 10px，border 为 10px，margin 为 10px，那么在标准模型下，这个元素的宽为 100px，高为 100px。* *IE 模型下，宽为 100px + 2*10px(左右 padding) + 2*10px(左右 border) = 140px;* *高为 100px + 2*10px(上下 padding) + 2\*10px(上下 border) = 140px;

3、如何设置这两种模型

```css
/* 设置标准模型 */
box-sizing: content-box;

/* 设置IE模型 */
box-sizing: border-box;
```

box-sizing 的默认值是 content-box，即默认标准模型

### JS 如何设置盒模型的宽和高

假设已经获取的节点为 `dom`

```js
//只能获取内联样式设置的宽高
dom.style.width / height;

//获取渲染后即时运行的宽高，值是准确的。但只支持 IE
dom.currentStyle.width / height;

//获取渲染后即时运行的宽高，值是准确的。兼容性更好
window.getComputedStyle(dom).width / height;

//获取渲染后即时运行的宽高，值是准确的。兼容性也很好，一般用来获取元素的绝对位置，getBoundingClientRect()会得到4个值：left, top, width, height
dom.getBoundingClientRect().width / height;
```

### 3、DOM 事件

#### 3.1 事件级别

三个事件级别, 注意没有 DOM1，因为 DOM1 标准制定的时候没有涉及 DOM 事件。DOM3 比 DOM2 只是增加了一些事件类型。

- DOM0：element.onclick = function(){}
- DOM2：element.addEventListener('click', function(){}, false)
- DOM3：element.addEventListener('keyup', function(){}, false)

#### 3.2 事件模型和事件流

DOM 事件模型包括捕获和冒泡。事件流即用户与界面交互的过程中，事件的流向过程。

#### 3.3 DOM 事件捕获

具体流程捕获的流程为：window -> document -> html -> body -> ... -> 目标元素。

冒泡的流程为：目标元素 -> ... -> body -> html -> document -> window。

#### 3.4 Event 对象常见应用

- event. preventDefault() 取消事件的默认动作

- event.stopPropagation() 阻止事件冒泡

- event.stopImmediatePropagation() 阻止剩下的事件处理程序被执行。如果一个元素上绑定了三个事件，在其中一个事件上调用了这个方法，那其他 的两个事件将不会被执行。

#### 3.5 事件捕获流程和自定义事件示例

```abap
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>dom事件</title>
	<link rel="stylesheet" href="">
</head>
<body>
	<style type="text/css" media="screen">
		#wrapper {
			width: 300px;
			height: 150px;
			background: yellow;
		}
	</style>

	<div id="wrapper">点我啊点我啊</div>

	<script type="text/javascript">
		var eve = document.getElementById('wrapper');

		//验证事件捕获过程
		window.addEventListener('click', function(){
			console.log('window capture')
		}, true)

		document.addEventListener('click', function(){
			console.log('document capture')
		}, true)

		//document.documentElement 获取的是 html 标签
		document.documentElement.addEventListener('click', function(){
			console.log('html capture')
		}, true)

		document.body.addEventListener('click', function(){
			console.log('body capture')
		}, true)

		eve.addEventListener('click', function(){
			console.log('eve capture')
		}, true)

		//自定义事件
		var customEvent = new Event('test')
		eve.addEventListener('test', function(){
				console.log('自定义事件 test 触发')
		}, true)

		setTimeout(() => {
			eve.dispatchEvent(customEvent)
		}, 3000)
	</script>
</body>
</html>
```

控制台打印的结果为：

```text
window capture
document capture
html capture
body capture
eve capture
```

证明了事件捕获的流程为：window -> document -> html -> body -> ... -> 目标元素。自定义事件设定了 3 秒后触发，刷新页面，3 秒后控制台打印出 `自定义事件 test 触发` 。

### 4、HTTP 协议

#### 4.1 http 协议的主要特点

简单快速、灵活、无连接、无状态 HTTP 三点注意事项：

- HTTP 是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- HTTP 是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过 HTTP 发送。客户端以及服务器指定使用适合的 MIME-type 内容类型。
- HTTP 是无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

#### 4.2 请求报文

一个 HTTP 请求报文由请求行（request line）、请求头（header）、空行和请求数据 4 个部分组成，下图给出了请求报文的一般格式。

- **请求行**：包括请求方法字段、URL 字段和 HTTP 协议版本，如：GET /index.html HTTP/1.1。
- **请求头**: 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：

- User-Agent：产生请求的浏览器类型。
- Accept：客户端可识别的内容类型列表。
- Host：请求的主机名，允许多个域名同处一个 IP 地址，即虚拟主机。
- Content-Type：请求体的 MIME 类型 （用于 POST 和 PUT 请求中）。如：Content-Type: application/x-www-form-urlencoded
- **空行**

最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。

- **请求数据**

请求数据不在 GET 方法中使用，而是在 POST 方法中使用。POST 方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length。

#### 4.3 响应报文

包括：状态行、响应头、空行、响应正文。

#### 4.4 HTTP 状态码

HTTP 状态码的英文为 HTTP Status Code。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。

- 1xx：指示信息--表示请求已接收，继续处理。
- 2xx：成功--表示请求已被成功接收、理解、接受。
- 3xx：重定向--要完成请求必须进行更进一步的操作。
- 4xx：客户端错误--请求有语法错误或请求无法实现。
- 5xx：服务器端错误--服务器未能实现合法的请求。

常见状态代码、状态描述的说明如下。

- 200 OK：客户端请求成功。
- 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
- 401 Unauthorized：请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用。
- 403 Forbidden：服务器收到请求，但是拒绝提供服务。
- 404 Not Found：请求资源不存在，举个例子：输入了错误的 URL。
- 500 Internal Server Error：服务器发生不可预期的错误。
- 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。

#### 4.5 优化

DNS 预解析

```html
<!--在head标签中，越早越好-->
<link rel="dns-prefetch" href="//example.com" />
```

HTTP 预连接

```html
<link rel="preconnect" href="//example.com" />
<link rel="preconnect" href="//cdn.example.com" crossorigin />
```

#### 4.6 浏览器输入 url 之后发生了什么

重点！

### 五、原型链

#### 5.1 创建对象的几种方法

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>原型链</title>
    <link rel="stylesheet" href="" />
  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      //创建对象的几种方式
      //1.字面量
      var obj1 = { name: 'solo obj1' };
      //2.new Object
      var obj2 = new Object({ name: 'solo obj2' });
      //3.构造函数创建
      var M = function (name) {
        this.name = name;
      };
      var obj3 = new M('solo obj3');
      //4.Object.create
      var p = { name: 'p' };
      var obj4 = Object.create(p);
    </script>
  </body>
</html>
```

#### 5.2 原型、构造函数、实例、原型链

![img](https://pic3.zhimg.com/80/v2-a6b2ab6b93f5b72cee707e2d3ea327e2_720w.jpg)

- 构造函数.prototype.constructor === 构造函数

M.prototype.constructor === M 的结果为 true

- 构造函数.prototype === 实例对象.**proto**

M.prototype === obj3._ *proto*_ 的结果为 true

#### instanceof 的原理

instanceof 用于判断一个引用类型是否属于某构造函数；还可以在继承关系中用来判断一个实例是否属于它的父类型。 instanceof 的原理是判断实例对象的 `__proto__` 是否与构造函数的 `prototype` 指向同一个引用。

![img](https://pic1.zhimg.com/80/v2-330ec703451af6c71b641b8ba16741c8_720w.jpg)

只要在实例对象的原型链上的构造函数，instaceof 都会返回 true。看下图： obj3 是 M 的实例，所以 `obj3 instanceof M = true` ; 同时 `obj3 instanceof Object` 的结果也是 true

#### 5.4 instanceof 和 typeof 的区别

typeof 对于基本数据类型（null, undefined, string, number, boolean, symbol），除了 null 都会返回正确的类型。null 会返回 object。 typeof 对于对象类型，除了函数会返回 function，其他的都返回 object。如果我们想获得一个变量的正确类型，可以通过 `Object.prototype.toString.call(xx)`。这样我们就可以获得类似 `[object Type]` 的字符串。

判断是否等于 undefined 的方法：

```js
let a;
// 我们也可以这样判断 undefined
a === undefined;
// 但是 undefined 不是保留字，能够在低版本浏览器被赋值
let undefined = 1;
// 这样判断就会出错
// 所以可以用下面的方式来判断，并且代码量更少
// 因为 void 后面随便跟上一个组成表达式
// 返回就是 undefined  或者void(0)
a === void 0;
```

#### 实现 new

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>模拟new的过程</title>
    <link rel="stylesheet" href="" />
  </head>
  <body>
    <script type="text/javascript" charset="utf-8" async defer>
      function Person(name, age) {
        this.name = name;
        this.age = age;
      }

      //手动实现new
      function _new() {
        //1.拿到传入的参数中的第一个参数，即构造函数名Func
        var Func = [].shift.call(arguments);
        //2.创建一个空对象obj,并让其继承Func.prototype
        var obj = Object.create(Func.prototype);
        //第二步也可以这样写
        // var obj = {}
        // obj.__proto__ = Func.prototype
        //3.执行构造函数，并将this指向创建的空对象obj
        var ret = Func.apply(obj, arguments);
        //4.如果构造函数返回的值是对象则返回，不是对象则返回创建的对象obj
        return typeof ret === 'object' ? ret : obj;
      }

      var p1 = _new(Person, 'bob', 19);
      console.log(p1);
    </script>
  </body>
</html>
```

### 六、面向对象

#### 6.1 类的声明和实例化

声明类有两种方法：

```js
function Animal(name) {
  this.name = name;
}

class Animal2 {
  constructor(name) {
    this.name = name;
  }
}
```

类的实例化只有一种方式

```js
var a1 = new Animal('shape');
var a2 = new Animal2('cat');
```

#### 6.2 继承

继承有多种实现方式

### 七、通信类

#### 7.1 同源策略及限制

**同源策略**限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 **协议、域名、端口**只要有一个不一样，就是不同的源。不同源的限制

- Cookie、LocalStorage、IndexDB 无法获取
- DOM 无法获取
- Ajax 请求不能发送(Ajax 只限于同源使用，不能跨域使用)

#### 7.2 前后端如何通信

- Ajax
- WebSocket
- CORS

#### 7.3 跨域通信的几种方式

- JSONP(利用 script 标签的异步加载实现的)

- Hash（window.location.hash + iframe）

- postMessage (H5 中新增的)

- WebSocket

- CORS

### 八、安全类

前端安全分两类：CSRF、XSS 常考点：基本概念和缩写、攻击原理、防御措施

#### 8.1 CSRF

CSRF（Cross-site request forgery）跨站请求伪造。攻击原理

1. 用户 C 打开浏览器，访问受信任网站 A，输入用户名和密码请求登录网站 A；
2. 在用户信息通过验证后，网站 A 产生 Cookie 信息并返回给浏览器，此时用户登录网站 A 成功，可以正常发送请求到网站 A；
3. 用户未退出网站 A 之前，在同一浏览器中，打开一个 TAB 页访问网站 B；
4. 网站 B 接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点 A；
5. 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求，导致来自网站 B 的恶意代码被执行。

防御措施

1. Token 验证
2. Referer 验证（简单易行，但 referer 可能被改变）
3. 隐藏令牌（跟 Token 验证差不多，把令牌存到 header 中）

#### 8.2 XSS

XSS（cross-site scripting）跨域脚本攻击攻击原理往 Web 页面里插入恶意 Script 代码防御措施

1. HTML：对以下这些字符进行转义：

```html
&：&amp;
<：&alt;
>：&gt;
'：&#x27;
"：&quot;
/：&#x2F;
```

Javascript：把所有非字母、数字的字符都转义成小于 256 的 ASCII 字符； URL：使用 Javascript 的 encodeURIComponent()方法对用户的输入进行编码，该方法会编码如下字符：, / ? : @ & = + \$ #

### 十、渲染机制

#### 10.1 DOCTYPE 及其作用

DTD (Document type definition，文档类型定义) 是一系列的语法规则，用来定义 XML 或 HTML 的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。 **DOCTYPE 是用来声明文档类型和 DTD 规范的**，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错。注意：<!DOCTYPE> 声明不区分大小写。

HTML5

```html
<!DOCTYPE html>
```

### HTML 4.01 Strict

这个 DTD 包含所有 HTML 元素和属性，但不包括表象或过时的元素（如 font ）。框架集是不允许的。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

### HTML 4.01 Frameset

这个 DTD 与 HTML 4.01 Transitional 相同，但是允许使用框架集内容。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/h>
```

#### 10.2 浏览器渲染过程

这个问题照着这张图讲清楚就好。浏览器拿到 HTML 和 CSS 之后，通过 `HTML Parser` 把 HTML 解析成 `DOM Tree` , 通过 `CSS Parser` 把 CSS 解析成 `Style Rules` 即 CSS 规则，然后 `DOM Tree` 和 CSS 规则 结合起来形成 `Render Tree` 。然后进行布局 Layout 和绘制 Painting，最终 Display 显示在页面上。

![img](https://pic3.zhimg.com/80/v2-cbed1132b3a2e868757c274e54e9e6a6_720w.jpg)

#### 10.3 重排 Reflow

定义: DOM 结构中各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称为 reflow。触发 Reflow 什么情况会触发 Reflow 呢？（记住两三个就可以）

- 增加、删除、修改 DOM 节点时，会导致 Reflow 或 Repaint
- 移动 DOM 位置，或搞个动画时
- 修改 CSS 样式时
- Resize 窗口（移动端没这个问题）或滚动的时候
- 修改网页默认字体时

#### 10.4 重绘 Repaint

定义: 当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定之后，浏览器把这些元素按照各自的特性绘制了一遍，于是页面内容出现了，这个过程称之为 repaint。触发 Repaint

- DOM 改动
- CSS 改动

如何最小程度的 Repaint 比如要添加多个 DOM 节点，一次性添加，而不要一个个添加。

#### 10.5 dispaly:none 和 visibility:hidden

dispaly:none 设置该属性后，该元素下的元素都会隐藏，占据的空间消失。 visibility:hidden 设置该元素后，元素虽然不可见了，但是依然占据空间的位置。

display:none 和 visibility:hidden 的区别？ 1.visibility 具有继承性，其子元素也会继承此属性，若设置 visibility:visible，则子元素会显示 2.visibility 不会影响计数器的计算，虽然隐藏掉了，但是计数器依然继续运行着。 3.在 css3 的 transition 中支持 visibility 属性，但是不支持 display，因为 transition 可以延迟执行，因此配合 visibility 使用纯 css 实现 hover 延时显示效果可以提高用户体验

4. display:none 会引起回流(重排)和重绘 visibility:hidden 会引起重绘

### 十一、JS 运行机制

掌握下面几个要点：

- 理解 JS 的单线程概念
- 理解任务队列
- 理解 EventLoop
- 理解哪些语句会放入异步任务队列
- 理解语句放入异步任务队列的时机

#### 11.1 为什么 JavaScript 是单线程

JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？这样能提高效率啊。 JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。

#### 11.2 任务队列

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。所有任务可以分成两种，一种是**同步任务**（synchronous），另一种是**异步任务**（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。具体来说，异步执行的运行机制如下:（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。 （3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 复制代码只要主线程空了，就会去读取"任务队列"，这就是 JavaScript 的运行机制。这个过程会不断重复。

#### 11.3 宏任务 & 微任务

这里需要注意的是 new Promise 是会进入到主线程中立刻执行，而 promise.then 则属于微任务

- 宏任务(macro-task)：整体代码 script、setTimeOut、setInterval
- 微任务(mincro-task)：promise.then、promise.nextTick(node)

#### 11.4 EventLoop 事件循环

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。

![img](https://pic4.zhimg.com/80/v2-aac30c2c5277e89df6738fa961c9348f_720w.jpg)

1. 整体的 script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”；
2. 同步任务会直接进入主线程依次执行；
3. 异步任务会再分为宏任务和微任务；
4. 宏任务进入到 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中；
5. 微任务也会进入到另一个 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中；
6. 当主线程内的任务执行完毕，主线程为空时，会检查微任务的 Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务；
7. 上述过程会不断重复，这就是 Event Loop 事件循环；

#### 11.5 定时器

除了放置异步任务的事件，"任务队列"还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做"定时器"（timer）功能，也就是定时执行的代码。定时器功能主要由 setTimeout()和 setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论 setTimeout()。 setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。 console.log(1); setTimeout(function(){console.log(2);},1000); console.log(3); 复制代码上面代码的执行结果是 1，3，2，因为 setTimeout()将第二行推迟到 1000 毫秒之后执行。如果将 setTimeout()的第二个参数设为 0，就表示当前代码执行完（执行栈清空）以后，立即执行（0 毫秒间隔）指定的回调函数。 setTimeout(function(){console.log(1);}, 0); console.log(2); 复制代码上面代码的执行结果总是 2，1，因为只有在执行完第二行以后，系统才会去执行"任务队列"中的回调函数。总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行。 HTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔），不得低于**4 毫秒**，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为 10 毫秒。另外，对于那些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是**每 16 毫秒执行一次**。这时使用 requestAnimationFrame()的效果要好于 setTimeout()。需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。

#### 11.6 哪些是异步任务

1. setTimeout 和 setInterval
2. DOM 事件
3. Promise
4. 网络请求
5. I/O

### 十二、页面性能

面试必考，这五个最好都能记住。异步加载和浏览器缓存都会延伸了问，其他三个只要说出来即可。

提升页面性能的方法有哪些？

1. 资源压缩合并，减少 HTTP 请求
2. 非核心代码异步加载（异步加载的方式，异步加载的区别）
3. 利用浏览器缓存（缓存的分类，缓存原理）
4. 使用 CDN
5. 预解析 DNS

```text
//强制打开 <a> 标签的 dns 解析
<meta http-equiv="x-dns-prefetch-controller" content="on">
//DNS预解析
<link rel="dns-prefetch" href="//host_name_to_prefetch.com">
```
