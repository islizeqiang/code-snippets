[TOC]

## XSS 攻击(跨站脚本)

Cross Site Scripting 在浏览器执行恶意脚本。

几种实现

1. 留言评论区提交一段脚本代码，在页面渲染时直接执行
2. 作为中间人身份，截取 html，修改内容

防范：

1. 不相信用户的输入，对输入内容转码或者过滤，让其不可执行

2. 利用 CSP，即开启白名单，可阻止白名单以外的资源加载和运行

   - ```http
     // 只允许加载本站资源
     Content-Security-Policy: default-src ‘self’
     // 只允许加载 HTTPS 协议图片
     Content-Security-Policy: img-src https://*
     // 允许加载任何来源框架
     Content-Security-Policy: child-src 'none'
     ```

   - ```html
     <meta
       http-equiv="Content-Security-Policy"
       content="default-src 'self'; img-src https://*; child-src 'none';"
     />
     ```

3. 设置 Cookie 的 HttpOnly 属性，使 JS 无法读取，让攻击者无法读取到 Cookie

## CSRF 攻击(跨站请求伪造)

Cross-site request forgery。利用服务器验证漏洞和用户之前的登录状态（Cookie）模拟用户操作。

实现：

- 模拟用户进行恶意攻击操作

防范：

- 利用 Cookie 的 SameSite 属性。其可以设置三个值，当设置 Strict 时，完全禁止第三方请求携带 Cookie，只允许相同站点下才能携带 Cookie。但浏览器兼容不一。
- 验证来源站点，Origin 只包含域名信息，Referer 包含具体的 URL 路径，但两者都可在请求时伪造。
- 携带 Token，浏览器请求服务器时，服务器返回一个 token，每个请求都需要同时带上 token 和 cookie 才会被认为是合法请求

## 点击劫持

点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 `iframe` 嵌套的方式嵌入自己的网页中，并将 `iframe` 设置为透明，在页面中透出一个按钮诱导用户点击。

- X-FRAME-OPTIONS

  `X-FRAME-OPTIONS` 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 `iframe` 嵌套的点击劫持攻击。

  该响应头有三个值可选，分别是

  - `DENY`，表示页面不允许通过 `iframe` 的方式展示
  - `SAMEORIGIN`，表示页面可以在相同域名下通过 `iframe` 的方式展示
  - `ALLOW-FROM`，表示页面可以在指定来源的 `iframe` 中展示

- 也可以采用 JS 进行防御

## cookie 和 token 都存放在 header 中，为什么不会劫持 token？

- 首先 token 不是防止 XSS 的，而是为了防止 CSRF 的，因为 浏览器会自动带上 cookie，而浏览器不会自动带上 token
- 用户点击链接，Cookie 未失效，让后端以为还在登录，进行了操作，而 Token 需要手动放置。Authorization: xxxx

## 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？

1. 能够完成整个 HTTP 请求+响应（尽管不需要响应内容）
2. 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据
3. 跨域友好（img 天然支持跨域）
4. 执行过程无阻塞
5. 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好
6. GIF 的最低合法体积最小（最小的 BMP 文件需要 74 个字节，PNG 需要 67 个字节，而合法的 GIF，只需要 43 个字节）

## 浏览器缓存机制

从缓存位置上来说分为四种，并且各自有**优先级**，当依次查找缓存且都没有命中的时候，才会去请求网络

1. Service Worker

   Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们**自由控制**缓存哪些文件、如何匹配缓存、如何读取缓存，并且**缓存是持续性的**。

   当 Service Worker 没有命中缓存的时候，我们需要去调用 `fetch` 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。**但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。**

2. Memory Cache

   Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。**但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。** 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

   当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存

   - 对于大文件来说，大概率是不存储在内存中的，反之优先
   - 当前系统内存使用率高的话，文件优先存储进硬盘

3. Disk Cache

   Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache **胜在容量和存储时效性上。**

   在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。**并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。**

4. Push Cache

   ush Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。**并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。**

   - 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好
   - 可以推送 `no-cache` 和 `no-store` 的资源
   - 一旦连接被关闭，Push Cache 就被释放
   - 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存
   - Push Cache 中的缓存只能被使用一次
   - 浏览器可以拒绝接受已经存在的资源推送
   - 你可以给其他域名推送资源

5. 网络请求

   分为强缓存和协商缓存

#### 强缓存（不需要发送 HTTP）

- **Expires** **存在于 HTTP 1**

  `Expires`即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。表示资源在`2019年11月22号8点41分`过期，过期了就得向服务端发请求。

  ```reStructuredText
  Expires: Wed, 22 Nov 2019 08:41:00 GMT
  ```

  缺点：服务器的时间和浏览器的时间可能并不一致导致这个过期时间就是不准确的。也可能用户修改本地时间，也会失效。

- **Cache-Control** **存在于 HTTP 1.1**

  它和`Expires`本质的不同在于它并没有采用`具体的过期时间点`这个方式，而是采用过期时间来控制缓存，对应的字段是**max-age**。代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。

  ```reStructuredText
  Cache-Control: max-age=3600
  ```

  它可以组合很多指令

  ![img](https://pic4.zhimg.com/80/v2-25f787baf5cbdb3bfa91fc41c5618e97_720w.jpg)

值得注意的是，当**Expires**和**Cache-Control**同时存在的时候，**Cache-Control**会优先考虑。

#### 协商缓存 需要发送 HTTP 由服务器决定是否采用

协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

- 协商缓存生效，返回 304 和 Not Modified
- 协商缓存失效，返回 200 和请求结果

协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

- Last-Modified 和 If-Modified-Since

  即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

  浏览器接收到后，如果第二次再发起这个请求，则会在请求头中携带`If-Modified-Since`字段，值就是 Last-Modified 中的值。

  服务器拿到请求头中的`If-Modified-Since`的字段后，会和这个服务器中`该资源的最后修改时间`对比:

  - 如果请求头中的这个值小于最后修改时间，说明有更新。返回新的资源和 200，跟常规的 HTTP 请求响应的流程一样。
  - 如果没有变化则返回 304 和空的响应体，告诉浏览器直接用缓存。

  缺点：

- ETag 和 If-None-Match

  `ETag` 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过`响应头`把这个值给浏览器。

  浏览器接收到`ETag`的值，会在下次请求时，将这个值作为**If-None-Match**这个字段的内容，并放到请求头中，然后发给服务器。

  服务器接收到**If-None-Match**后，会跟服务器上该资源的**ETag**进行比对:

  - 如果两者不一样，说明要更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。
  - 否则返回 304，告诉浏览器直接用缓存。

#### 两者对比

1. 在`精准度`上，`ETag`优于`Last-Modified`。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:
   - 如果本地打开或编辑了缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
   - 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源
2. 在性能上，`Last-Modified`优于`ETag`，也很简单理解，`Last-Modified`仅仅只是记录一个时间点，而 `Etag`需要根据文件的具体内容生成哈希值。

另外，如果两种方式都支持的话，服务器会优先考虑`ETag`。

#### 缓存位置

前面我们已经提到，当`强缓存`命中或者协商缓存中服务器返回 304 的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

1. Service Worker

   Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们**自由控制**缓存哪些文件、如何匹配缓存、如何读取缓存，并且**缓存是持续性的**。

   当 Service Worker 没有命中缓存的时候，我们需要去调用 `fetch` 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

2. Memory Cache

   **Memory Cache**指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当进程结束后，内存缓存也就不存在了。

3. Disk Cache

   **Disk Cache**就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。

   - 比较大的 JS、CSS 文件会直接被丢进磁盘，反之丢进内存

- 内存使用率比较高的时候，文件优先进入磁盘

4. Push Cache

   即推送缓存，这是浏览器缓存的最后一道防线。它是 `HTTP/2` 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。

#### 总结

对浏览器的缓存机制来做个简要的总结:

首先通过 `Cache-Control` 验证强缓存是否可用

- 如果强缓存可用，直接使用

- 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的

  ```
  If-Modified-Since
  ```

  或者

  ```
  If-None-Match
  ```

  这些条件请求字段检查资源是否更新

  - 若资源更新，返回资源和 200 状态码
  - 否则，返回 304，告诉浏览器直接从缓存获取资源
  - 如果什么缓存策略都没有设置，那么浏览器会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间

![img](https://user-gold-cdn.xitu.io/2020/4/5/1714a298b93c3208?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 使用场景

- 频繁变动的资源

对于频繁变动的资源，首先需要使用 `Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 `ETag` 或者 `Last-Modified` 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

- 代码文件

这里特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。

一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 `Cache-Control: max-age=31536000`，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。

## 浏览器的本地存储

#### Cookie

由于 HTTP 协议是无状态协议，Cookie 最开始是为了做状态存储的。

缺点

1. 容量缺陷。Cookie 的体积上限只有`4KB`，只能用来存储少量的信息。
2. 性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。
3. 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在`HttpOnly`为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

|   属性    |                              作用                              |
| :-------: | :------------------------------------------------------------: |
|   value   | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 |
| http-only |             不能通过 JS 访问 Cookie，减少 XSS 攻击             |
|  secure   |                只能在协议为 HTTPS 的请求中携带                 |
| same-site |     规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击      |

#### localStorage

- 和 Cookie 异同

`localStorage`有一点跟`Cookie`一样，就是针对一个域名，即在同一个域名下，会存储相同的一段**localStorage**。

不过它相对`Cookie`还是有相当多的区别的:

1. 容量。localStorage 的容量上限为**5M**，相比于`Cookie`的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。
2. 只存在客户端，默认不参与服务端的通信。这样就很好地避免了 Cookie 带来的**性能问题**和**安全问题**。
3. 接口封装。通过`localStorage`暴露在全局，并通过它的 `setItem` 和 `getItem`等方法进行操作，非常方便

- 应用场景

利用`localStorage`的较大容量和持久特性，可以利用`localStorage`存储一些内容稳定的资源，比如官网的`logo`，存储`Base64`格式的图片资源，因此利用`localStorage`

#### sessionStorage

- 特点

  `sessionStorage`以下方面和`localStorage`一致:

  - 容量。容量上限也为 5M。
  - 只存在客户端，默认不参与与服务端的通信。
  - 接口封装。除了`sessionStorage`名字有所变化，存储方式、操作方式均和`localStorage`一样。

  但`sessionStorage`和`localStorage`有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分`sessionStorage`就不复存在了。

- 应用场景
  1. 可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
  2. 可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用`sessionStorage`就再合适不过了。事实上微博就采取了这样的存储方式。

#### IndexDB

`IndexDB`是运行在浏览器中的`非关系型数据库`, 本质上是数据库，绝不是和刚才 WebStorage 的 5M 一个量级，理论上这个容量是没有上限的。

#### Service Worker

Service Worker 是运行在浏览器背后的**独立线程**，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 **HTTPS**。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。

Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 `install` 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

## 实现图片懒加载

1. 给 scroll 添加监听事件，进行节流处理，通过 clientHeight、scrollTop 和 offsetTop 判断元素是否出现在视图中

2. 给 scroll 添加监听事件，进行节流处理，通过 getBoundingClientRect 判断元素是否出现在视图中

3. 采用 IntersectionObserver API，其可以实现监听 window 的 scroll 事件，判断是否在视图中及节流功能

   ```js
   let img = document.document.getElementsByTagName('img');

   const observer = new IntersectionObserver((changes) => {
     //changes 是被观察的元素集合
     for (let i = 0, len = changes.length; i < len; i++) {
       let change = changes[i];
       // 通过这个属性判断是否在视口中
       if (change.isIntersecting) {
         const imgElement = change.target;
         imgElement.src = imgElement.getAttribute('data-src');
         observer.unobserve(imgElement);
       }
     }
   });

   observer.observe(img);
   ```

## 做过 H5 页面没有？你怎样适配移动端的

在程序初始化的时候可以使用以下方式来修改根节点的字体大小：

(假设你需要的`1rem = 20px`)

```js
(function () {
  var html = document.documentElement;
  function onWindowResize() {
    html.style.fontSize = html.getBoundingClientRect().width / 20 + 'px';
  }
  window.addEventListener('resize', onWindowResize);
  onWindowResize();
})();
```

- `document.documentElement`：获取`document`的根元素
- `html.getBoundingClientRect().width`：获取`html`的宽度(窗口的宽度)
- 监听`window`的`resize`事件

一般还需要配合一个`meta`头：

```html
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, minimum-sacle=1.0, maximum-scale=1.0, user-scalable=no"
/>
```

## 为何会出现浏览器兼容问题

渐进增强：针对低版本浏览器开发基本的功能，在高级版本浏览器里用更好的效果提升用户体验。

优雅降级：从一开始就构建完整更好的效果，针对低版本浏览器进行兼容。

处理兼容问题的思路：

1. 产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）

2. 成本的角度 (有无必要做某件事)

   - 做到什么程度，让哪些浏览器支持哪些效果

- 如何做：根据兼容需求选择技术框架/库(jquery)，可以选择兼容工具(css reset、normalize.css、 条件注释、js 能力检测)做一些修补

## 白屏时间

白屏时间是指浏览器从输入网址，到浏览器开始显示内容的时间。

`startTime`：有些浏览器实现为`navigationStart`，代表浏览器开始 unload 前一个页面文档的开始时间节点。比如我们当前正在浏览 baidu.com，在地址栏输入 google.com 并回车，浏览器的执行动作依次为：unload 当前文档（即 baidu.com）->请求下一文档（即 google.com）。navigationStart 的值便是触发 unload 当前文档的时间节点。如果当前文档为空，则 navigationStart 的值等于 fetchStart。

`domLoading`代表浏览器开始解析 html 文档的时间节点。我们知道 IE 浏览器下的 document 有 readyState 属性，domLoading 的值就等于 readyState 改变为 loading 的时间节点；

白屏时间

```js
performance.timing.domLoading -
  (performance.timing.navigationStart || performance.timing.pageStartTime);
```

## 首屏时间

首屏时间：从浏览器输入地址并回车后到首屏内容渲染完毕的时间

`domContentLoadedEventStart`：代表 DOMContentLoaded 事件触发的时间节点： 页面文档完全加载并解析完毕之后,会触发 DOMContentLoaded 事件，HTML 文档不会等待样式文件,图片文件,子框架页面的加载(load 事件可以用来检测 HTML 页面是否完全加载完毕(fully-loaded))。

- 如果页面首屏没有图片

```js
performance.timing.domContentLoadedEventStart - performance.timing.navigationStart;
```

- H5 如果页面首屏有图片可以在每个 img 中添加 onload 时间并绑定到 window 属性上, 等 window.onload 事件触发再进行计算

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>首屏</title>
    <script>
      // 不兼容 performance.timing 的浏览器
      window.pageStartTime = Date.now();
    </script>
  </head>
  <body>
    <img src="https://lz5z.com/assets/img/google_atf.png" alt="img" onload="load()" />
    <img src="https://lz5z.com/assets/img/css3_gpu_speedup.png" alt="img" onload="load()" />
    <script>
      function load() {
        window.firstScreen = Date.now();
      }
      window.onload = function () {
        // 首屏时间
        console.log(window.firstScreen - performance.timing.navigationStart);
      };
    </script>
  </body>
</html>
```

```reStructuredText
首屏图片全部加载完毕的时刻 - performance.timing.navigationStart
```

## 跨域通信的几种方式

- JSONP(利用 script 标签的异步加载实现的)
- WebSocket
- cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息
- 反向代理 nginx 服务内部配置 Access-Control-Allow-Origin \*

## 什么是跨域？浏览器如何拦截响应？如何解决？

回顾一下 URI 的组成:

[![img](http://47.98.159.95/my_blog/http/004.png)](http://47.98.159.95/my_blog/http/004.png)

浏览器遵循**同源政策**(`scheme(协议)`、`host(主机)`和`port(端口)`都相同则为`同源`)。非同源站点有这样一些限制:

- 不能读取和修改对方的 DOM 银行系统嵌入恶意网站进行读取操作
- 不读访问对方的 Cookie、IndexDB 和 LocalStorage
- 限制 XMLHttpRequest 请求。 登录用户 Cookie 进行 CSRF 攻击

跨域只存在于浏览器端。浏览器它为`web`提供了访问入口，并且访问的方式很简单，在地址栏输入要访问的地址或者点击某个链接就可以了，正是这种**开放的形态**，所以我们需要对它有所限制。

渲染进程被装进了沙箱，以防止黑客触碰到系统资源，在沙箱里是无法发送网络请求的，所以需要主进程来发送。

发送到服务端之后，将响应返回，主进程检查到跨域，且没有 cors(后面会详细说)响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。

#### JSONP

虽然`XMLHttpRequest`对象遵循同源政策，但是`script`标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。和`CORS`相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。

```js
const jsonp = ({ url, params, callbackName }) => {
  const generateURL = (callback) => {
    const allParams = { ...params, callback };
    const dataStr = Object.entries(allParams).reduce((acc, [key, value]) => {
      return `${acc}${key}=${value}&`;
    }, '');
    return `${url}?${dataStr}`;
  };

  return new Promise((resolve) => {
    // 初始化回调函数名称
    const callback = callbackName || `callback${Date.now()}`;
    // 创建 script 元素并加入到当前文档中
    const scriptEle = document.createElement('script');
    scriptEle.src = generateURL(callback);
    document.body.appendChild(scriptEle);
    // 绑定到 window 上，为了后面调用
    window[callback] = (data) => {
      resolve(data);
      // script 执行完了，成为无用元素，需要清除
      document.body.removeChild(scriptEle);
    };
  });
};

jsonp({
  url: 'http://localhost:3000',
  params: {
    a: 1,
    b: 2,
  },
}).then((data) => {
  console.log('data: ', data);
  // 拿到数据进行处理
  // 数据包
});
```

当然在服务端也会有响应的操作, 以 express 为例:

```js
let express = require('express');
let app = express();
app.get('/', function (req, res) {
  let { a, b, callback } = req.query;
  console.log(a); // 1
  console.log(b); // 2
  // 注意哦，返回给script标签，浏览器直接把这部分字符串执行
  res.end(`${callback}('数据包')`);
});
app.listen(3000);
```

#### Nginx 做反向代理设置设置 Header 头

Nginx 相当于起了一个跳板机，这个跳板机的域名也是`client.com`，让客户端首先访问 `client.com/api`，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给`server.com`，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。

```
server {
  listen  80;
  server_name  client.com;
  location /api {
    proxy_pass server.com;
  }
}
```

#### CORS

跨域资源共享，需要浏览器支持和后端服务支持。

一些重要的 Response 头

- 最重要的 通过 Access-Control-Allow-Origin 来判断请求头里的 Origin 是否在其中。判断是否是跨域请求。
- Access-Control-Allow-Credentials 表示是否允许发送 Cookie

* 简单请求
  - 请求方法为 GET、POST 或者 HEAD
  - 请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`)
* 除了上述情况就非简单请求

非简单请求流程

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

会先发送预检请求， 这个请求对服务器是安全的，也就是说不会对服务器的资源做任何改变，仅仅用于确认 header 响应

请求如下

```http
OPTIONS / HTTP/1.1
// 当前请求地址
Origin: 当前地址
// 目标地址
Host: xxx.com
// 这次请求要用到的HTTP方法
Access-Control-Request-Method: PUT
```

响应如下

```http
HTTP/1.1 200 OK
// 表示可以允许请求的源，可以填具体的源名，也可以填`*`表示允许任意源请求
Access-Control-Allow-Origin: *
// 表示允许的请求方法列表。
Access-Control-Allow-Methods: GET, POST, PUT
// 表示允许携带Cookie
Access-Control-Allow-Credentials: true
// 预检请求的有效期，在此期间，不用发出另外一条预检请求。
Access-Control-Max-Age: 1728000
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
```

如果成功则进行下步真正发送请求。

## Ajax 和 Fetch 区别

- Ajax 是使用 XMLHttpRequest 对象发起的，但是用起来很麻烦，所以 ES6 新规范就有了 fetch，fetch 发一个请求不用像 ajax 那样写一大堆代码。

- 使用 fetch 无法取消一个请求，这是因为 fetch 基于 Promise，而 Promise 无法做到这一点。

- 在默认情况下，fetch 不会发送 cookies

- fetch 没有办法原生监测请求的进度，而 XMLHttpRequest 可以

- fetch 只对网络请求报错，对 400，500 都当做成功的请求，需要封装去处理

- fetch 由于是 ES6 规范，兼容性上比不上 XMLHttpRequest

## 前端项目如何找出性能瓶颈

前端的性能一般能在用户层面体现出来， 需要针对具体表现进行分析具体解决。比如页面首页加载过慢，则有可能时请求资源过多，资源太大，没有压缩，没有缓存，那这样就可以减少 http 请求转换 base64，压缩资源，设置缓存等。再比如列表滑动加载数据比较卡，那么有可能时频繁请求操作，数据比较大，那就可以做懒加载，函数节流等。

## 页面性能

- 网络

  1. DNS 进行域名预解析

     ```html
     <link rel="dns-prefetch" href="//yuchengkai.cn" />
     ```

  2. 使用 CDN 尽可能的在各个地方分布机房缓存数据，可通过最近的机房迅速加载资源

  3. 采用 Nginx 的 gzip 压缩

- 浏览器缓存角度

  1. 利用浏览器缓存 强缓存和协商缓存 或者代理缓存

- 资源角度

  - 减小文件资源大小

    1. webpack 代码分割，根据首页是否加载使用进行分割
    2. 三方库采用按需加载
    3. 图片加载优化 1.小图采用 base64，将多个图标文件整合到一个图片中 2. 选择正确的图片格式，可以使用 WebP 格式，一些图标也可以使用字体代替

- 资源加载顺序

  1. script 标签上的使用 async defer

     - 脚本与 DOM 元素或者其他脚本依赖关系不强时，选用 async，下载完立即执行
       - 依赖 DOM 元素或者其他脚本，选用 defer，下载完等待 html 解析完成在执行

  2. 合理使用 link 标签的 rel 属性设置 prefetch 和 preload

     ```html
     <!-- preload 下载顺序权重提高，可以放一些页面必须的 web 字体包，因中文字体包一般较大。 -->
     <link rel="preload" href="fonts" />
     ```

     ```html
     <!-- prefetch 告诉浏览器这个资源将来可能需要，不会阻塞onload事件。但是什么时间加载这个资源是由浏览器来决定的，可以加速下一次的导航。 -->
     <link rel="prefetch" href="/library.js" as="script" />
     ```

  3. 懒加载

     将不关键的资源延后加载，比如图片，视频等

- 代码书写角度

  1. 编写高效的 CSS 脚本，尽量使用短的匹配语句和避免使用标签和通用选择器
  2. 节流： 滚动事件请求接口进行节流
  3. 防抖：一个按钮点击就触发网络请求，点完一段时间没有点击再触发。
  4. V8 角度：让 V8 生成更多的机器码，尽量编写传入参数类型一致的函数。但 TS 仅在开发阶段保持类型，编译后还是会变成 JS，V8 还是不能确定函数的参数类型。

## target 和 currentTarget 区别

- event.target 返回触发事件的元素
- event.currentTarget 返回绑定事件的元素

## 事件委托 / 代理

事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。不需要给每一个元素绑定事件，节省内存，在

所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。

- 节省内存
- 不需要给子节点注销事件

## DOM 事件模型及阻止冒泡和阻止默认行为

事件捕获阶段 处于目标阶段 事件冒泡阶段

但也有特例，比如在一个 body 中的元素同事注册冒泡和捕获，则会按照注册的顺序执行。

具体流程捕获的流程为：window -> document -> html -> body -> ... -> 目标元素。

冒泡的流程为：目标元素 -> ... -> body -> html -> document -> window。

默认是在冒泡阶段，为事件代理提供条件。

1. event.stopPropagation() 阻止冒泡。
2. event.stopImmediatePropagation() 阻止冒泡，也阻止其他绑定事件。
3. event. preventDefault() 阻止默认行为 例如 a 标签跳转 ，form 表单提交跳转

## addEventListener 函数的参数

type：表示监听事件类型的字符串

listener：监听事件的回调

options：

指定有关 listener 属性的可选参数对象。

1. 可以是布尔值 useCapture

   - 为 true 时，在捕获阶段调用，默认为 false，在冒泡阶段调用。

2. 可以是对象

   - once 表示添加后只执行一次，执行完会被移除。

   - passive 表示该 listener 永远不会调用 preventDefault()

   - capture 同 useCapture

## 所有的事件都有冒泡吗？

并不是所有的事件都有冒泡的，例如以下事件就没有：

- `onblur`
- `onfocus`
- `onmouseenter`
- `onmouseleave`

## 事件绑定的方式

- 嵌入 dom

```html
<button onclick="func()">按钮</button>
```

- 直接绑定

```html
btn.onclick = function(){}
```

- 事件监听

```html
btn.addEventListener('click',function(){})
```

## 有写过原生的自定义事件吗

- 使用`Event`
- 使用`customEvent` （可以传参数）
- 使用`document.createEvent('CustomEvent')和initEvent()`

**创建自定义事件**

原生自定义事件有三种写法：

1. 使用 Event

```js
let myEvent = new Event('event_name');
```

2. 使用 CustomEvent （可以传参数）

```js
let myEvent = new CustomEvent('event_name', {
  detail: {
    // 将需要传递的参数放到这里
    // 可以在监听的回调函数中获取到：event.detail
  },
});
```

3. 使用 document.createEvent('CustomEvent') 和 initEvent()

```js
let myEvent = document.createEvent('CustomEvent'); // 注意这里是为'CustomEvent'
myEvent
  .initEvent
  // 1. event_name: 事件名称
  // 2. canBubble: 是否冒泡
  // 3. cancelable: 是否可以取消默认行为
  ();
```

**事件的监听**

自定义事件的监听其实和普通事件的一样，使用`addEventListener`来监听：

```
button.addEventListener('event_name', function (e) {})
```

**事件的触发**

触发自定义事件使用`dispatchEvent(myEvent)`。

注意 ，这里的参数是要自定义事件的对象(也就是`myEvent`)，而不是自定义事件的名称(`'myEvent'`)

**案例**

来看个案例吧：

```js
// 1.
// let myEvent = new Event('myEvent');
// 2.
// let myEvent = new CustomEvent('myEvent', {
//   detail: {
//     name: 'lindaidai'
//   }
// })
// 3.
let myEvent = document.createEvent('CustomEvent');
myEvent.initEvent('myEvent', true, true);

let btn = document.getElementsByTagName('button')[0];
btn.addEventListener('myEvent', function (e) {
  console.log(e);
  console.log(e.detail);
});
setTimeout(() => {
  btn.dispatchEvent(myEvent);
}, 2000);
```

1.
