[TOC]

## cookie 和 session 的区别

1. cookie 数据存放在客户的浏览器（客户端）上，session 数据放在服务器上
2. session 的生成可依赖在 cookie 上，也可将其附在 URL 上。
3. cookie 不是很安全，session 相对安全
4. 在访问增多时，session 增多会影响服务器性能。

## DNS 查询详细

就是通过域名来查询到具体的 IP，DNS 是应用层协议，基于 UDP 传输层协议之上，因为 TCP 的消耗太大，需要三次握手，四次挥手，，一个查询包一个响应包，而 UDP 只要两个包一个查询包，一个响应包。

1. 在本地的 hosts 文件和本地的 DNS 解析器缓存里进行查找，linux 在/etc/hosts
2. 去系统配置的 DNS 服务器中查找
3. 去 DNS 根服务器查找，这一步会找到负责.com 一级域名的服务器
4. 然后去该服务器查找下一级比如 google
5. 然后再去查找下一级，直到找到 www.google.com 主机

从客户端到本地 DNS 服务器是递归查询，DNS 服务器之间的查询是迭代查询。

## websocket 用法，鉴权，房间分配，心跳机制，重连方案等。

长轮询底层还是 HTTP 协议，是一问一答，不过加长了连接时间。

与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

客户端发送 GET 请求，并携带 Upgrade: websocket 和 Connection: Upgrade 代表发起的是 WS 协议，并携带一个 Sec-WebSocket-Key 是由浏览器随机生成的，提供基本的防护，防止恶意或无意的连接。

服务端给客户端 101 表示已经理解了客户端的请求，并通过 Upgrade: websocket 通知客户端采用不同的协议完成这个请求。

Sec-WebSocket-Accept 是经过服务器确认，并且加密后的 Sec-WebSocket-Key，这个换算只能带来基本的保障。

鉴权：可通过 HTTP 握手时携带一些 Header，也可以在 URL 后面拼接 token 等等

房间分配：同一连接进入一个房间，发布订阅的方式，通知到每一个连接，不是同一连接则进入另一个房间。

心跳机制：就是为了保证连接状态，断开时让客户端和服务端都知道，进而重连。实现就是客户端定时发送 ping 消息，服务端收到之后发送 pong，如果出现异常则重连。

重连方案：需要设置锁和重连次数，避免出现无限重连情况，可设置 5 秒重试一次，最多 12 次等等。

- cdn 服务搭建

- 学习过图形学相关知识，知道矩阵等数学原理在动画中的作用，知道三维场景需要的最基础的构成，能用 threejs 搭 3d 场景，知道 webgl 和 threejs 的关系。

- 知道 css 动画，css 动画属性知道关键字和用法(换句话说，电话面试会当场出题要求口喷 css 动画，至少能说对大概，而不是回答百度一下就会用)。

- 知道 js 动画，能说出 1~2 个社区 js 动画库，知道 js 动画和 css 动画优缺点以及适用场景。

- 如果没有 threejs，你也能基于 webgl 自己封装一个简单的 threejs 出来

- 聊到原理能说出四元数，聊到鼠标操作能提到节流，聊到性能能提到 restore，聊到帧说出 raf 和 timeout 的区别，以及各自在优化时候的作用。

- 知道怎样在移动端处理加载问题，渲染性能问题。

- 知道如何结合 native 能力优化性能。

- 知道如何排查性能问题。对 chrome 动画、3d、传感器调试十分了解。

- 埋点方案，能够说明白前端埋点方案技术底层实现，以及技术选型原理。能够设计出基于埋点的数据采集和分析方案，关键字包括：分桶策略，采样率，时序性，数据仓库，数据清洗等。

- 微前端 有基于全家桶构建复杂应用的经验，比如最近很火的微前端和这些类库结合的时候要注意什么，会有什么坑，怎么解决

- 数据 mock 方案，mock 方案，能够设计出满足各种场景需要的 mock 数据方案，同时能说出对前后端分离的理解。考虑 mock 方案的通用性、场景覆盖度，以及代码或工程侵入程度。

- pc 端与移动端登录态维护方案，知道 token base 登录态实现细节，知道服务端 session 控制实现，关键字：refresh token。

- 知道 oauth2.0 轻量与完整实现原理。

- 静态文件的浏览器缓存如何实现?

- 移动端如何实现下拉到底部 跟随移动 结束后回弹的动画?

- 移动端如何优化首页白屏时间过长 ?

- 移动端高清方案如何解决

- ES6 generator 函数简述

- 如何定位性能问题

- 动态规划

- 错误监控， 收集，分析

- 为什么生成了 CSSOM 树这样的结构

- css hack 实现方案和优化方案的原理

- 登陆表单如何实现；cookie 登录态维护方案；token base 登录态方案；session 概念；如何完成一个登录模块

- 知道 antd 组件化设计思路。

- 能结合 redux，vuex，mobx 等数据流谈谈自己对 vue 和 react 的异同。

- 了解异步模块加载的实现原理，能口喷代码实现核心逻辑。

- animation 实现原理

- 文件上传实现

## 重绘和重排具体，触发回流的方式？触发回流的次数

## webpack 基础配置

通过配置一个入口文件，以及打包之后的出口文件，配置一些 loader 作为模块的翻译器，配置一些 Plugin 扩展插件，在 webpack 生命周期中某个指定时间段进行扩展。

还可以配置一些 devServer 的端口等等。

## webpack 中的 Tree Shaking

可以删除项目中未被引用的代码。

## webpack，rollup 以及他们适用的场景

Rollup 偏向应用于 JS 库，只是 JS 代码，仅仅希望做 ES 转换，模块解析。

Webpack 涉及到前端工程，包含 css，html 等。

## 常见 Webpack 的 Loader

Vue-loader ：将 Vue 组件转换为 js 模块。

## index.js 和 runtime.js

runtime.js 文件相当于动态文件的索引文件，相当于一个文件夹中的 index 索引文件，告诉 main.js 要引用的文件的名字。

## webpack 性能优化

减少构建时间

首先可指定打包的范围，例如 babel-loader 不检查 node_modules 中的代码。

可开启多线程进行打包优化

采用 DllPlugin 将不经常变的特定的类库提前打包引入。

按需加载

Tree Shaking：删除项目中未被引入的代码。

## 代码分割是怎么个加载形式

三方库按需加载可以用 Babel 的插件 babel-plugin-import

- 知道 webpack 打包结果的代码结构和执行流程，知道 index.js，runtime.js 是干嘛的。
- 知道所有模块化标准。定义一个模块怎么写。给出 2 个文件，能口喷一段代码完成模块打包和执行的核心逻辑。
- 知道 webpack 打包链路，知道 plugin 生命周期，知道怎么写一个 plugin 和 loader。
- 能结合性能优化聊 webpack 配置怎么做，能清楚说明白核心要点有哪些，并说明解决什么问题，需要哪些外部依赖，比如 cdn，接入层等。

## raf 和其他达到 60fps 的方法。

`requestAnimationFrame`是浏览器用于定时循环操作的一个接口，类似于`setTimeout`，主要用途是按帧对网页进行重绘。对于`JS`动画，用`requestAnimationFrame` 会比 `setInterval` 效果更好。

- 知道 diff 算法大致实现思路。
- react 内部的 diff 算法是怎么样的？带来了什么？为什么要使用？
- 知道 react 大致实现思路，能对比 react 和 js 控制原生 dom 的差异，能口喷一个简化版的 react。
- 能用自己的理解说明白 react like 框架的本质，能说明白如何让这些框架共存。

## react 中两大部分

O(n^3)：因为要找到两个树的最小更新方式，所以需要两两对比每个叶子节点是否相同，对比需要 O(n^2)，找到差异后还需要计算最小转换方式，所以为 O(n^3)

Diff 采取三个最主要的策略来将算法复杂度降低

1. Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。

   基于策略 1：tree diff

   会对树进行分层比较，只会对比同一层的节点。

   但如果发现节点跨层级移动操作，会简单的销毁，然后重新创建。会影响性能。

2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。

   基于策略 2：component diff

   如果是同一类型。则会按照原策略比较虚拟 DOM，但开发者可手动设置 shouldComponentUpdate()确定是否需要比较

   不同类型，则直接删除，重新创建。

3. 对于同一层级的一组子节点，它们可以通过唯一 key 进行区分。

   基于策略 3：element diff

   处于同一层级，可通过 key 进行区分，存在相同节点会进行复用移动，不存在则删除或重建。

虚拟 DOM

1. 用一个 JS 对象去表示 DOM 树的结构，然后用这个对象树构建一个真实的树，插到文档中。

2. 当状态变更时，重新构造一个新的对象树，和旧的对象树做比较，

   利用 diff 算法生成一个 patches 对象，也就是两个树的差异对象。

3. 把差异应用到真实 DOM 上。

## React 中 key 的作用

key 帮助 React 识别哪些元素改变了

如果没有设置数组里的 key，在一个个手动创建时会提升创建速度，会就地复用。

但常用会是通过 map 方法，如果没添加 key 的话，会默认使用数组的 index 作为 key，这样如果 unshift 一项，则会导致后面两项重新创建并渲染，不然的话是可以复用的。

## react 常用的生命周期

constructor

componentDidMount()

render()

static getDerivedStateFromProps(props, state)

shouldComponentUpdate(nextProps, nextState)

componentDidUpdate(prevProps, prevState, snapshot)

componentWillUnmount()

## window 的 onload 事件和 domcontentloaded 谁先谁后

onload：页面上所有的 DOM，样式表，脚本，图片，flash 都已经加载完成。

DOMContentLoaded：仅当 DOM 加载完成，不包含样式表，图片，flash。

## worker 有哪几种？

worker 没有获取 DOM 的权限

1. Web Worker 作用是为 JS 创造多线程环境，允许主线程创建 Worker 线程，分给后者允许。可使用 Worker 线程完成轮询。

   ```js
   // 参数是一个脚本文本，这个脚本必须来自网络，不能加载本地。
   var worker = new Worker('work.js');

   // 向Worker发消息
   worker.postMessage('Hello World');
   worker.postMessage({ method: 'echo', args: ['Work'] });

   // 监听函数，接收子线程发回来的消息
   worker.onmessage = function (event) {
     console.log('Received message ' + event.data);
     doSomething();
   };
   ```

2. Service Worker 是一个在浏览器后台运行的脚本，与网页不相干，专注于那些不需要网页或用户互动就能完成的功能。它主要用于操作离线缓存。

   通过拦截网络请求，使得网站运行得更快，或者在离线情况下，依然可以执行。

   作为其他后台功能的基础，比如消息推送和背景同步。

   缓存会是持续的。就算没命中缓存，从 memory 或是网络中获取，都显示来源于 Service Worker。

## immutable

最大的特点就是持久化数据结构和结构共享。

持久化数据结构是指一旦创建，想要更新或修改都会返回一个新的 immutable 对象。

结构共享是指在更新一个数据的时候，没改变的数据会共有一个引用，这样会减少深拷贝的性能消耗，也减少了内存。

其实最主要还是需要有优化的意识，熟悉 js 引用类型的特性，简单的更新完全可以不用 immutable，比如解构啊，map 操作数组啊，返回一个新的引用，但这些操作一层还好，如果深层次赋值 immutable 就能体现出他的能力了。而且这个框架有学习成本，有些时候调试也不太方便。

## 实现简单版深拷贝

```js
// JSON.parse(JSON.stringify(e))

const deepClone = (e) => {
  if (e === null) return null;
  if (typeof e !== 'object' || typeof e !== 'function') return e;
  if (e instanceof RegExp) return new RegExp(e);
  if (e instanceof Date) return new Date(e);

  const { constructor } = Object.getPrototypeOf(e);
  const newObj = new constructor();
  Object.keys(e).forEach((key) => {
    newObj[key] = deepClone(e[key]);
  });

  return newObj;
};

const a = { name: 1, xx: { a: 2, b: '3', c: true, d: [23] } };

console.log(deepClone(a));
```

## Redux

### 适用场景

多组件之间的状态共享。要做的是让 state 的变化可预测，单向数据流，更能及时发现错误。

### 宏观原理

redux 是将整个应用的状态存储在一个 store 中，属于单例模式的设计思想。组件可以通过 dispatch 一个 action 来调用 reducer 实现修改 store，其他组件内部通过订阅 store 中的状态来刷新自己的视图。

单向数据流，只能通过 reducer 修改状态返回一个新的状态。

Action 就是一个对象，包含一个 type，表示 action 的名称，其他属性可以自由设置。

dispatch 就是 view 发出 Action 的唯一方法，dispatch 接收一个 action 作为参数。

Reducer 是一个纯函数，就是同样的输入必定得到同样的输出。它接受 Action 和当前 State 作为参数，返回一个新的 State。

store 就是一个存储状态的对象，包含所有数据，如果想得到某个时点的数据，就需要对其生成快照，这个时点数据的集合叫 State。

它具有 store.getState()，store.dispatch()，store.subscribe()方法，通过 createStore 创建。

对于 store.subscribe()，一旦 State 发生变化，就自动执行里面的函数，且他返回一个函数，调用这个函数就可以解除监听。

```javascript
let unsubscribe = store.subscribe(() => console.log(store.getState()));

unsubscribe();
```

createStore 接收的参数

```javascript
const store = createStore(
  reducer,
  initial_state,
  // 中间件的次序有讲究，需要查看文档。
  // 会依次执行
  applyMiddleware(thunk, promise, logger),
);
```

## 触发 action 如何指派到对应的 reducer

dispatch 会触发 reducer 的自动执行，做法就是将 reducer 传入 CreateStore 中。然后再根据 action 的 type 来决定触发对应的 reducer

## 原生 js 和 redux 结合

可能最重要的点就是 store.subscribe，在 react-redux 帮我们做了这一层，就是在 State 发现变化后，立即调用这个里面包裹的监听方法，实现更新。

## redux-thunk 做什么？

```javascript
const fetchPosts = postTitle => (dispatch, getState) => {
  dispatch(requestPosts(postTitle));
  return fetch(`/some/API/${postTitle}.json`)
    .then(response => response.json())
    .then(json => dispatch(receivePosts(postTitle, json)));
  };
};

// 使用方法一
store.dispatch(fetchPosts('reactjs'));
// 使用方法二
store.dispatch(fetchPosts('reactjs')).then(() =>
  console.log(store.getState())
);
```

写一个返回函数的 Action Creator，使用 redux-thunk 中间件改造 store.dispatch 对其功能增强。可以在 reducer 中进行一些异步操作。

## 知道 thunk 干嘛用的，怎么实现的。

## react-redux

```javascript
import { connect } from 'react-redux';

const VisibleTodoList = connect(mapStateToProps, mapDispatchToProps)(TodoList);
```

两个参数

1. mapStateToProps 负责输入，将 state 映射到组件的 props。是一个函数，会订阅 Store，每当 state 更新，就会自动执行。可以省略，就不会订阅 Store，不会引起更新。

   ```javascript
   const mapStateToProps = (state, ownProps) => {
     return {
       active: ownProps.filter === state.visibilityFilter,
     };
   };
   ```

2. mapDispatchToProps 负责输出，将操作映射成 Action。可以是一个函数，也可以是对象，作为函数时，应当返回一个对象。

   ```javascript
   const mapDispatchToProps = (
     dispatch,
     ownProps
   ) => {
     return {
       onClick: () => {
         dispatch({
           type: 'SET_VISIBILITY_FILTER',
           filter: ownProps.filter
         });
       }
     };
   }

   // 或
   const mapDispatchToProps = {
     onClick: (filter) => {
       type: 'SET_VISIBILITY_FILTER',
       filter: filter
     };
   }
   ```

## React-Redux 中的 Provider 组件

是为了让多层级下的组件都可以拿到 state

原理是 React 组件的 context 属性。store 放在了上下文对象 context 上面。

```javascript
// 原理
class Provider extends Component {
  getChildContext() {
    return {
      store: this.props.store,
    };
  }
  render() {
    return this.props.children;
  }
}
// 使用
const Root = ({ store }) => (
  <Provider store={store}>
    <Router>
      <Route path="/" component={App} />
    </Router>
  </Provider>
);
```

所以其下层组件里都被 react-redux 包裹了一层。

## react 中的 context

## react 中的 portal

## ToB 和 ToC 的区别

ToB：面向企业，关注的是效率提升，看中的是稳定和方便，不能随意操作，试错空间小。

ToC：面向用户，关注的是用户体验，看中的是体验和美观，可适当进行操作，有流量思维，如何吸引用户去使用。

## 虚拟滚动

数据量较大，仅显示需要看见的部分，其他部分不进行渲染。

原理就是截取数组部分，仅显示当前需要看见的部分。

有一个列表容器和一个可滚动的定高的容器

## Echarts 你是怎么封装的，有性能卡顿问题吗？echarts 卸载时需要注意的点

按需加载，使用 import 方法的形式。

采用 immutable 持久化数据结构，深层次赋值，返回一个新的 options。

遇到一个 websocket 推送数据进行更新问题，这个数据是后端推过来，然后可能会造成频繁更新数据的情况，会对性能有一定的影响，所以我的方案是加一个缓冲池。

具体设计就是节流，把推送过来的数据先放入数组里，然后进行节流，设置一个缓存时间等时间到了，再一起加入到 options 中。

假如每一秒有一条数据需要渲染，10 秒就是 10 次，但我可以将其设置为 2 秒一次，这样就会将渲染次数减倍，也就是将性能提升了一倍。

## 怎么用过 svg 和 canvas

svg：一种基于 XML 语法的图像格式，全称是可缩放矢量图。是属于对图像的形状描述，所以本质是文本文件，体积较小，不管放大多少都不会失真。

M 移动到（moveto）； L 画直线到（lineto）；Z 闭合路径。

defs 用于自定义形状，仅供引用。

之前绘制过一个静态的多边形，我直接用 path 来绘制的路线。path 中的 d 属性代表绘制顺序，每个字母代表一个绘制动作，后面跟着坐标。

其实现动画可通过 animate 和 animateMotion 还有 JS + RAF 去控制

canvas： 利用 canvas 的 translate，scale，rotate，也可以不断擦除和重绘实现动画帧率效果。GPU 上的内容不需要昂贵的回读（例如加速视频 Canvas2D 或 WebGL ）。

canvas 是脚本调用各种方法生成图像。获取到其 DOM 元素后可通过 getContext 获取其上下文对象，然后利用上下文对象去绘制图形和图像处理。

SVG 则是一个 XML 文件，叫可缩放矢量图，属于对图像形状的描述，通过各种子元素生成图像。可通过 JS 和 CSS 进行操作。

three.js 场景 相机 渲染器 OpenGL 是最常用的跨平台图形库，WebGL 是基于 OpenGL 设计的面向 web 的图形化标准，提供了一系列 JavaScript API，通过这些 API 进行图形渲染将得以利用图形硬件从而获得较高性能。 而 Three.js 是通过对 WebGL 接口的封装与简化而形成的一个易用的图形库。

## Three.js 的坐标系和 canvas 的坐标系的区别

three 采用右手坐标系，场景，相机，渲染器

材质，纹理贴图，加载外部 3D 模型，如 obj，json，gltf 等格式文件。

canvas 通过 js 调用上下文对象进行绘制，通过 getContext 方式，可指定参数为 2d 或 webgl

提供了上下文对象的 translate，scale，rotate 等基本功能。

## svg 和 canvas 的区别？以及你用过哪些？

Canvas 是 HTML5 的画布元素，在使用 Canvas 时，需要用到 Canvas 的上下文，可以用 2D 上下文绘制二维的图像，也可以使用 3D 上下文绘制三维的图像，其中 3D 上下文就是指 WebGL。

## 知道 react 常见优化方案

优化点

1. 减少渲染的节点 / 降低渲染计算量

   - 不在渲染函数里进行不必要的计算
   - 减少不必要的嵌套，可用 React.Fragments
   - 虚拟列表
   - 惰性渲染，必要时才去渲染，比如 Tab 中的内容。
   - 选择合适的样式方案 css > css in js > inline style

2. 避免重新渲染
   - 简化 props
   - 不变的事件处理器
   - 不可变数据
   - 简化 state
   - 使用 recompose 精细化对比
3. 精细化渲染
   - 响应式数据的精细化渲染
   - 不要滥用 Context

## 为什么要实现 React hook

注意事项

1. 不要在循环，条件，嵌套函数中调用 hook，必须在顶层使用

   因为 react 是要利用调用顺序来正确更新相应的状态。如果不在顶层使用可能会导致调用顺序的不一致。

2. useState 设置状态的时候，只有第一次生效，后期需要更新状态，必须通过 useEffect

3. 使用 useState 时候，要用声明式的更新状态，尽量不要使用 push，pop，splice 等直接更改状态

## 为什么要用 TS

程序：数据 + 逻辑 => 数据结构 + 算法

静态类型检查、直接编译到原生 js、引入新的语法糖

静态类型更有利于构建大型应用

1. 静态类型可以在编译阶段提前发现问题
2. 静态类型对阅读代码是友好的

强类型：不容忍隐式类型转换

弱类型：容忍隐式类型转换

静态类型：编译的时候就知道每一个变量的类型。因为类型错误而不能做的事情是语法错误。

动态类型：编译的时候不知道每一个变量的类型。因为类型错误而不能做的事情是运行错误。

![img](https://pic3.zhimg.com/80/b0aeb7ffd1667b9162e5329154d43777_720w.jpg?source=1940ef5c)

## JSBridge 的用途

提供了一个 JS 和 Native 双向通信的通道。

JS 单独运行在它的环境下，与原生运行环境天然隔离，所以 Native 和 JS 的每次互相调用都可以看成一次 RPC 调用。远程过程调用。

## Docker 和 K8S

docker 就是 搭建 发送 运行

三大核心概念就是 镜像 容器 仓库

K8S 是基于容器的集群管理平台

## 移动端预加载

添加 prefetch 和 preload

可直接在 link 标签里设置 rel

也可通过 webpack 中的 import()添加魔法注释

## 闭包有哪些使用场景

1. 立即执行函数，里面包含了全局 window 和当前作用域
2. 定时器等异步操作中使用了回调函数，实际上就是应用了闭包，保存了全局 window 和当前作用域
3. 实现节流和防抖函数的时候也可以应用闭包，保存变量。

## 寄生式组合继承和 class 继承的区别

寄生式组合继承：

1. 利用构造函数实现实例的属性和方法的继承
2. 利用原型链实现共享原型属性和方法的继承

class 继承：

1. 利用 class 定义类，extends 实现类的继承
2. 子类 constructor 里调用 super()父类构造函数实现实例的属性和方法的继承
3. 子类原型继承父类原型，实现原型对象上方法的继承

## 为什么要引入微任务？

可以想成如何处理回调？大概有三种方式

1. 使用同步回调，这样会导致整个脚本阻塞
2. 使用异步回调，但是在所有宏任务的队尾，这样会导致如果当前宏任务队列较长，回调得不到及时的执行。
3. 使用异步回调，放到当前宏任务最后面，可以解决实时性的问题。

## BigInt 使用

BigInt 是一种新的数据类型，用于当整数值大于 Number 数据类型支持的范围时。这种数据类型允许我们安全地对`大整数`执行算术操作，表示高分辨率的时间戳，使用大整数 id，等等，而不需要使用库。

- 为什么需要 BigInt?

  在 JS 中，所有的数字都以双精度 64 位浮点格式表示，那这会带来什么问题呢？

  这导致 JS 中的 Number 无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS 中的 Number 类型只能安全地表示-9007199254740991(-(2^53-1))和 9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。

## 字符串 replace 方法和实现 replaceAll

如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。

```js
const str = 'dogdogdog';
const str2 = str.replace(new RegExp('dog'), 'cat');
const str3 = str.replace(new RegExp('dog', 'gm'), 'cat');
console.log(str2);

console.log(new RegExp('dog', 'g'));
```

## Math 对象方法和生成随机数的方式

| 方法 | 描述 |
| :-- | :-- |
| [ceil(x)](https://www.runoob.com/jsref/jsref-ceil.html) | 对数进行上舍入，即向上取整。 |
| [floor(x)](https://www.runoob.com/jsref/jsref-floor.html) | 对 x 进行下舍入，即向下取整。 |
| [round(x)](https://www.runoob.com/jsref/jsref-round.html) | 四舍五入。 |
| [random()](https://www.runoob.com/jsref/jsref-random.html) | 返回 0 ~ 1 之间的随机数，包含 0 不包含 1。 |

```js
Math.ceil(Math.random() * 10); // 获取从 1 到 10 的随机整数，取 0 的概率极小。

Math.round(Math.random()); // 可均衡获取 0 到 1 的随机整数。

Math.floor(Math.random() * 10); // 可均衡获取 0 到 9 的随机整数。

Math.round(Math.random() * 10); // 基本均衡获取 0 到 10 的随机整数，其中获取最小值 0 和最大值 10 的几率少一半。
```

## Promise.all 中如何失败也执行.then 方法

核心内容是 map 方法，map 的每一项都是 promise，catch 方法返回值会被 promise.reslove()包裹，这样传进 promise.all 的数据都是 resolved 状态的。

```js
Promise.all(
  [
    Promise.reject({ code: 500, msg: '服务异常' }),
    Promise.resolve({ code: 200, list: [] }),
    Promise.resolve({ code: 200, list: [] }),
  ].map((p) => p.catch((e) => e)),
)
  .then((res) => {
    console.log('res=>', res);
  })
  .catch((error) => {
    console.log('error=>', error);
  });
// [ { code: 500, msg: '服务异常' },{ code: 200, list: [] },{ code: 200, list: [] } ]
```

## 数组实例操作的几种方式

不修改原数组的

| 类别 | concat | every | filter | find / findIndex | flat | forEach | includes | indexof | join |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 返回值 | 合并两个或多个数组 | 布尔值，全部通过 | 过滤 | 查找项 / 索引 | 指定深度递归展平 | 遍历 | 包含 | 元素 index | 所有元素拼接成字符串按照- |

修改原数组的

| 类别   | push           | pop                | unshift                | shift              |
| ------ | -------------- | ------------------ | ---------------------- | ------------------ |
| 返回值 | 新数组的新长度 | 末尾弹出，弹出的项 | 前面加一项，新数组长度 | 头部弹出，弹出的项 |

## webpack 如何自适应手机端

使用 postcss-pxtorem

## 使用 defineproperty 实现一个双向绑定

是利用了 Object.defineProperty()这个方法重新定义了对象获取属性值 get 和设置属性值 set 的操作来实现的。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <span id="box">
      <h1 id="text"></h1>
      <input type="text" id="input" oninput="inputChange(event)" />
      <button id="button" onclick="clickChange()">Click me</button>
    </span>
    <script>
      const input = document.getElementById('input');
      const text = document.getElementById('text');
      const button = document.getElementById('button');
      const data = {
        value: '',
      };

      function defineProperty(obj, attr) {
        let val;

        Object.defineProperty(obj, attr, {
          set(newValue) {
            console.log('set');
            if (val === newValue) {
              return;
            }
            val = newValue;
            input.value = newValue;
            text.innerHTML = newValue;
          },

          get() {
            console.log('get');
            return val;
          },
        });
      }

      defineProperty(data, 'value');

      function inputChange(event) {
        data.value = event.target.value;
      }

      function clickChange() {
        data.value = 'hello';
      }
    </script>
  </body>
</html>
```

## 使用 Proxy 实现一个双向绑定

## 实现双向绑定 Proxy 比 defineproperty 优劣如何？

1. Object.definedProperty 的作用是劫持一个对象的属性，劫持属性的 getter 和 setter 方法，在对象的属性发生变化时进行特定的操作。而 Proxy 劫持的是整个对象。
2. Proxy 会返回一个代理对象，我们只需要操作新对象即可，而 `Object.defineProperty` 只能遍历对象属性直接修改。
3. Object.definedProperty 不支持数组，更准确的说是不支持数组的各种 API，因为如果仅仅考虑 arry[i] = value 这种情况，是可以劫持的，但是这种劫持意义不大。而 Proxy 可以支持数组的各种 API。
4. 尽管 Object.defineProperty 有诸多缺陷，但是其兼容性要好于 Proxy.

## 实现一个 EventEmitter 类

```js
class EventEmitter {
  constructor() {
    this.handler = {};
  }

  on(eventName, callback) {
    if (!this.handles) {
      this.handles = {};
    }
    if (!this.handles[eventName]) {
      this.handles[eventName] = [];
    }
    this.handles[eventName].push(callback);
  }

  emit(eventName, ...arg) {
    if (this.handles[eventName]) {
      for (var i = 0; i < this.handles[eventName].length; i++) {
        this.handles[eventName][i](...arg);
      }
    }
  }
}
```

## flex 整体说一下

有主轴和交叉轴

在容器上常用的有

1. flex-direction 决定主轴的方向。

2. justify-content 属性定义了项目在主轴上的对齐方式。

3. align-items 属性定义项目在交叉轴上如何对齐。

在项目上常用的有

1. order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。
2. flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。
3. flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。
4. flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。
5. flex 属性是 flex-grow，flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。

## 客户端渲染和服务端渲染

客户端渲染：html 仅作为静态文件，解析完 js 之后进行 dom 修改

history 模式下 try_files $uri $uri/ index.html;

服务端渲染：在特定区域已经用数据填充，客户端只进行解析 html，有利于 SEO，因为不仅仅对于其中的 head 头还有其中的内容。

同构：是客户端渲染和服务端渲染的整合，代码总共执行两次，在客户端可进行交互

## React Fiber

作用：Fiber 可以提升复杂 React 应用的可响应性和性能。Fiber 即是 React 新的调度算法。

与 Generator 中的协程概念类似，Generator 是交出函数的执行权，而 fiber 是交出浏览器的控制权，比如当前有一个 react 渲染任务，同时有一个事件响应任务，或手势操作任务，这个任务比 react 的渲染任务优先级更高，则 react 就会交出浏览器控制权，等到浏览器空闲后再继续。

没有使用 Generator 语法层次的让出机制，而是通过 Fiber 这个执行单位实现了自己的调度让出机制。直白说法：编译器直接把 jsx 编译成 generator 然后在里面插一些 yield。

## Map Set weakMap weakSet 的区别

Set 是 ES6 新增的一种新的数据结构，类似数组，其成员是唯一且无序的，没有重复的值。

```js
new Set([iterable]);
// add delete has clear 清空
```

WeakSet 允许你将弱引用对象储存在一个集合中，只能储存对象引用，不能存放值，而 Set 对象都可以

WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素。

Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键

```js
// 任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数
const set = new Set([
  ['foo', 1],
  ['bar', 2],
]);
const m1 = new Map(set);
m1.get('foo'); // 1

const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz'); // 3
```

WeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。

注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。

## ===和 Object.is 的区别

| 数据  | Object.is | ===  | Set  | Map  |
| :---- | --------- | ---- | ---- | ---- |
| NaN   | 相等      | 不等 | 相等 | 相等 |
| +0 -0 | 不等      | 相等 | 相等 | 相等 |

## scrollTop 和 offsetTop 的位置

![img](https://user-gold-cdn.xitu.io/2019/4/2/169dd79558ce2af9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

![img](https://img-blog.csdn.net/20180104085724397)

## 前端微服务如何兼容老系统中的新系统开发，现在有多个 spa 的项目，有 angular 的，有 vue 的和 react 的，如何将他们合并成一个大统一的 spa 项目

| 方案 | 描述 | 优点 | 缺点 |
| --- | --- | --- | --- |
| Nginx 路由转发 | 通过 Nginx 配置反向代理来实现不同路径映射到不同应用，例如 www.abc.com/app1 对应 app1，www.abc.com/app2 对应 app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置。 | 简单，快速，易配置 | 在切换应用时会触发浏览器刷新，影响体验 |
| iframe 嵌套 | 父应用单独是一个页面，每个子应用嵌套一个 iframe，父子通信可采用 postMessage 或者 contentWindow 方式 | 实现简单，子应用之间自带沙箱，天然隔离，互不影响 | iframe 的样式显示、兼容性等都具有局限性；太过简单而显得 low |
| Web Components | 每个子应用需要采用纯 Web Components 技术编写组件，是一套全新的开发模式 | 每个子应用拥有独立的 script 和 css，也可单独部署 | 对于历史系统改造成本高，子应用通信较为复杂易踩坑 |
| 组合式应用路由分发 | 每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载，启动，卸载，以及通信机制 | 纯前端改造，体验良好，可无感知切换，子应用相互隔离 | 需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点 |

## webp 具体兼容方式以及判断

优点：更优的图像压缩算法提供高质量的图片，更小的图片体积。

问题有 平台兼容性问题以及其解码时间要更长，但体积缩小了，利大于弊。

判断兼容方法：

1. 可以采用 picture 标签的方式加载，可包含多个 source 和一个 img 为不同的设备场景提供图像版本，可在 source 上设置 media 或 type。

## 遍历一个 DOM 树

```js
// 借用一下前面的
function traversal(node) {
  const stack = [];
  stack.push(node);
  while (stack.length > 0) {
    const elem = stack.pop();
    if (elem && elem.nodeType === 1) {
      console.log('tagName: ', elem.tagName);
      const children = elem.children;
      for (let i = 0, len = children.length; i < len; i++) {
        stack.push(children[i]);
      }
    }
  }
}

traversal(document.body);
```

## 设计一个攻击服务器的策略

- 前段时间很火的一个例子，伪造虚假 npm 包 + nodejs 版本的 payload
- nodejs 的反序列化攻击

## SEO 优化

- title 标签优先级最大，强调重点即可，然后 meta 标签中的 name 为 description 的 content 将页面内容大概概况，然后还有 keywords 可设置网站的关键词
- 语义化的 HTML 标签
- 非装饰的图片必须加 alt 添加描述
- 重要内容不要用 JS 控制
- 少用 iframe

## 前后端分离项目如何 SEO 优化

使用预渲染技术 prerender

有提供这种的服务，也有 webpack 的插件提供 prerender-spa-plugin

手动实现思路：在百度上找出常见的爬虫，在 nginx 判断访问页面的用户的 User-Agent 是否为爬虫，如果是，则用 Nginx 反向代理到我们自己实现的爬虫服务器上，通过自己的爬虫服务器爬自己的项目，可以通过 nodejs 和 puppeteer。最终得到数据后返回给百度的爬虫。

puppeteer 是一个 chrome 出品的库，提供一系列 api，在 UI 的情况下调用 chrome 的功能，适用爬虫，自动化处理等。

## 1000 div 问题

- 一次性插入 1000 个 div，如何优化插入的性能
  - 使用 Fragment

```js
var fragment = document.createDocumentFragment();
fragment.appendChild(elem);
```

- 向 1000 个并排的 div 元素中，插入一个平级的 div 元素，如何优化插入的性能
  - 先 display:none 然后插入 再 display:block
  - 赋予 key，然后使用 virtual-dom，先 render，然后 diff，最后 patch
  - 脱离文档流，用 GPU 去渲染，开启硬件加速

## 在浏览器端，用 js 存储 2 万个小球的信息，包含小球的大小，位置，颜色等，如何做到对这 2 万条小球信息进行最优检索和存储

你面试阿里和腾讯，能否上 p7 和 t31，就看你对开放题能答有多深和多广。

这题目考察你如何在浏览器端中进行大数据的存储优化和检索优化。

如果你仅仅只是答用数组对象存储了 2 万个小球信息，然后用 for 循环去遍历进行索引，那是远远不够的。

这题要往深一点走，用特殊的数据结构和算法进行存储和索引。

然后进行存储和速度的一个权衡和对比，最终给出你认为的最优解。

我提供几个能触及阿里 p7 和腾讯 t31 级别的思路：

- 用 ArrayBuffer 实现极致存储
- 哈夫曼编码 + 字典查询树实现更优索引
- 用 bit-map 实现大数据筛查
- 用 hash 索引实现简单快捷的检索
- 用 IndexedDB 实现动态存储扩充浏览器端虚拟容量
- 用 iframe 的漏洞实现浏览器端 localStorage 无限存储，实现 2 千万小球信息存储

## 接上一题如何尽可能流畅的实现这 2 万小球在浏览器中，以直线运动的动效显示出来

这题考察对大数据的动画显示优化，当然方法有很多种。

但是你有没有用到浏览器的高级 api？

你还有没有用到浏览器的专门针对动画的引擎？

或者你对 3D 的实践和优化，都可以给面试官展示出来。

提供几个思路：

- 使用 GPU 硬件加速
- 使用 webGL
- 使用 assembly 辅助计算，然后在浏览器端控制动画帧频
- 用 web worker 实现 javascript 多线程，分块处理小球
- 用单链表树算法和携程机制，实现任务动态分割和任务暂停、恢复、回滚，动态渲染和处理小球

## 0.1 + 0.2 的问题，JS 浮点数的问题，你是如何避免的

js 是遵守 IEEE754 规范的

所有 Number 都是以 64-bit 双精度浮点数存储的，其划分了 3 端，是 1-11-52 模式。

1 表示最高位，0 表示正，1 表示负

11 表示指数部分

52 表示尾数部分，也就是有效域部分

```js
function add() {
  const args = [...arguments];
  const maxLen = Math.max.apply(
    null,
    args.map((item) => {
      const str = String(item).split('.')[1];
      return str ? str.length : 0;
    }),
  );
  return args.reduce((sum, cur) => sum + cur * 10 ** maxLen, 0) / 10 ** maxLen;
}
console.log(add(0.1, 0.2)); // => 0.3
console.log(add(10, 11)); // => 21
console.log(add(0.001, 0.003)); // => 0.004
console.log(add(0.001, 0.003, 0.005)); // => 0.009
console.log(add(0.001)); // => 0.001
```

## png8 png24 png32 的区别，并简单讲讲 png 的压缩原理

png8 指的是 8bits，用 2 的 8 次方即 256 种颜色表示。

png24 用三个 8bits 分别去表示 R，G，B

png32 在 png24 上加了一个 8bits 来表示 A

压缩

1. 预解析，对其进行预处理
2. 压缩 用一些算法进行编码

## git 丢弃提交

git reset：丢弃提交，将最新提交的指针回到以前某个节点。默认不加 hard 会保存在暂存区，加 hard 会直接更改文件。

git reflog：要重返未来，查看命令历史，以便确定回到哪个版本。

git cherry-pick：将指定的提交应用于其他分支。

## 在 web 安全方面，有什么实际的经验？

- 同源策略

  限制不同源 JS 脚本操作 DOM 问题，限制不同源站点读取 Cookie，LocalStorage 等，限制通过 XML，fetch 请求接口。

  解决：

  Cookie 可设置作用域 document.domain 设置为同一二级域，适用于 Cookie 和 iframe。document.path 为路径。LocalStorage 和 IndexDB 可以通过 postMessage 这个来通信。

  ```bash
  www.   zhihu.  com     .
  三级域  二级域   顶级域  根域
  www.   zhihu. com.   cn      .
  四级域  三级域  二级域  顶级域  根域
  ```

  CORS

- XSS 跨站脚本攻击（Cross Site Scripting）

  恶意评论 在用户输入存储的地方做转码

  中间人截取 DOM，读取 cookie 等

  设置 cookie 为 httponly。

  设置 CSP，内容安全策略，白名单形式，非白名单的内容无法正常执行。

- CSRF （Cross-site request forgery）

  利用用户的登录状态发起的跨站请求

  可设置 Cookie 的 SameSite，strict 会完全禁止三方的 Cookie，Lax 在 a 链接或 get 表单时会携带，None 任何情况都会发送，但必须加上 Secure，必须支持 https

  可

  验证 Origin 域名信息，Referer 具体的 URL 路径。

  使用 Token 作为验证信息 放在请求头中的 Authorization 中

- 点击劫持

  点击透明 iframe 中的按钮

  添加 X-Frame-Options 响应头，可设置 Deny，SameOrigin，Allow from

- window.opener 安全问题

  A 页通过 target="\_blank"的 a 标签打开 B 页，B 页可通过 window.opener 获取 A 页的 window 对象。可设置其 window.opener.location 改写 A 页地址进行钓鱼操作。

  通过在 a 标签设置 rel 属性，rel="noopener noreferrer" 使得 B 页的 window.opener 的值为 null，后面的 noreferrer 是为了兼容旧浏览器。

  将外链替换为内部的跳转连接服务，跳转时先跳到内部地址，在由服务器 redirect 到外链。

- SQL 注入

  拼接 SQL 未仔细过滤，例如查文章时，动态拼接字符串，1=1 永远是 true，导致 where 语句永远是 true。

  禁止利用动态拼接字符串的方式访问数据库

  对数据库操作赋予权限控制

1. HTTPS

   对称加密：加密和解密都是同一个密钥，可能会被窃取

   非对称加密：A 和 B 有两把密钥，A 加密后的数据包只能通过 B 解密，B 加密后的数据包只能通过 A 解密。

   过程

   1. 浏览器发起请求，携带自己支持的一套加密规则和一个随机数
   2. 服务器收到后将自身的网站的证书和一个随机数和确定双方要使用的加密规则
   3. 浏览器收到之后，首先校验证书的合法性，如果合法，则会生成一个随机数，通过证书的公钥进行加密，将这个加密后的发送给服务端。
   4. 服务器使用自己的私钥解密出客户端发来的随机数
   5. 服务器和客户端根据约定的加密方法，使用前面三个随机数，生成对话密钥，利用对称加密算法进行加密传输。

## 性能优化详细

**网站加载速度**

1. 设置强缓存从硬盘或内存中读取 200 from disk cache 或者 from memory cache

2. 设置协商缓存

3. 避免重定向

4. 设置 gzip

5. 减少 http 请求次数

   下载 src 设置的 url 会阻塞，并且对每个域名的连接数是有限制的。

   - 图片 base64 编码形式
   - 雪碧图

6. 合理设置 script 标签的 async 和 defer

7. 合理设置 link 标签的 rel 属性设置 prefetch 和 preload 预先加载

   ```html
   <!-- preload 下载顺序权重提高，可以放一些页面必须的 web 字体包，因中文字体包一般较大。 -->
   <link rel="preload" href="fonts" />
   ```

   ```html
   <!-- prefetch 告诉浏览器这个资源将来可能需要，不会阻塞onload事件。但是什么时间加载这个资源是由浏览器来决定的，可以加速下一次的导航。 -->
   <link rel="prefetch" href="/library.js" as="script" />
   ```

8. 可设置 DNS 预解析，预先获得域名所对应的 IP

   ```html
   <link rel="dns-prefetch" href="//yi.cn" />
   ```

9. CDN 缓存

   将静态资源缓存到最近的机房

10. 使用体积小，可缓存的网站图标

    因为不管页面中是否设置，浏览器都会尝试请求，所以最好存在，且体积较小。

11. Cookie 的优化

    减小其大小，设置合理的作用域 domain，设置合理的过期时间

12. 图片懒加载

    监测图片在当前视口，初始可以是同一张空白图片。将 data-src 属性设置到 src 上进行懒加载

**网站执行速度**

1. 对滚动加载事件做节流

2. 对按钮频繁点击请求事件做防抖
3. 在 JS 执行时尽量传入类型一致的变量来进行函数调用，生成更多的机器码，提升 JS 执行效率。
4. 减少 DOM 的重排
   - 分离读写操作，缓存一些布局信息
   - 利用 class 类名的方式一次改变样式
   - 脱离文档流
   - 提升为合成层，开启硬件加速

## 图片懒加载

```html
<img src="default.jpg" data-src="http://www.xxx.com/target.jpg" /></img>
```

方案一：采用 clientHeight、scrollTop、offsetTop

```js
let img = document.document.getElementsByTagName('img');
let count = 0; //计数器，从第一张图片开始计

lazyload(); //首次加载别忘了显示图片

window.addEventListener('scroll', lazyload);

function lazyload() {
  let viewHeight = document.documentElement.clientHeight; //视口高度
  let scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条卷去的高度
  for (let i = count; i < num; i++) {
    // 元素现在已经出现在视口中
    if (img[i].offsetTop < scrollHeight + viewHeight) {
      if (img[i].getAttribute('src') !== 'default.jpg') continue;
      img[i].src = img[i].getAttribute('data-src');
      count++;
    }
  }
}
```

```js
// throttle函数我们上节已经实现
window.addEventListener('scroll', throttle(lazyload, 200));
```

方案二：getBoundingClientRect

```js
function lazyload() {
  for (let i = count; i < num; i++) {
    // 元素现在已经出现在视口中
    if (img[i].getBoundingClientRect().top < document.documentElement.clientHeight) {
      if (img[i].getAttribute('src') !== 'default.jpg') continue;
      img[i].src = img[i].getAttribute('data-src');
      count++;
    }
  }
}
```

方案三：IntersectionObserver

```js
let img = document.document.getElementsByTagName('img');

const observer = new IntersectionObserver((changes) => {
  //changes 是被观察的元素集合
  for (let i = 0, len = changes.length; i < len; i++) {
    let change = changes[i];
    // 通过这个属性判断是否在视口中
    if (change.isIntersecting) {
      const imgElement = change.target;
      imgElement.src = imgElement.getAttribute('data-src');
      observer.unobserve(imgElement);
    }
  }
});
observer.observe(img);
```

## 你觉得项目有哪些不足

## 你最近在关注哪些前端部分

## 前端组件库建设

## 技术深度以及之前是否有对源码有一些研究

## 你的优点

## 你觉得你最擅长什么？

## 你的缺点，后续如何改进，以及一些成效

## 性能 3D 词云
